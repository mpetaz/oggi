<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>🎯 AI Betting - Moreno & Marco</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #2d3748; line-height: 1.6; min-height: 100vh;
}

.container { max-width: 1400px; margin: 0 auto; padding: 2rem; }

.app-header { text-align: center; margin-bottom: 2rem; color: white; }
.app-header h1 { font-size: 2.5rem; font-weight: 800; margin-bottom: 0.5rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
.app-header p { font-size: 1.1rem; opacity: 0.9; }

nav.menu {
    background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); padding: 1.5rem;
    border-radius: 20px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1); margin-bottom: 2rem;
}

nav.menu ul { list-style: none; display: flex; gap: 1.5rem; justify-content: center; flex-wrap: wrap; }

nav.menu ul li button {
    background: linear-gradient(135deg, #667eea, #764ba2); border: none; color: white;
    padding: 1rem 2rem; cursor: pointer; border-radius: 25px; font-weight: 600; font-size: 1rem;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
}

nav.menu ul li button:hover, nav.menu ul li button.active {
    transform: translateY(-3px); box-shadow: 0 12px 30px rgba(102, 126, 234, 0.4);
}

.section {
    background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); padding: 2.5rem;
    border-radius: 25px; box-shadow: 0 15px 50px rgba(0, 0, 0, 0.1); margin-bottom: 2rem;
}

.section h2 { color: #4a5568; margin-bottom: 2rem; font-size: 1.8rem; font-weight: 700; text-align: center; position: relative; }

.section h2::after {
    content: ''; position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%);
    width: 60px; height: 3px; background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 2px;
}

.user-selection { background: rgba(102, 126, 234, 0.1); padding: 1.5rem; border-radius: 15px; margin-bottom: 2rem; }
.user-selection label { display: block; font-weight: 600; margin-bottom: 0.5rem; color: #4a5568; }

.scoring-controls {
    background: rgba(16, 185, 129, 0.1); padding: 1.5rem; border-radius: 15px; margin-bottom: 2rem;
    border: 2px solid rgba(16, 185, 129, 0.2);
}

.scoring-grid {
    display: grid; grid-template-columns: 1fr 1fr auto; gap: 1rem; align-items: end;
}

.database-controls {
    background: rgba(59, 130, 246, 0.1); padding: 1.5rem; border-radius: 15px; margin-bottom: 2rem;
    border: 2px solid rgba(59, 130, 246, 0.2);
}

.database-grid {
    display: grid; grid-template-columns: 1fr 1fr auto auto auto; gap: 1rem; align-items: end;
}

.filters-advanced {
    background: rgba(102, 126, 234, 0.05); padding: 1.5rem; border-radius: 15px; margin-bottom: 2rem;
    border: 2px solid rgba(102, 126, 234, 0.1);
}

.filters-grid {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; align-items: end;
}

.filter-group {
    display: flex; flex-direction: column;
}

.filter-group label {
    font-size: 0.9rem; margin-bottom: 0.5rem; color: #4a5568; font-weight: 600;
}

.filter-group select, .filter-group input {
    padding: 0.7rem; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 0.9rem;
}

.date-filters {
    display: grid; grid-template-columns: 1fr 1fr auto auto; gap: 1rem; align-items: end;
}

.user-filters {
    display: grid; grid-template-columns: 1fr auto; gap: 1rem; align-items: end; margin-bottom: 1rem;
}

.stats-simple { 
    display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-top: 2rem; 
}

.stat-box { 
    background: white; padding: 2rem; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); text-align: center; 
}

.stat-box h3 { 
    font-size: 3rem; margin-bottom: 0.5rem; font-weight: 800; 
}

.stat-box p { 
    color: #6b7280; font-weight: 600; font-size: 1rem; 
}

.stat-box.total h3 { color: #3b82f6; }
.stat-box.win h3 { color: #10b981; }
.stat-box.lose h3 { color: #ef4444; }
.stat-box.winrate h3.good { color: #10b981; }
.stat-box.winrate h3.bad { color: #ef4444; }

.helper-note {
    font-size: 0.85rem; color: #6b7280; font-style: italic; margin-top: 0.5rem;
}

input[type="number"] { width: 120px; padding: 0.8rem; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 1rem; background: white; }
input[type="number"]:focus { border-color: #667eea; outline: none; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }

select { width: 200px; padding: 0.8rem; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 1rem; background: white; cursor: pointer; }
select:focus { border-color: #667eea; outline: none; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }

form { display: grid; gap: 1.5rem; }
label { font-weight: 600; color: #4a5568; margin-bottom: 0.5rem; display: block; }

input[type="date"], input[type="file"] {
    width: 100%; padding: 1rem 1.2rem; border: 2px solid #e2e8f0; border-radius: 12px;
    font-size: 1rem; transition: all 0.3s ease; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

input[type="date"]:focus, input[type="file"]:focus {
    border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); outline: none; transform: translateY(-1px);
}

button.control-btn {
    padding: 1.2rem 2.5rem; font-weight: 600; border: none; border-radius: 15px; cursor: pointer;
    font-size: 1.1rem; margin-top: 1rem; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    text-transform: uppercase; letter-spacing: 0.5px;
}

button.control-btn.compact {
    padding: 0.8rem 1.5rem; font-size: 0.9rem; margin-top: 0;
}

button.control-btn.green { background: linear-gradient(135deg, #10b981, #059669); color: white; box-shadow: 0 6px 20px rgba(16, 185, 129, 0.3); }
button.control-btn.orange { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; box-shadow: 0 6px 20px rgba(245, 158, 11, 0.3); }
button.control-btn.red { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; box-shadow: 0 6px 20px rgba(239, 68, 68, 0.3); }
button.control-btn.blue { background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3); }
button.control-btn.purple { background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; box-shadow: 0 6px 20px rgba(139, 92, 246, 0.3); }
button.control-btn:hover { transform: translateY(-3px); }

#estratti-container, #pronostici-container, #statistiche-container, #roi-container, #multiple-container, #alerts-container {
    background: rgba(248, 250, 252, 0.8); border-radius: 15px; padding: 1.5rem; margin-top: 2rem;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05); max-height: 70vh; overflow-y: auto;
}

table { 
    width: 100%; border-collapse: separate; border-spacing: 0; margin-top: 1rem; 
    border-radius: 12px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-size: 0.7rem;
}

th { 
    background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 0.5rem 0.3rem; 
    text-align: left; font-weight: 600; text-transform: uppercase; letter-spacing: 0.2px; 
    font-size: 0.6rem;
}

td { 
    background: white; padding: 0.5rem 0.3rem; border-bottom: 1px solid #e2e8f0; 
    transition: background-color 0.2s ease; font-size: 0.65rem;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}

td:nth-child(1) { width: 60px; }
td:nth-child(2) { width: 70px; }
td:nth-child(3) { width: 90px; }
td:nth-child(4) { width: 150px; }
td:nth-child(5) { width: 50px; text-align: center; }
td:nth-child(6) { width: 50px; text-align: center; }
td:nth-child(7) { width: 50px; text-align: center; }
td:nth-child(8) { width: 70px; text-align: center; }
td:nth-child(9) { width: 60px; text-align: center; }

tr:hover td { background-color: #f8fafc; }
tr:last-child td { border-bottom: none; }

.user-badge { 
    padding: 0.3rem 0.6rem; border-radius: 8px; color: white; font-weight: 700; 
    font-size: 0.65rem; display: inline-block; min-width: 60px; text-align: center;
}
.user-badge.moreno { background: linear-gradient(135deg, #3b82f6, #1d4ed8); }
.user-badge.marco { background: linear-gradient(135deg, #10b981, #059669); }

.badge { 
    padding: 0.25rem 0.5rem; border-radius: 10px; color: white; font-weight: 600; 
    font-size: 0.6rem; text-align: center; display: inline-block; min-width: 45px;
}
.badge.excellent { background: linear-gradient(135deg, #10b981, #059669); }
.badge.good { background: linear-gradient(135deg, #f59e0b, #d97706); }
.badge.poor { background: linear-gradient(135deg, #ef4444, #dc2626); }
.badge.win { background: linear-gradient(135deg, #10b981, #059669); }
.badge.lose { background: linear-gradient(135deg, #ef4444, #dc2626); }
.badge.pending { background: linear-gradient(135deg, #f59e0b, #d97706); }

.loading { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(102, 126, 234, 0.3); border-radius: 50%; border-top-color: #667eea; animation: spin 1s ease-in-out infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

.alert { padding: 1rem; border-radius: 8px; margin: 1rem 0; border-left: 4px solid; }
.alert.success { background: rgba(16, 185, 129, 0.1); border-color: #10b981; color: #065f46; }
.alert.warning { background: rgba(245, 158, 11, 0.1); border-color: #f59e0b; color: #92400e; }
.alert.info { background: rgba(59, 130, 246, 0.1); border-color: #3b82f6; color: #1e3a8a; }
.alert.danger { background: rgba(239, 68, 68, 0.1); border-color: #ef4444; color: #991b1b; }

.tab-container {
    margin-bottom: 1.5rem;
}

.tab-buttons {
    display: flex;
    border-bottom: 2px solid #e2e8f0;
    margin-bottom: 1rem;
}

.tab-button {
    padding: 0.75rem 1.5rem;
    background: none;
    border: none;
    cursor: pointer;
    font-weight: 600;
    color: #6b7280;
    transition: all 0.3s ease;
    border-bottom: 3px solid transparent;
}

.tab-button.active {
    color: #667eea;
    border-bottom: 3px solid #667eea;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.chart-container {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    height: 300px;
    position: relative;
}

.chart-canvas-wrapper {
    height: 250px;
    width: 100%;
}

.chart-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: #4a5568;
}

.multiple-card {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    border-left: 4px solid #667eea;
}

.multiple-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: #4a5568;
}

.multiple-odds {
    font-size: 1.5rem;
    font-weight: 700;
    color: #667eea;
    margin-bottom: 0.5rem;
}

.multiple-roi {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 1rem;
}

.multiple-roi.positive {
    color: #10b981;
}

.multiple-roi.negative {
    color: #ef4444;
}

.multiple-matches {
    font-size: 0.9rem;
    color: #6b7280;
}

.alert-item {
    background: white;
    border-radius: 12px;
    padding: 1rem;
    margin-bottom: 0.75rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    border-left: 4px solid;
}

.alert-item.warning {
    border-left-color: #f59e0b;
}

.alert-item.danger {
    border-left-color: #ef4444;
}

.alert-item.info {
    border-left-color: #3b82f6;
}

.alert-item.success {
    border-left-color: #10b981;
}

.alert-title {
    font-weight: 600;
    margin-bottom: 0.25rem;
}

.alert-description {
    font-size: 0.9rem;
    color: #6b7280;
}

@media (max-width: 768px) {
    .container { padding: 1rem; }
    nav.menu ul { flex-direction: column; }
    .section { padding: 1.5rem; }
    nav.menu ul li button { width: 100%; }
    .app-header h1 { font-size: 2rem; }
    .scoring-grid { grid-template-columns: 1fr; }
    .database-grid { grid-template-columns: 1fr; }
    .date-filters { grid-template-columns: 1fr; }
    .user-filters { grid-template-columns: 1fr; }
    .filters-grid { grid-template-columns: 1fr; }
    .tab-buttons { flex-wrap: wrap; }
    .chart-container { height: 250px; }
    .chart-canvas-wrapper { height: 200px; }
}
</style>
</head>
<body>
<div class="container">

<div class="app-header">
<h1>🎯 AI Betting</h1>
<p>👨‍👦 Sistema Pronostici - Moreno & Marco</p>
</div>

<nav class="menu">
<ul>
<li><button id="btn-pronostici">📊 Database Pronostici</button></li>
<li><button id="btn-inserisci" class="active">🎯 Inserisci & Salva</button></li>
<li><button id="btn-statistiche">📊 Filtri e Statistiche</button></li>
<li><button id="btn-roi">💰 Analisi ROI</button></li>
<li><button id="btn-multiple">🎲 Multiple</button></li>
<li><button id="btn-alerts">⚠️ Alert</button></li>
</ul>
</nav>

<!-- SEZIONE PRONOSTICI -->
<div id="section-pronostici" class="section" style="display:none;">
<h2>📊 Database Pronostici</h2>

<div class="user-selection">
<label for="view-user">👥 Visualizza pronostici di:</label>
<select id="view-user">
<option value="both">🔵🟢 Entrambi</option>
<option value="moreno">🔵 Solo Moreno</option>
<option value="marco">🟢 Solo Marco</option>
</select>
</div>

<div class="database-controls">
<h4 style="margin-bottom: 1rem; color: #3b82f6;">🗂️ Controlli Database</h4>
<div class="database-grid">
<div>
<label for="db-date-from">📅 Da:</label>
<input type="date" id="db-date-from"/>
<div class="helper-note">(lasciare vuote per tutto il database)</div>
</div>
<div>
<label for="db-date-to">📅 A:</label>
<input type="date" id="db-date-to"/>
</div>
<button type="button" id="btn-view-filtered" class="control-btn blue compact">🔵 Vedi Pronostici</button>
<button type="button" id="btn-delete-filtered" class="control-btn orange compact">🟠 Cancella Filtrati</button>
<button type="button" id="btn-delete-user-all" class="control-btn red compact">💀 Cancella Tutto Utente</button>
</div>
</div>

<div id="pronostici-container">
<div style="text-align: center; padding: 3rem; color: #6b7280;">
<h3>📊 Database Pronostici</h3>
<p>Usa i controlli sopra per vedere o gestire i pronostici</p>
</div>
</div>
</div>

<!-- SEZIONE INSERISCI -->
<div id="section-inserisci" class="section">
<h2>🎯 Inserisci e Salva Pronostici</h2>

<div class="user-selection">
<label for="current-user">👤 Utente:</label>
<select id="current-user">
<option value="moreno">🔵 Moreno</option>
<option value="marco">🟢 Marco</option>
</select>
</div>

<div class="scoring-controls">
<h4 style="margin-bottom: 1rem; color: #10b981;">⚙️ Controlli Scoring Avanzato</h4>
<div class="scoring-grid">
<div>
<label for="score-threshold">🎯 Soglia Punteggio Minimo:</label>
<input type="number" id="score-threshold" value="45" min="20" max="100"/>
<small style="color: #6b7280;">Salva tutte le partite con punteggio ≥ soglia</small>
</div>
<div>
<label for="max-selections">🔢 Massimo Partite:</label>
<input type="number" id="max-selections" value="10" min="5" max="50"/>
<small style="color: #6b7280;">Limite massimo partite totali. Priorità a quelle VERDI (≥50)</small>
</div>
<button type="button" id="btn-preview" class="control-btn orange compact">👁️ Anteprima</button>
</div>
</div>

<form id="form-inserisci">
<div>
<label for="input-data">📅 Data partite:</label>
<input type="date" id="input-data" required/>
</div>
<div>
<label for="file-giorno">📄 File partite del giorno:</label>
<input type="file" id="file-giorno" accept=".csv" required/>
</div>
<div>
<label for="file-storico">📊 File storico (per calcoli):</label>
<input type="file" id="file-storico" accept=".csv" required/>
</div>
<button type="button" id="btn-estrai" class="control-btn green">🚀 Calcola e Salva Intelligente</button>
</form>
<div id="estratti-container"></div>
</div>

<!-- SEZIONE STATISTICHE -->
<div id="section-statistiche" class="section" style="display:none;">
<h2>📊 Filtri e Statistiche</h2>

<div class="user-selection">
<h4 style="margin-bottom: 1rem;">👥 Selezione Utente</h4>
<div class="user-filters">
<div>
<label for="stats-user">Visualizza partite di:</label>
<select id="stats-user">
<option value="both">🔵🟢 Entrambi</option>
<option value="moreno">🔵 Solo Moreno</option>
<option value="marco">🟢 Solo Marco</option>
</select>
</div>
<button type="button" id="btn-reset-user" class="control-btn green compact">🔄 Reset</button>
</div>
</div>

<div class="user-selection">
<h4 style="margin-bottom: 1rem;">📅 Filtro Periodo</h4>
<div class="date-filters">
<div>
<label for="data-da">Da:</label>
<input type="date" id="data-da"/>
<div class="helper-note">(lasciare vuote per tutto il database)</div>
</div>
<div>
<label for="data-a">A:</label>
<input type="date" id="data-a"/>
</div>
<button type="button" id="btn-applica-filtri" class="control-btn green compact">🔍 Applica Filtri</button>
<button type="button" id="btn-reset-date" class="control-btn green compact">🔄 Reset Date</button>
</div>
</div>

<div class="filters-advanced">
<h4 style="margin-bottom: 1rem;">🔍 Filtri Avanzati (tipo Excel)</h4>
<div class="filters-grid">
<div class="filter-group">
<label for="filter-status">Status:</label>
<select id="filter-status">
<option value="all">🔄 Tutti</option>
<option value="WIN">✅ Solo Vinte</option>
<option value="LOSE">❌ Solo Perse</option>
<option value="PENDING">⏳ Solo Pending</option>
</select>
</div>
<div class="filter-group">
<label for="filter-tip">Tip:</label>
<select id="filter-tip">
<option value="all">🎯 Tutti i Tip</option>
</select>
</div>
<div class="filter-group">
<label for="filter-lega">Lega:</label>
<select id="filter-lega">
<option value="all">🏆 Tutte le Leghe</option>
</select>
</div>
<div class="filter-group">
<label for="filter-prob-min">Prob Min %:</label>
<input type="number" id="filter-prob-min" placeholder="es: 80" min="0" max="100"/>
</div>
<div class="filter-group">
<label for="filter-quota-min">Quota Min:</label>
<input type="number" id="filter-quota-min" placeholder="es: 1.5" step="0.1" min="1"/>
</div>
<div class="filter-group">
<label for="filter-roi-min">ROI Min %:</label>
<input type="number" id="filter-roi-min" placeholder="es: 10" step="1" min="-100"/>
</div>
<div class="filter-group">
<label for="filter-winrate-min">Win Rate Min %:</label>
<input type="number" id="filter-winrate-min" placeholder="es: 70" step="1" min="0" max="100"/>
</div>
<div class="filter-group" style="align-self: end;">
<button type="button" id="btn-clear-filters" class="control-btn orange compact">🧹 Pulisci Filtri</button>
</div>
</div>
</div>

<div class="user-selection">
<h4 style="margin-bottom: 1rem;">📄 Aggiorna Risultati</h4>
<div style="display: grid; grid-template-columns: 1fr auto; gap: 1rem; align-items: end;">
<div>
<label for="file-risultati">File TOTALI risultati:</label>
<input type="file" id="file-risultati" accept=".csv"/>
</div>
<button type="button" id="btn-aggiorna-risultati" class="control-btn orange compact">✅ Aggiorna Status</button>
</div>
<div id="matching-info" style="margin-top: 1rem; font-size: 0.9rem; color: #6b7280;"></div>
</div>

<div class="stats-simple">
<div class="stat-box total">
<h3 id="stat-total">0</h3>
<p>Partite Totali</p>
</div>
<div class="stat-box win">
<h3 id="stat-wins">0</h3>
<p>Vinte</p>
</div>
<div class="stat-box lose">
<h3 id="stat-losses">0</h3>
<p>Perse</p>
</div>
<div class="stat-box winrate">
<h3 id="stat-winrate">0%</h3>
<p>Win-Rate</p>
</div>
</div>

<div id="statistiche-container">
<div style="text-align: center; padding: 2rem; color: #6b7280;">
<h3>📊 Elenco Partite</h3>
<p>Applica filtri per vedere le partite del periodo/utente selezionato</p>
</div>
</div>

</div>

<!-- SEZIONE ROI -->
<div id="section-roi" class="section" style="display:none;">
<h2>💰 Analisi ROI</h2>

<div class="tab-container">
<div class="tab-buttons">
<button class="tab-button active" data-tab="roi-tip">ROI per Tip</button>
<button class="tab-button" data-tab="roi-lega">ROI per Lega</button>
<button class="tab-button" data-tab="roi-periodo">ROI per Periodo</button>
<button class="tab-button" data-tab="roi-utente">ROI per Utente</button>
</div>

<div id="roi-tip" class="tab-content active">
<div class="chart-container">
<div class="chart-title">ROI per Tip di Scommessa</div>
<div class="chart-canvas-wrapper">
<canvas id="roi-tip-chart"></canvas>
</div>
</div>
<div id="roi-tip-table"></div>
</div>

<div id="roi-lega" class="tab-content">
<div class="chart-container">
<div class="chart-title">ROI per Lega</div>
<div class="chart-canvas-wrapper">
<canvas id="roi-lega-chart"></canvas>
</div>
</div>
<div id="roi-lega-table"></div>
</div>

<div id="roi-periodo" class="tab-content">
<div class="chart-container">
<div class="chart-title">ROI per Periodo</div>
<div class="chart-canvas-wrapper">
<canvas id="roi-periodo-chart"></canvas>
</div>
</div>
<div id="roi-periodo-table"></div>
</div>

<div id="roi-utente" class="tab-content">
<div class="chart-container">
<div class="chart-title">ROI per Utente</div>
<div class="chart-canvas-wrapper">
<canvas id="roi-utente-chart"></canvas>
</div>
</div>
<div id="roi-utente-table"></div>
</div>
</div>

<div id="roi-container">
<div style="text-align: center; padding: 2rem; color: #6b7280;">
<h3>💰 Analisi ROI</h3>
<p>Seleziona una tab per visualizzare l'analisi del ROI</p>
</div>
</div>
</div>

<!-- SEZIONE MULTIPLE -->
<div id="section-multiple" class="section" style="display:none;">
<h2>🎲 Multiple Intelligenti</h2>

<div class="user-selection">
<h4 style="margin-bottom: 1rem;">⚙️ Configurazione Multiple</h4>
<div class="scoring-grid">
<div>
<label for="multiple-type">Tipo di Multipla:</label>
<select id="multiple-type">
<option value="doppia">Doppia</option>
<option value="tripla">Tripla</option>
</select>
</div>
<div>
<label for="multiple-strategy">Strategia:</label>
<select id="multiple-strategy">
<option value="sicurezza">Sicurezza (ROI basso, win rate alto)</option>
<option value="valore">Valore (ROI medio, win rate medio)</option>
<option value="rischio">Rischio (ROI alto, win rate basso)</option>
</select>
</div>
<button type="button" id="btn-generate-multiple" class="control-btn purple compact">🎲 Genera Multipla</button>
</div>
</div>

<div id="multiple-container">
<div style="text-align: center; padding: 2rem; color: #6b7280;">
<h3>🎲 Multiple Intelligenti</h3>
<p>Configura e genera multiple basate su performance storica</p>
</div>
</div>
</div>

<!-- SEZIONE ALERT -->
<div id="section-alerts" class="section" style="display:none;">
<h2>⚠️ Sistema di Alert</h2>

<div class="user-selection">
<h4 style="margin-bottom: 1rem;">⚙️ Configurazione Alert</h4>
<div class="filters-grid">
<div class="filter-group">
<label for="alert-threshold">Soglia Alert %:</label>
<input type="number" id="alert-threshold" value="20" min="5" max="50"/>
<small style="color: #6b7280;">Scostamento dalla media per generare alert</small>
</div>
<div class="filter-group">
<label for="alert-period">Periodo Analisi:</label>
<select id="alert-period">
<option value="7">Ultimi 7 giorni</option>
<option value="14">Ultimi 14 giorni</option>
<option value="30">Ultimi 30 giorni</option>
</select>
</div>
<div class="filter-group" style="align-self: end;">
<button type="button" id="btn-generate-alerts" class="control-btn orange compact">⚠️ Genera Alert</button>
</div>
</div>
</div>

<div id="alerts-container">
<div style="text-align: center; padding: 2rem; color: #6b7280;">
<h3>⚠️ Sistema di Alert</h3>
<p>Configura e genera alert per pattern anomali</p>
</div>
</div>
</div>

</div>

<script type="module">
let firebaseReady = false;
let db = null, currentUser = null;
let collection, addDoc, getDocs, doc, updateDoc, deleteDoc, where, query;
let allPredictions = [];
let allResults = [];
let fileRisultati = null;

// Chart.js per i grafici ROI
const chartScript = document.createElement('script');
chartScript.src = 'https://cdn.jsdelivr.net/npm/chart.js';
document.head.appendChild(chartScript);

async function initFirebase() {
    try {
        const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.1.0/firebase-app.js');
        const firestoreModule = await import('https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js');
        const authModule = await import('https://www.gstatic.com/firebasejs/10.1.0/firebase-auth.js');

        collection = firestoreModule.collection;
        addDoc = firestoreModule.addDoc;
        getDocs = firestoreModule.getDocs;
        doc = firestoreModule.doc;
        updateDoc = firestoreModule.updateDoc;
        deleteDoc = firestoreModule.deleteDoc;
        where = firestoreModule.where;
        query = firestoreModule.query;

        const { getFirestore, enableNetwork } = firestoreModule;
        const { getAuth, signInAnonymously, onAuthStateChanged } = authModule;

        const firebaseConfig = {
            apiKey: "AIzaSyDohOjXix2tRoEhm8vv1gCYrqXlNeXjbGM",
            authDomain: "oggi-17f48.firebaseapp.com",
            projectId: "oggi-17f48",
            storageBucket: "oggi-17f48.firebasestorage.app",
            messagingSenderId: "961828441770",
            appId: "1:961828441770:web:270382ebd68fb953ff8ad3"
        };

        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        const auth = getAuth(app);

        await enableNetwork(db);

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                firebaseReady = true;
                console.log('🔥 Firebase connesso:', user.uid);
                loadAllPredictions();
            } else {
                signInAnonymously(auth);
            }
        });

    } catch (error) {
        console.error('❌ Errore Firebase:', error);
    }
}

async function loadAllPredictions() {
    if (!firebaseReady) return;

    try {
        const snapshot = await getDocs(collection(db, 'aipredictions'));
        allPredictions = snapshot.docs.map(docSnap => ({
            id: docSnap.id,
            ...docSnap.data()
        }));

        console.log('📊 Caricati', allPredictions.length, 'pronostici da Firebase');
        populateFilters();

    } catch (error) {
        console.error('❌ Errore caricamento:', error);
    }
}

function populateFilters() {
    if (allPredictions.length === 0) return;

    const uniqueTips = [...new Set(allPredictions.map(p => p.tip))].sort();
    const filterTip = document.getElementById('filter-tip');
    filterTip.innerHTML = '<option value="all">🎯 Tutti i Tip</option>';
    uniqueTips.forEach(tip => {
        filterTip.innerHTML += '<option value="' + tip + '">' + tip + '</option>';
    });

    const uniqueLeagues = [...new Set(allPredictions.map(p => p.lega))].sort();
    const filterLega = document.getElementById('filter-lega');
    filterLega.innerHTML = '<option value="all">🏆 Tutte le Leghe</option>';
    uniqueLeagues.forEach(lega => {
        filterLega.innerHTML += '<option value="' + lega + '">' + lega + '</option>';
    });
}

const sections = {
  pronostici: document.getElementById('section-pronostici'),
  inserisci: document.getElementById('section-inserisci'),
  statistiche: document.getElementById('section-statistiche'),
  roi: document.getElementById('section-roi'),
  multiple: document.getElementById('section-multiple'),
  alerts: document.getElementById('section-alerts')
};

const buttons = {
  pronostici: document.getElementById('btn-pronostici'),
  inserisci: document.getElementById('btn-inserisci'),
  statistiche: document.getElementById('btn-statistiche'),
  roi: document.getElementById('btn-roi'),
  multiple: document.getElementById('btn-multiple'),
  alerts: document.getElementById('btn-alerts')
};

function showSection(section) {
  Object.keys(sections).forEach(key => {
    if (key === section) {
      sections[key].style.display = 'block';
      buttons[key].classList.add('active');
    } else {
      sections[key].style.display = 'none';
      buttons[key].classList.remove('active');
    }
  });
}

showSection('inserisci');
buttons.pronostici.addEventListener('click', () => showSection('pronostici'));
buttons.inserisci.addEventListener('click', () => showSection('inserisci'));
buttons.statistiche.addEventListener('click', () => showSection('statistiche'));
buttons.roi.addEventListener('click', () => showSection('roi'));
buttons.multiple.addEventListener('click', () => showSection('multiple'));
buttons.alerts.addEventListener('click', () => showSection('alerts'));

// Tab functionality
document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
        const tabId = button.getAttribute('data-tab');
        
        // Remove active class from all tabs and buttons
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        
        // Add active class to clicked button and corresponding tab
        button.classList.add('active');
        document.getElementById(tabId).classList.add('active');
        
        // Load data for the selected tab
        if (tabId === 'roi-tip') loadROITipData();
        else if (tabId === 'roi-lega') loadROILegaData();
        else if (tabId === 'roi-periodo') loadROIPeriodoData();
        else if (tabId === 'roi-utente') loadROIUtenteData();
    });
});

let fileStorico = null;
let fileGiorno = null;

function parseCSV(text) {
  const lines = text.trim().split('\n').filter(line => line.trim());
  if (lines.length < 2) return [];

  const headerLine = lines[0];
  const headers = [];
  let inQuotes = false;
  let currentHeader = '';

  for (let i = 0; i < headerLine.length; i++) {
    const char = headerLine[i];
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      headers.push(currentHeader.trim().toLowerCase().replace(/['"]/g, ''));
      currentHeader = '';
    } else {
      currentHeader += char;
    }
  }
  if (currentHeader) {
    headers.push(currentHeader.trim().toLowerCase().replace(/['"]/g, ''));
  }

  const data = [];
  for (let lineIndex = 1; lineIndex < lines.length; lineIndex++) {
    const line = lines[lineIndex];
    const values = [];
    let inQuotes = false;
    let currentValue = '';

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        values.push(currentValue.trim().replace(/['"]/g, ''));
        currentValue = '';
      } else {
        currentValue += char;
      }
    }
    if (currentValue) {
      values.push(currentValue.trim().replace(/['"]/g, ''));
    }

    const row = {};
    headers.forEach((h, i) => { 
      row[h] = values[i] || ''; 
    });
    data.push(row);
  }

  return data;
}

function calculateScore(partita, legheSet, tipsSet) {
  let legaScore = 0, tipScore = 0, probScore = 0, quotaValid = true;

  const lega = (partita.lega || partita.Lega || '').toLowerCase().trim();
  if (legheSet.has(lega)) legaScore = 20;
  else if (lega.startsWith('eu-')) legaScore = 5;

  let tipNorm = (partita.tip || partita.Tip || '').trim();
  if (tipNorm) {
    tipNorm = tipNorm.replace(',', '.').toUpperCase();
    const val = parseFloat(tipNorm);
    if (!isNaN(val)) tipNorm = (val >= 0 ? '+' : '-') + Math.abs(val);
  }

  if (tipsSet.has(tipNorm)) tipScore = 20;
  else if (lega.startsWith('eu-')) tipScore = 5;

  const quota = parseFloat(String(partita.quota || partita.Quota || '').replace(',', '.')) || 0;
  if (quota < 1.20) quotaValid = false;

  const prob = parseFloat((partita.probabilità || partita.probabilita || partita['Probabilità'] || '').toString().replace('%', '')) || 0;

  if (prob <= 65) {
    probScore = 0;
  } else if (prob <= 77) {
    probScore = 5;
  } else {
    probScore = 20 + (prob - 78);
  }

  return { 
    legaScore, 
    tipScore, 
    probScore: Math.round(probScore), 
    totalScore: legaScore + tipScore + Math.round(probScore), 
    quotaValid, 
    quota, 
    prob 
  };
}

document.getElementById('file-storico').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(event) { 
      fileStorico = parseCSV(event.target.result); 
    };
    reader.readAsText(file);
  }
});

document.getElementById('file-giorno').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(event) { 
      fileGiorno = parseCSV(event.target.result); 
    };
    reader.readAsText(file);
  }
});

document.getElementById('file-risultati').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(event) { 
      fileRisultati = parseCSV(event.target.result);
      allResults = fileRisultati;
      console.log('✅ File risultati caricato:', fileRisultati.length, 'righe');
      document.getElementById('matching-info').innerHTML = '📊 <strong>File caricato:</strong> ' + fileRisultati.length + ' risultati';
    };
    reader.readAsText(file);
  }
});

function previewScoring() {
  if (!fileStorico || !fileGiorno) {
    alert('⚠️ Carica prima i file per vedere l anteprima!');
    return;
  }

  const scoreThreshold = parseInt(document.getElementById('score-threshold').value) || 45;
  const maxPartite = parseInt(document.getElementById('max-selections').value) || 10;
  const container = document.getElementById('estratti-container');
  container.innerHTML = '<div class="loading"></div> 🔄 Anteprima intelligente...';

  try {
    const legheSet = new Set();
    const tipsSet = new Set();

    fileStorico.forEach(row => {
      const lega = (row.lega || row.Lega || '').toLowerCase().trim();
      const tip = (row.tip || row.Tip || '').trim();
      if (lega) legheSet.add(lega);
      if (tip) {
        let normalizedTip = tip.replace(',', '.').toUpperCase();
        const val = parseFloat(normalizedTip);
        if (!isNaN(val)) normalizedTip = (val >= 0 ? '+' : '-') + Math.abs(val);
        tipsSet.add(normalizedTip);
      }
    });

    let selections = fileGiorno.filter(row => {
      const lega = (row.lega || row.Lega || '').toLowerCase().trim();
      const tip = (row.tip || row.Tip || '').trim();

      let normalizedTip = tip.replace(',', '.').toUpperCase();
      const val = parseFloat(normalizedTip);
      if (!isNaN(val)) normalizedTip = (val >= 0 ? '+' : '-') + Math.abs(val);

      return legheSet.has(lega) && tipsSet.has(normalizedTip);
    });

    if (selections.length === 0) {
      container.innerHTML = '<div class="alert warning">❌ Nessuna partita con leghe E tip storici trovata.</div>';
      return;
    }

    selections.forEach(s => Object.assign(s, calculateScore(s, legheSet, tipsSet)));

    const validMatches = selections.filter(m => m.quotaValid && m.totalScore >= scoreThreshold);
    validMatches.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const partiteVerdi = validMatches.filter(m => m.totalScore >= 50);
    const partiteGialle = validMatches.filter(m => m.totalScore >= 45 && m.totalScore < 50);
    const partiteRosse = validMatches.filter(m => m.totalScore < 45);

    // Simula selezione con limite
    let simulatedSelection = [];
    let spazio = maxPartite;

    const verdiOrdered = [...partiteVerdi].sort((a, b) => b.totalScore - a.totalScore);
    const gialleOrdered = [...partiteGialle].sort((a, b) => b.totalScore - a.totalScore);
    const rosseOrdered = [...partiteRosse].sort((a, b) => b.totalScore - a.totalScore);

    const verdiSel = verdiOrdered.slice(0, Math.min(spazio, verdiOrdered.length));
    simulatedSelection.push(...verdiSel);
    spazio -= verdiSel.length;

    if (spazio > 0) {
      const gialleSel = gialleOrdered.slice(0, Math.min(spazio, gialleOrdered.length));
      simulatedSelection.push(...gialleSel);
      spazio -= gialleSel.length;
    }

    if (spazio > 0) {
      const rosseSel = rosseOrdered.slice(0, Math.min(spazio, rosseOrdered.length));
      simulatedSelection.push(...rosseSel);
    }

    const finalVerdi = simulatedSelection.filter(m => m.totalScore >= 50).length;
    const finalGialle = simulatedSelection.filter(m => m.totalScore >= 45 && m.totalScore < 50).length;
    const finalRosse = simulatedSelection.filter(m => m.totalScore < 45).length;

    let html = '<div class="alert info">👁️ <strong>ANTEPRIMA INTELLIGENTE</strong> - Soglia: ' + scoreThreshold + ' | Limite: ' + maxPartite + ' partite</div>';
    html += '<h3>🔍 Simulazione Selezione</h3>';
    html += '<p style="margin: 1rem 0; font-size: 0.9rem;"><strong>Disponibili:</strong> ';
    html += '<span style="color: #10b981;">🟢 ' + partiteVerdi.length + ' VERDI (≥50)</span> | ';
    html += '<span style="color: #f59e0b;">🟡 ' + partiteGialle.length + ' GIALLE (45-49)</span> | ';
    html += '<span style="color: #ef4444;">🔴 ' + partiteRosse.length + ' ROSSE (<45)</span></p>';

    html += '<p style="margin: 1rem 0; font-size: 0.9rem;"><strong>Verranno selezionate:</strong> ';
    html += '<span style="color: #10b981;">🟢 ' + finalVerdi + ' VERDI</span> | ';
    html += '<span style="color: #f59e0b;">🟡 ' + finalGialle + ' GIALLE</span> | ';
    html += '<span style="color: #ef4444;">🔴 ' + finalRosse + ' ROSSE</span>';
    html += ' = <strong>' + simulatedSelection.length + ' partite totali</strong></p>';

    if (partiteVerdi.length > finalVerdi) {
      html += '<div class="alert warning">⚠️ <strong>ATTENZIONE:</strong> ' + (partiteVerdi.length - finalVerdi) + ' partite VERDI verranno escluse per rispettare il limite di ' + maxPartite + ' partite.</div>';
    }

    container.innerHTML = html;

  } catch (error) {
    container.innerHTML = '<div class="alert warning">❌ Errore: ' + error.message + '</div>';
  }
}

async function estraiESalvaPronostici() {
  const selectedDate = document.getElementById('input-data').value;
  const currentUserName = document.getElementById('current-user').value;
  const scoreThreshold = parseInt(document.getElementById('score-threshold').value) || 45;
  const maxPartite = parseInt(document.getElementById('max-selections').value) || 10;

  if (!selectedDate || !fileStorico || !fileGiorno) {
    alert('⚠️ Inserisci data e carica entrambi i file!');
    return;
  }

  if (!firebaseReady) {
    alert('⚠️ Firebase non ancora pronto!');
    return;
  }

  await loadAllPredictions();
  const esistenti = allPredictions.filter(p => 
    p.user === currentUserName && 
    p.date === selectedDate
  );

  if (esistenti.length > 0) {
    const conferma = confirm(
      '⚠️ ATTENZIONE! Trovate ' + esistenti.length + ' partite già inserite per ' + 
      selectedDate + ' di ' + currentUserName + '.\\n\\n' +
      'Continuando verranno AGGIUNTE alle esistenti (possibili duplicati).\\n\\n' +
      'Vuoi CANCELLARE prima le partite esistenti? (CONSIGLIATO)'
    );

    if (conferma) {
      const container = document.getElementById('estratti-container');
      container.innerHTML = '<div class="loading"></div> 🗑️ Pulizia database...';

      for (const pred of esistenti) {
        await deleteDoc(doc(db, 'aipredictions', pred.id));
      }

      alert('🗑️ Cancellate ' + esistenti.length + ' partite esistenti! Ora inserisco le nuove.');
      await loadAllPredictions();
    } else {
      if (!confirm('⚠️ ATTENZIONE: Le nuove partite verranno AGGIUNTE a quelle esistenti!\\nSicuro di continuare?')) {
        return;
      }
    }
  }

  const container = document.getElementById('estratti-container');
  container.innerHTML = '<div class="loading"></div> 🔄 Selezione intelligente...';

  try {
    const legheSet = new Set();
    const tipsSet = new Set();

    fileStorico.forEach(row => {
      const lega = (row.lega || row.Lega || '').toLowerCase().trim();
      const tip = (row.tip || row.Tip || '').trim();
      if (lega) legheSet.add(lega);
      if (tip) {
        let normalizedTip = tip.replace(',', '.').toUpperCase();
        const val = parseFloat(normalizedTip);
        if (!isNaN(val)) normalizedTip = (val >= 0 ? '+' : '-') + Math.abs(val);
        tipsSet.add(normalizedTip);
      }
    });

    let selections = fileGiorno.filter(row => {
      const lega = (row.lega || row.Lega || '').toLowerCase().trim();
      const tip = (row.tip || row.Tip || '').trim();

      let normalizedTip = tip.replace(',', '.').toUpperCase();
      const val = parseFloat(normalizedTip);
      if (!isNaN(val)) normalizedTip = (val >= 0 ? '+' : '-') + Math.abs(val);

      return legheSet.has(lega) && tipsSet.has(normalizedTip);
    });

    if (selections.length === 0) {
      container.innerHTML = '<div class="alert warning">❌ Nessuna partita con leghe E tip storici trovata.</div>';
      return;
    }

    selections.forEach(s => Object.assign(s, calculateScore(s, legheSet, tipsSet)));

    const validMatches = selections.filter(m => m.quotaValid && m.totalScore >= scoreThreshold);
    validMatches.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    if (validMatches.length === 0) {
      container.innerHTML = '<div class="alert warning">❌ Nessuna partita raggiunge la soglia impostata.</div>';
      return;
    }

    const partiteVerdi = validMatches.filter(m => m.totalScore >= 50);
    const partiteGialle = validMatches.filter(m => m.totalScore >= 45 && m.totalScore < 50);
    const partiteRosse = validMatches.filter(m => m.totalScore < 45);

    console.log('🟢 Partite VERDI (≥50):', partiteVerdi.length);
    console.log('🟡 Partite GIALLE (45-49):', partiteGialle.length);
    console.log('🔴 Partite ROSSE (<45):', partiteRosse.length);

    // SELEZIONE CON LIMITE
    let finalSelections = [];
    let spazio = maxPartite;

    const verdiOrdered = partiteVerdi.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const gialleOrdered = partiteGialle.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const rosseOrdered = partiteRosse.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const verdiSelezionate = verdiOrdered.slice(0, Math.min(spazio, verdiOrdered.length));
    finalSelections.push(...verdiSelezionate);
    spazio -= verdiSelezionate.length;

    if (spazio > 0) {
      const gialleSelezionate = gialleOrdered.slice(0, Math.min(spazio, gialleOrdered.length));
      finalSelections.push(...gialleSelezionate);
      spazio -= gialleSelezionate.length;
    }

    if (spazio > 0) {
      const rosseSelezionate = rosseOrdered.slice(0, Math.min(spazio, rosseOrdered.length));
      finalSelections.push(...rosseSelezionate);
    }

    finalSelections.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const verdiTagliate = partiteVerdi.length - verdiSelezionate.length;

    // Salvataggio su Firebase con feedback
    let savedCount = 0;
    let errorCount = 0;
    
    for (const match of finalSelections) {
      try {
        await addDoc(collection(db, 'aipredictions'), {
          date: selectedDate,
          user: currentUserName,
          lega: match.lega || match.Lega || '',
          partita: match.partita || match.Partita || '',
          tip: match.tip || match.Tip || '',
          quota: parseFloat(String(match.quota || match.Quota || '').replace(',', '.')) || 0,
          probabilita: match.prob,
          score: match.totalScore,
          status: 'PENDING',
          risultato: '',
          userid: currentUser.uid,
          createdat: new Date().toISOString()
        });
        savedCount++;
      } catch (error) {
        console.error('❌ Errore salvataggio singolo:', error);
        errorCount++;
      }
    }

    const userBadge = currentUserName === 'moreno' ? 
      '<span class="user-badge moreno">🔵 Moreno</span>' : 
      '<span class="user-badge marco">🟢 Marco</span>';

    let html = '<h3>🎯 SELEZIONE INTELLIGENTE - ' + finalSelections.length + ' PARTITE - ' + userBadge + ' - ' + selectedDate + '</h3>';

    if (errorCount > 0) {
      html += '<div class="alert danger">❌ <strong>Attenzione:</strong> ' + errorCount + ' partite non sono state salvate correttamente.</div>';
    } else {
      html += '<div class="alert success">✅ <strong>Salvate ' + savedCount + ' partite!</strong> (Limite: ' + maxPartite + ') Soglia: ' + scoreThreshold + ' punti</div>';
    }

    if (verdiTagliate > 0) {
      html += '<div class="alert info">⚠️ <strong>LIMITE RAGGIUNTO:</strong> Tagliate ' + verdiTagliate + ' partite VERDI per rispettare il limite di ' + maxPartite + ' partite.</div>';
    }

    const verdiFinali = finalSelections.filter(m => m.totalScore >= 50).length;
    const gialleFinali = finalSelections.filter(m => m.totalScore >= 45 && m.totalScore < 50).length;
    const rosseFinali = finalSelections.filter(m => m.totalScore < 45).length;

    html += '<p style="margin: 1rem 0; font-size: 0.9rem;"><strong>Selezione:</strong> ';
    html += '<span style="color: #10b981;">🟢 ' + verdiFinali + ' VERDI (≥50)</span> | ';
    html += '<span style="color: #f59e0b;">🟡 ' + gialleFinali + ' GIALLE (45-49)</span> | ';
    html += '<span style="color: #ef4444;">🔴 ' + rosseFinali + ' ROSSE (<45)</span></p>';

    html += '<table><thead><tr><th>Pos</th><th>Tipo</th><th>Lega</th><th>Partita</th><th>Tip</th><th>Quota</th><th>Prob%</th><th>Score</th></tr></thead><tbody>';

    finalSelections.forEach((m, index) => {
      const badgeClass = m.totalScore >= 60 ? 'excellent' : m.totalScore >= 45 ? 'good' : 'poor';

      let tipoPartita = '';
      if (m.totalScore >= 50) {
        tipoPartita = '<span style="color: #10b981; font-weight: bold;">🟢</span>';
      } else if (m.totalScore >= 45) {
        tipoPartita = '<span style="color: #f59e0b; font-weight: bold;">🟡</span>';
      } else {
        tipoPartita = '<span style="color: #ef4444; font-weight: bold;">🔴</span>';
      }

      html += '<tr>';
      html += '<td><strong>' + (index + 1) + '</strong></td>';
      html += '<td>' + tipoPartita + '</td>';
      html += '<td>' + (m.lega || m.Lega || '') + '</td>';
      html += '<td><strong>' + (m.partita || m.Partita || '') + '</strong></td>';
      html += '<td><strong>' + (m.tip || m.Tip || '') + '</strong></td>';
      html += '<td><strong>' + (m.quota || m.Quota || '') + '</strong></td>';
      html += '<td><strong>' + m.prob + '%</strong></td>';
      html += '<td><span class="badge ' + badgeClass + '">' + m.totalScore + '</span></td>';
      html += '</tr>';
    });

    html += '</tbody></table>';
    container.innerHTML = html;

    await loadAllPredictions();

  } catch (error) {
    container.innerHTML = '<div class="alert warning">❌ Errore: ' + error.message + '</div>';
    console.error('❌ Errore salvataggio:', error);
  }
}

async function viewFilteredPredictions() {
  const viewUser = document.getElementById('view-user').value;
  const dateFrom = document.getElementById('db-date-from').value;
  const dateTo = document.getElementById('db-date-to').value;
  const container = document.getElementById('pronostici-container');

  container.innerHTML = '<div class="loading"></div> 📂 Caricando...';

  await loadAllPredictions();

  let predictions = [...allPredictions];

  if (viewUser !== 'both') {
    predictions = predictions.filter(p => p.user === viewUser);
  }

  if (dateFrom || dateTo) {
    predictions = predictions.filter(p => {
      return (!dateFrom || p.date >= dateFrom) && (!dateTo || p.date <= dateTo);
    });
  }

  if (predictions.length === 0) {
    container.innerHTML = '<div class="alert warning">📭 Nessun pronostico trovato con i filtri selezionati.</div>';
    return;
  }

  predictions.sort((a, b) => new Date(b.date) - new Date(a.date));

  let html = '<h3>📊 Database Pronostici (' + predictions.length + ' totali)</h3>';

  const filtriAttivi = [];
  if (viewUser !== 'both') filtriAttivi.push('Utente: ' + viewUser);
  if (dateFrom || dateTo) filtriAttivi.push('Periodo: ' + (dateFrom || 'inizio') + ' - ' + (dateTo || 'fine'));

  if (filtriAttivi.length > 0) {
    html += '<p style="margin-bottom: 1rem; font-size: 0.9rem; color: #6b7280;"><strong>Filtri:</strong> ' + filtriAttivi.join(', ') + '</p>';
  }

  html += '<table><thead><tr><th>Data</th><th>Utente</th><th>Lega</th><th>Partita</th><th>Tip</th><th>Quota</th><th>Prob%</th><th>Status</th></tr></thead><tbody>';

  predictions.forEach(p => {
    const userBadge = p.user === 'moreno' ? 'moreno' : 'marco';
    const statusBadge = p.status === 'WIN' ? 'win' : p.status === 'LOSE' ? 'lose' : 'pending';

    html += '<tr>';
    html += '<td>' + p.date + '</td>';
    html += '<td><span class="user-badge ' + userBadge + '">' + (p.user === 'moreno' ? '🔵' : '🟢') + ' ' + p.user + '</span></td>';
    html += '<td>' + p.lega + '</td>';
    html += '<td><strong>' + p.partita + '</strong></td>';
    html += '<td><strong>' + p.tip + '</strong></td>';
    html += '<td><strong>' + p.quota + '</strong></td>';
    html += '<td><strong>' + p.probabilita + '%</strong></td>';
    html += '<td><span class="badge ' + statusBadge + '">' + p.status + '</span></td>';
    html += '</tr>';
  });

  html += '</tbody></table>';
  container.innerHTML = html;
}

async function deleteFilteredPredictions() {
  const viewUser = document.getElementById('view-user').value;
  const dateFrom = document.getElementById('db-date-from').value;
  const dateTo = document.getElementById('db-date-to').value;

  await loadAllPredictions();

  let toDelete = [...allPredictions];

  if (viewUser !== 'both') {
    toDelete = toDelete.filter(p => p.user === viewUser);
  }

  if (dateFrom || dateTo) {
    toDelete = toDelete.filter(p => {
      return (!dateFrom || p.date >= dateFrom) && (!dateTo || p.date <= dateTo);
    });
  }

  if (toDelete.length === 0) {
    alert('ℹ️ Nessuna partita da cancellare con i filtri selezionati.');
    return;
  }

  let confirmMsg = '🟠 Cancellare ' + toDelete.length + ' partite';
  if (dateFrom || dateTo) {
    confirmMsg += ' del periodo ' + (dateFrom || 'inizio') + ' - ' + (dateTo || 'fine');
  }
  if (viewUser !== 'both') {
    confirmMsg += ' di ' + viewUser;
  }
  confirmMsg += '?';

  if (confirm(confirmMsg)) {
    try {
      for (const pred of toDelete) {
        await deleteDoc(doc(db, 'aipredictions', pred.id));
      }

      alert('🗑️ Cancellate ' + toDelete.length + ' partite!');
      await loadAllPredictions();
      viewFilteredPredictions();
    } catch (error) {
      console.error('❌ Errore cancellazione:', error);
      alert('❌ Errore durante la cancellazione');
    }
  }
}

async function deleteAllUserPredictions() {
  const viewUser = document.getElementById('view-user').value;

  if (viewUser === 'both') {
    alert('⚠️ Seleziona un utente specifico per cancellare tutto!');
    return;
  }

  if (confirm('💀 ATTENZIONE! Cancellare TUTTI i pronostici di ' + viewUser + '?')) {
    if (confirm('🚨 Sei SICURO? Tutti i dati di ' + viewUser + ' verranno eliminati!')) {
      try {
        await loadAllPredictions();
        const userPredictions = allPredictions.filter(p => p.user === viewUser);

        for (const pred of userPredictions) {
          await deleteDoc(doc(db, 'aipredictions', pred.id));
        }

        alert('💀 Cancellati tutti i ' + userPredictions.length + ' pronostici di ' + viewUser + '!');
        await loadAllPredictions();
        viewFilteredPredictions();
      } catch (error) {
        console.error('❌ Errore cancellazione totale:', error);
        alert('❌ Errore durante la cancellazione totale');
      }
    }
  }
}

async function applicaFiltriEStats() {
  const dateFrom = document.getElementById('data-da').value;
  const dateTo = document.getElementById('data-a').value;
  const statsUser = document.getElementById('stats-user').value;

  const filterStatus = document.getElementById('filter-status').value;
  const filterTip = document.getElementById('filter-tip').value;
  const filterLega = document.getElementById('filter-lega').value;
  const filterProbMin = document.getElementById('filter-prob-min').value;
  const filterQuotaMin = document.getElementById('filter-quota-min').value;
  const filterROIMin = document.getElementById('filter-roi-min').value;
  const filterWinRateMin = document.getElementById('filter-winrate-min').value;

  const container = document.getElementById('statistiche-container');

  await loadAllPredictions();

  let predictions = [...allPredictions];

  if (statsUser !== 'both') {
    predictions = predictions.filter(p => p.user === statsUser);
  }

  if (dateFrom || dateTo) {
    predictions = predictions.filter(p => {
      return (!dateFrom || p.date >= dateFrom) && (!dateTo || p.date <= dateTo);
    });
  }

  if (filterStatus !== 'all') {
    predictions = predictions.filter(p => p.status === filterStatus);
  }

  if (filterTip !== 'all') {
    predictions = predictions.filter(p => p.tip === filterTip);
  }

  if (filterLega !== 'all') {
    predictions = predictions.filter(p => p.lega === filterLega);
  }

  if (filterProbMin) {
    predictions = predictions.filter(p => p.probabilita >= parseFloat(filterProbMin));
  }

  if (filterQuotaMin) {
    predictions = predictions.filter(p => p.quota >= parseFloat(filterQuotaMin));
  }

  // Nuovi filtri basati su performance storica
  if (filterROIMin || filterWinRateMin) {
    const historicalData = calculateHistoricalPerformance(predictions);
    
    if (filterROIMin) {
      predictions = predictions.filter(p => {
        const key = `${p.tip}_${p.lega}`;
        return historicalData[key] && historicalData[key].roi >= parseFloat(filterROIMin);
      });
    }
    
    if (filterWinRateMin) {
      predictions = predictions.filter(p => {
        const key = `${p.tip}_${p.lega}`;
        return historicalData[key] && historicalData[key].winRate >= parseFloat(filterWinRateMin);
      });
    }
  }

  if (predictions.length === 0) {
    container.innerHTML = '<div class="alert warning">📭 Nessun pronostico corrisponde ai filtri selezionati.</div>';

    document.getElementById('stat-total').textContent = '0';
    document.getElementById('stat-wins').textContent = '0';
    document.getElementById('stat-losses').textContent = '0';
    document.getElementById('stat-winrate').textContent = '0%';
    document.getElementById('stat-winrate').className = '';
    return;
  }

  const totalMatches = predictions.length;
  const wonMatches = predictions.filter(p => p.status === 'WIN').length;
  const lostMatches = predictions.filter(p => p.status === 'LOSE').length;
  const pendingMatches = predictions.filter(p => p.status === 'PENDING').length;

  const completedMatches = wonMatches + lostMatches;
  const winRate = completedMatches > 0 ? ((wonMatches / completedMatches) * 100).toFixed(1) : 0;

  document.getElementById('stat-total').textContent = totalMatches;
  document.getElementById('stat-wins').textContent = wonMatches;
  document.getElementById('stat-losses').textContent = lostMatches;
  document.getElementById('stat-winrate').textContent = winRate + '%';

  const winRateElement = document.getElementById('stat-winrate');
  if (parseFloat(winRate) >= 80) {
    winRateElement.className = 'good';
  } else {
    winRateElement.className = 'bad';
  }

  predictions.sort((a, b) => new Date(b.date) - new Date(a.date));

  let html = '<h3>📊 Elenco Partite Filtrate (' + predictions.length + ' totali)</h3>';

  let filtriAttivi = [];
  if (statsUser !== 'both') filtriAttivi.push('Utente: ' + statsUser);
  if (dateFrom || dateTo) filtriAttivi.push('Periodo: ' + (dateFrom || 'inizio') + ' - ' + (dateTo || 'fine'));
  if (filterStatus !== 'all') filtriAttivi.push('Status: ' + filterStatus);
  if (filterTip !== 'all') filtriAttivi.push('Tip: ' + filterTip);
  if (filterLega !== 'all') filtriAttivi.push('Lega: ' + filterLega);
  if (filterProbMin) filtriAttivi.push('Prob Min: ' + filterProbMin + '%');
  if (filterQuotaMin) filtriAttivi.push('Quota Min: ' + filterQuotaMin);
  if (filterROIMin) filtriAttivi.push('ROI Min: ' + filterROIMin + '%');
  if (filterWinRateMin) filtriAttivi.push('Win Rate Min: ' + filterWinRateMin + '%');

  if (filtriAttivi.length > 0) {
    html += '<p style="margin-bottom: 1rem; font-size: 0.9rem; color: #6b7280;"><strong>Filtri attivi:</strong> ' + filtriAttivi.join(', ') + '</p>';
  }

  html += '<table><thead><tr><th>Data</th><th>Utente</th><th>Lega</th><th>Partita</th><th>Tip</th><th>Quota</th><th>Prob%</th><th>Risultato</th><th>Status</th></tr></thead><tbody>';

  predictions.forEach(p => {
    const userBadge = p.user === 'moreno' ? 'moreno' : 'marco';
    const statusBadge = p.status === 'WIN' ? 'win' : p.status === 'LOSE' ? 'lose' : 'pending';

    html += '<tr>';
    html += '<td>' + p.date + '</td>';
    html += '<td><span class="user-badge ' + userBadge + '">' + (p.user === 'moreno' ? '🔵' : '🟢') + ' ' + p.user + '</span></td>';
    html += '<td>' + p.lega + '</td>';
    html += '<td><strong>' + p.partita + '</strong></td>';
    html += '<td><strong>' + p.tip + '</strong></td>';
    html += '<td><strong>' + p.quota + '</strong></td>';
    html += '<td><strong>' + p.probabilita + '%</strong></td>';
    html += '<td><strong>' + (p.risultato || 'N/A') + '</strong></td>';
    html += '<td><span class="badge ' + statusBadge + '">' + p.status + '</span></td>';
    html += '</tr>';
  });

  html += '</tbody></table>';
  container.innerHTML = html;
}

function calculateHistoricalPerformance(predictions) {
  const historicalData = {};
  
  predictions.forEach(p => {
    const key = `${p.tip}_${p.lega}`;
    
    if (!historicalData[key]) {
      historicalData[key] = {
        total: 0,
        wins: 0,
        losses: 0,
        totalOdds: 0,
        roi: 0,
        winRate: 0
      };
    }
    
    historicalData[key].total++;
    historicalData[key].totalOdds += parseFloat(p.quota);
    
    if (p.status === 'WIN') {
      historicalData[key].wins++;
    } else if (p.status === 'LOSE') {
      historicalData[key].losses++;
    }
  });
  
  // Calcola ROI e win rate per ogni combinazione
  Object.keys(historicalData).forEach(key => {
    const data = historicalData[key];
    const avgOdds = data.totalOdds / data.total;
    const wins = data.wins;
    const total = data.total;
    
    // ROI = (Vincite * Quota Media - Scommesse Totali) / Scommesse Totali * 100
    data.roi = ((wins * avgOdds) - total) / total * 100;
    data.winRate = (wins / total) * 100;
  });
  
  return historicalData;
}

async function aggiornaRisultati() {
  if (!fileRisultati) {
    alert('⚠️ Carica prima il file dei risultati!');
    return;
  }

  // Controlla che il container esista
  const container = document.getElementById('statistiche-container');
  if (!container) {
    console.error('❌ Errore: Container non trovato');
    return;
  }

  container.innerHTML = '<div class="loading"></div> 🔄 Aggiornamento risultati...';

  try {
    await loadAllPredictions();
    
    let updatedCount = 0;
    let notFoundCount = 0;
    
    // Funzione di normalizzazione per i nomi delle squadre
    function normalizeTeamName(str) {
        if (!str) return '';
        return str.toLowerCase()
                  .replace(/[àáâãäå]/g, 'a')
                  .replace(/[èéêë]/g, 'e')
                  .replace(/[ìíîï]/g, 'i')
                  .replace(/[òóôõö]/g, 'o')
                  .replace(/[ùúûü]/g, 'u')
                  .replace(/[ýÿ]/g, 'y')
                  .replace(/[ñ]/g, 'n')
                  .replace(/[ç]/g, 'c')
                  .replace(/[^a-z0-9\s]/g, '')
                  .replace(/\s+/g, ' ')
                  .trim();
    }
    
    // Funzione per estrarre i nomi delle squadre da una stringa di partita
    function extractTeams(matchString) {
        if (!matchString) return [];
        
        // Rimuovi eventuali risultati finali (es: "1-0", "2-1")
        const cleanMatch = matchString.replace(/\s+\d+-\d+\s*$/, '').trim();
        
        // Dividi per "-" o "vs" o "v"
        const parts = cleanMatch.split(/\s*[-–]\s*|\s+vs\s+|\s+v\s+/i);
        
        if (parts.length >= 2) {
            return [
                normalizeTeamName(parts[0].trim()),
                normalizeTeamName(parts[1].trim())
            ];
        }
        
        return [normalizeTeamName(cleanMatch)];
    }
    
    // Funzione per normalizzare e formattare la data
    function normalizeDate(dateStr) {
        if (!dateStr) return '';
        
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
            return dateStr;
        }
        
        const date = new Date(dateStr);
        if (!isNaN(date.getTime())) {
            return date.toISOString().split('T')[0];
        }
        
        return dateStr;
    }
    
    // Itera su tutte le partite PENDING nel database Firebase
    const pendingPredictions = allPredictions.filter(p => p.status === 'PENDING');
    
    // Itera su tutti i risultati nel file esterno
    for (const result of fileRisultati) {
        const resultDate = normalizeDate(result.data || '');
        const resultPartita = result.partita || '';
        const resultEsito = (result.esito || '').toLowerCase().trim();
        const resultRisultato = result.risultato || '';
        
        // Estrai le squadre dalla partita del risultato
        const resultTeams = extractTeams(resultPartita);
        
        // Cerca partite PENDING corrispondenti
        const matchingPredictions = pendingPredictions.filter(p => {
            const predDate = normalizeDate(p.date || '');
            const predPartita = p.partita || '';
            
            // Matching esatto per data
            if (predDate !== resultDate) return false;
            
            // Estrai le squadre dal pronostico
            const predTeams = extractTeams(predPartita);
            
            // Se non abbiamo squadre nel risultato, non possiamo fare il matching
            if (resultTeams.length === 0) return false;
            
            // Se non abbiamo squadre nel pronostico, non possiamo fare il matching
            if (predTeams.length === 0) return false;
            
            // Controlla se almeno una squadra del pronostico corrisponde a una del risultato
            const hasTeamMatch = predTeams.some(predTeam => 
                resultTeams.some(resultTeam => 
                    predTeam.includes(resultTeam) || resultTeam.includes(predTeam)
                )
            );
            
            return hasTeamMatch;
        });
        
        // Aggiorna lo stato per ogni pronostico corrispondente
        for (const pred of matchingPredictions) {
            let newStatus = 'PENDING';
            
            if (resultEsito === 'vinto') {
                newStatus = 'WIN';
            } else if (resultEsito === 'perso') {
                newStatus = 'LOSE';
            }
            
            if (pred.status !== newStatus) {
                await updateDoc(doc(db, 'aipredictions', pred.id), {
                    status: newStatus,
                    risultato: resultRisultato
                });
                updatedCount++;
                console.log(`✅ Aggiornato: ${pred.partita} - ${newStatus}`);
            }
        }
        
        if (matchingPredictions.length === 0) {
            notFoundCount++;
        }
    }
    
    // Dopo aver aggiornato i risultati, ricarica tutti i dati
    await loadAllPredictions();
    
    let html = '<div class="alert success">✅ <strong> Il problema è che il container non esiste nel DOM</strong></div>';
    html += '<p style="margin: 1rem 0;">Aggiornati ' + updatedCount + ' pronostici.</p>';
    
    if (notFoundCount > 0) {
        html += '<div class="alert warning">⚠️ <strong>Attenzione:</strong> ' + notFoundCount + ' risultati non hanno trovato corrispondenze nei pronostici.</div>';
    }
    
    // Usa setTimeout per assicurarsi che il container sia disponibile
    setTimeout(() => {
        container.innerHTML = html;
        // Aggiorna le statistiche
        applicaFiltriEStats();
    }, 100);
    
  } catch (error) {
    // Usa setTimeout per assicurarsi che il container sia disponibile
    setTimeout(() => {
        const container = document.getElementById('statistiche-container');
        if (container) {
            container.innerHTML = '<div class="alert danger">❌ Errore durante l\'aggiornamento: ' + error.message + '</div>';
        }
    }, 100);
    
    console.error('❌ Errore aggiornamento risultati:', error);
  }
}

// Funzioni per la sezione ROI
function loadROITipData() {
  const container = document.getElementById('roi-tip-table');
  container.innerHTML = '<div class="loading"></div> 🔄 Caricamento dati...';
  
  // Calcola ROI per tip
  const tipData = {};
  
  allPredictions.forEach(p => {
    const tip = p.tip || 'Sconosciuto';
    
    if (!tipData[tip]) {
      tipData[tip] = {
        total: 0,
        wins: 0,
        losses: 0,
        totalOdds: 0,
        roi: 0,
        winRate: 0
      };
    }
    
    tipData[tip].total++;
    tipData[tip].totalOdds += parseFloat(p.quota);
    
    if (p.status === 'WIN') {
      tipData[tip].wins++;
    } else if (p.status === 'LOSE') {
      tipData[tip].losses++;
    }
  });
  
  // Calcola ROI e win rate per ogni tip
  Object.keys(tipData).forEach(tip => {
    const data = tipData[tip];
    const avgOdds = data.totalOdds / data.total;
    const wins = data.wins;
    const total = data.total;
    
    // ROI = (Vincite * Quota Media - Scommesse Totali) / Scommesse Totali * 100
    data.roi = ((wins * avgOdds) - total) / total * 100;
    data.winRate = (wins / total) * 100;
  });
  
  // Ordina per ROI decrescente
  const sortedTips = Object.keys(tipData).sort((a, b) => tipData[b].roi - tipData[a].roi);
  
  // Crea tabella
  let html = '<table><thead><tr><th>Tip</th><th>Totale</th><th>Vinte</th><th>Perse</th><th>Win Rate</th><th>ROI</th></tr></thead><tbody>';
  
  sortedTips.forEach(tip => {
    const data = tipData[tip];
    const roiClass = data.roi >= 0 ? 'good' : 'bad';
    const winRateClass = data.winRate >= 70 ? 'good' : 'bad';
    
    html += '<tr>';
    html += '<td><strong>' + tip + '</strong></td>';
    html += '<td>' + data.total + '</td>';
    html += '<td>' + data.wins + '</td>';
    html += '<td>' + data.losses + '</td>';
    html += '<td class="' + winRateClass + '">' + data.winRate.toFixed(1) + '%</td>';
    html += '<td class="' + roiClass + '">' + data.roi.toFixed(1) + '%</td>';
    html += '</tr>';
  });
  
  html += '</tbody></table>';
  container.innerHTML = html;
  
  // Crea grafico
  createROITipChart(sortedTips, tipData);
}

function createROITipChart(tips, tipData) {
  const ctx = document.getElementById('roi-tip-chart').getContext('2d');
  
  // Distruggi grafico esistente se presente
  if (window.roiTipChart) {
    window.roiTipChart.destroy();
  }
  
  window.roiTipChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: tips.slice(0, 10), // Limita ai primi 10 per leggibilità
      datasets: [{
        label: 'ROI (%)',
        data: tips.slice(0, 10).map(tip => tipData[tip].roi),
        backgroundColor: tips.slice(0, 10).map(tip => 
          tipData[tip].roi >= 0 ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)'
        ),
        borderColor: tips.slice(0, 10).map(tip => 
          tipData[tip].roi >= 0 ? 'rgba(16, 185, 129, 1)' : 'rgba(239, 68, 68, 1)'
        ),
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'ROI (%)'
          }
        }
      },
      plugins: {
        legend: {
          display: false
        }
      }
    }
  });
}

function loadROILegaData() {
  const container = document.getElementById('roi-lega-table');
  container.innerHTML = '<div class="loading"></div> 🔄 Caricamento dati...';
  
  // Calcola ROI per lega
  const legaData = {};
  
  allPredictions.forEach(p => {
    const lega = p.lega || 'Sconosciuta';
    
    if (!legaData[lega]) {
      legaData[lega] = {
        total: 0,
        wins: 0,
        losses: 0,
        totalOdds: 0,
        roi: 0,
        winRate: 0
      };
    }
    
    legaData[lega].total++;
    legaData[lega].totalOdds += parseFloat(p.quota);
    
    if (p.status === 'WIN') {
      legaData[lega].wins++;
    } else if (p.status === 'LOSE') {
      legaData[lega].losses++;
    }
  });
  
  // Calcola ROI e win rate per ogni lega
  Object.keys(legaData).forEach(lega => {
    const data = legaData[lega];
    const avgOdds = data.totalOdds / data.total;
    const wins = data.wins;
    const total = data.total;
    
    // ROI = (Vincite * Quota Media - Scommesse Totali) / Scommesse Totali * 100
    data.roi = ((wins * avgOdds) - total) / total * 100;
    data.winRate = (wins / total) * 100;
  });
  
  // Ordina per ROI decrescente
  const sortedLeghe = Object.keys(legaData).sort((a, b) => legaData[b].roi - legaData[a].roi);
  
  // Crea tabella
  let html = '<table><thead><tr><th>Lega</th><th>Totale</th><th>Vinte</th><th>Perse</th><th>Win Rate</th><th>ROI</th></tr></thead><tbody>';
  
  sortedLeghe.forEach(lega => {
    const data = legaData[lega];
    const roiClass = data.roi >= 0 ? 'good' : 'bad';
    const winRateClass = data.winRate >= 70 ? 'good' : 'bad';
    
    html += '<tr>';
    html += '<td><strong>' + lega + '</strong></td>';
    html += '<td>' + data.total + '</td>';
    html += '<td>' + data.wins + '</td>';
    html += '<td>' + data.losses + '</td>';
    html += '<td class="' + winRateClass + '">' + data.winRate.toFixed(1) + '%</td>';
    html += '<td class="' + roiClass + '">' + data.roi.toFixed(1) + '%</td>';
    html += '</tr>';
  });
  
  html += '</tbody></table>';
  container.innerHTML = html;
  
  // Crea grafico
  createROILegaChart(sortedLeghe, legaData);
}

function createROILegaChart(leghe, legaData) {
  const ctx = document.getElementById('roi-lega-chart').getContext('2d');
  
  // Distruggi grafico esistente se presente
  if (window.roiLegaChart) {
    window.roiLegaChart.destroy();
  }
  
  window.roiLegaChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: leghe.slice(0, 10), // Limita alle prime 10 per leggibilità
      datasets: [{
        label: 'ROI (%)',
        data: leghe.slice(0, 10).map(lega => legaData[lega].roi),
        backgroundColor: leghe.slice(0, 10).map(lega => 
          legaData[lega].roi >= 0 ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)'
        ),
        borderColor: leghe.slice(0, 10).map(lega => 
          legaData[lega].roi >= 0 ? 'rgba(16, 185, 129, 1)' : 'rgba(239, 68, 68, 1)'
        ),
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'ROI (%)'
          }
        }
      },
      plugins: {
        legend: {
          display: false
        }
      }
    }
  });
}

function loadROIPeriodoData() {
  const container = document.getElementById('roi-periodo-table');
  container.innerHTML = '<div class="loading"></div> 🔄 Caricamento dati...';
  
  // Calcola ROI per periodo (mese)
  const periodoData = {};
  
  allPredictions.forEach(p => {
    const date = new Date(p.date);
    const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
    
    if (!periodoData[monthYear]) {
      periodoData[monthYear] = {
        total: 0,
        wins: 0,
        losses: 0,
        totalOdds: 0,
        roi: 0,
        winRate: 0
      };
    }
    
    periodoData[monthYear].total++;
    periodoData[monthYear].totalOdds += parseFloat(p.quota);
    
    if (p.status === 'WIN') {
      periodoData[monthYear].wins++;
    } else if (p.status === 'LOSE') {
      periodoData[monthYear].losses++;
    }
  });
  
  // Calcola ROI e win rate per ogni periodo
  Object.keys(periodoData).forEach(periodo => {
    const data = periodoData[periodo];
    const avgOdds = data.totalOdds / data.total;
    const wins = data.wins;
    const total = data.total;
    
    // ROI = (Vincite * Quota Media - Scommesse Totali) / Scommesse Totali * 100
    data.roi = ((wins * avgOdds) - total) / total * 100;
    data.winRate = (wins / total) * 100;
  });
  
  // Ordina per periodo
  const sortedPeriodi = Object.keys(periodoData).sort();
  
  // Crea tabella
  let html = '<table><thead><tr><th>Periodo</th><th>Totale</th><th>Vinte</th><th>Perse</th><th>Win Rate</th><th>ROI</th></tr></thead><tbody>';
  
  sortedPeriodi.forEach(periodo => {
    const data = periodoData[periodo];
    const roiClass = data.roi >= 0 ? 'good' : 'bad';
    const winRateClass = data.winRate >= 70 ? 'good' : 'bad';
    
    html += '<tr>';
    html += '<td><strong>' + periodo + '</strong></td>';
    html += '<td>' + data.total + '</td>';
    html += '<td>' + data.wins + '</td>';
    html += '<td>' + data.losses + '</td>';
    html += '<td class="' + winRateClass + '">' + data.winRate.toFixed(1) + '%</td>';
    html += '<td class="' + roiClass + '">' + data.roi.toFixed(1) + '%</td>';
    html += '</tr>';
  });
  
  html += '</tbody></table>';
  container.innerHTML = html;
  
  // Crea grafico
  createROIPeriodoChart(sortedPeriodi, periodoData);
}

function createROIPeriodoChart(periodi, periodoData) {
  const ctx = document.getElementById('roi-periodo-chart').getContext('2d');
  
  // Distruggi grafico esistente se presente
  if (window.roiPeriodoChart) {
    window.roiPeriodoChart.destroy();
  }
  
  window.roiPeriodoChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: periodi,
      datasets: [{
        label: 'ROI (%)',
        data: periodi.map(periodo => periodoData[periodo].roi),
        backgroundColor: 'rgba(102, 126, 234, 0.2)',
        borderColor: 'rgba(102, 126, 234, 1)',
        borderWidth: 2,
        fill: true,
        tension: 0.4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'ROI (%)'
          }
        }
      },
      plugins: {
        legend: {
          display: false
        }
      }
    }
  });
}

function loadROIUtenteData() {
  const container = document.getElementById('roi-utente-table');
  container.innerHTML = '<div class="loading"></div> 🔄 Caricamento dati...';
  
  // Calcola ROI per utente
  const utenteData = {};
  
  allPredictions.forEach(p => {
    const user = p.user || 'Sconosciuto';
    
    if (!utenteData[user]) {
      utenteData[user] = {
        total: 0,
        wins: 0,
        losses: 0,
        totalOdds: 0,
        roi: 0,
        winRate: 0
      };
    }
    
    utenteData[user].total++;
    utenteData[user].totalOdds += parseFloat(p.quota);
    
    if (p.status === 'WIN') {
      utenteData[user].wins++;
    } else if (p.status === 'LOSE') {
      utenteData[user].losses++;
    }
  });
  
  // Calcola ROI e win rate per ogni utente
  Object.keys(utenteData).forEach(user => {
    const data = utenteData[user];
    const avgOdds = data.totalOdds / data.total;
    const wins = data.wins;
    const total = data.total;
    
    // ROI = (Vincite * Quota Media - Scommesse Totali) / Scommesse Totali * 100
    data.roi = ((wins * avgOdds) - total) / total * 100;
    data.winRate = (wins / total) * 100;
  });
  
  // Ordina per ROI decrescente
  const sortedUtenti = Object.keys(utenteData).sort((a, b) => utenteData[b].roi - utenteData[a].roi);
  
  // Crea tabella
  let html = '<table><thead><tr><th>Utente</th><th>Totale</th><th>Vinte</th><th>Perse</th><th>Win Rate</th><th>ROI</th></tr></thead><tbody>';
  
  sortedUtenti.forEach(user => {
    const data = utenteData[user];
    const roiClass = data.roi >= 0 ? 'good' : 'bad';
    const winRateClass = data.winRate >= 70 ? 'good' : 'bad';
    
    html += '<tr>';
    html += '<td><strong>' + user + '</strong></td>';
    html += '<td>' + data.total + '</td>';
    html += '<td>' + data.wins + '</td>';
    html += '<td>' + data.losses + '</td>';
    html += '<td class="' + winRateClass + '">' + data.winRate.toFixed(1) + '%</td>';
    html += '<td class="' + roiClass + '">' + data.roi.toFixed(1) + '%</td>';
    html += '</tr>';
  });
  
  html += '</tbody></table>';
  container.innerHTML = html;
  
  // Crea grafico
  createROIUtenteChart(sortedUtenti, utenteData);
}

function createROIUtenteChart(utenti, utenteData) {
  const ctx = document.getElementById('roi-utente-chart').getContext('2d');
  
  // Distruggi grafico esistente se presente
  if (window.roiUtenteChart) {
    window.roiUtenteChart.destroy();
  }
  
  window.roiUtenteChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: utenti,
      datasets: [{
        label: 'ROI (%)',
        data: utenti.map(user => utenteData[user].roi),
        backgroundColor: utenti.map(user => 
          utenteData[user].roi >= 0 ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)'
        ),
        borderColor: utenti.map(user => 
          utenteData[user].roi >= 0 ? 'rgba(16, 185, 129, 1)' : 'rgba(239, 68, 68, 1)'
        ),
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'ROI (%)'
          }
        }
      },
      plugins: {
        legend: {
          display: false
        }
      }
    }
  });
}

// Funzioni per la sezione Multiple
function generateMultiple() {
  const multipleType = document.getElementById('multiple-type').value;
  const strategy = document.getElementById('multiple-strategy').value;
  const container = document.getElementById('multiple-container');
  
  container.innerHTML = '<div class="loading"></div> 🔄 Generazione multiple...';
  
  // Filtra solo pronostici con status PENDING
  const pendingPredictions = allPredictions.filter(p => p.status === 'PENDING');
  
  if (pendingPredictions.length < (multipleType === 'doppia' ? 2 : 3)) {
    container.innerHTML = '<div class="alert warning">⚠️ Non ci sono abbastanza pronostici pending per generare una ' + multipleType + '.</div>';
    return;
  }
  
  // Calcola performance storica per tip e leghe
  const historicalData = calculateHistoricalPerformance(allPredictions);
  
  // Assegna un punteggio a ogni pronostico basato su performance storica
  const scoredPredictions = pendingPredictions.map(p => {
    const key = `${p.tip}_${p.lega}`;
    const historical = historicalData[key] || { roi: 0, winRate: 0 };
    
    // Punteggio combinato basato su ROI e win rate storici
    let score = 0;
    
    if (strategy === 'sicurezza') {
      // Priorità a win rate alto
      score = historical.winRate * 0.7 + Math.max(0, historical.roi) * 0.3;
    } else if (strategy === 'valore') {
      // Bilanciato tra ROI e win rate
      score = historical.winRate * 0.5 + Math.max(0, historical.roi) * 0.5;
    } else if (strategy === 'rischio') {
      // Priorità a ROI alto
      score = Math.max(0, historical.roi) * 0.7 + historical.winRate * 0.3;
    }
    
    return {
      ...p,
      score: score || 0,
      historicalROI: historical.roi,
      historicalWinRate: historical.winRate
    };
  });
  
  // Ordina per punteggio decrescente
  scoredPredictions.sort((a, b) => b.score - a.score);
  
  // Genera multiple
  const numMultiples = Math.min(5, Math.floor(scoredPredictions.length / (multipleType === 'doppia' ? 2 : 3)));
  const multiples = [];
  
  for (let i = 0; i < numMultiples; i++) {
    const startIndex = i * (multipleType === 'doppia' ? 2 : 3);
    const endIndex = startIndex + (multipleType === 'doppia' ? 2 : 3);
    
    if (endIndex > scoredPredictions.length) break;
    
    const selectedMatches = scoredPredictions.slice(startIndex, endIndex);
    
    // Calcola quota totale
    let totalOdds = 1;
    selectedMatches.forEach(m => {
      totalOdds *= parseFloat(m.quota);
    });
    
    // Calcola ROI potenziale basato su performance storica
    let expectedWinRate = 1;
    selectedMatches.forEach(m => {
      expectedWinRate *= (m.historicalWinRate / 100);
    });
    
    const expectedROI = (expectedWinRate * totalOdds - 1) * 100;
    
    multiples.push({
      matches: selectedMatches,
      totalOdds: totalOdds.toFixed(2),
      expectedWinRate: (expectedWinRate * 100).toFixed(1),
      expectedROI: expectedROI.toFixed(1)
    });
  }
  
  // Visualizza le multiple
  let html = '<h3>🎲 Multiple ' + (multipleType === 'doppia' ? 'Doppie' : 'Triple') + ' - Strategia: ' + strategy + '</h3>';
  
  if (multiples.length === 0) {
    html += '<div class="alert warning">⚠️ Non è stato possibile generare multiple con i criteri selezionati.</div>';
    container.innerHTML = html;
    return;
  }
  
  multiples.forEach((multiple, index) => {
    const roiClass = parseFloat(multiple.expectedROI) >= 0 ? 'positive' : 'negative';
    
    html += '<div class="multiple-card">';
    html += '<div class="multiple-title">' + (multipleType === 'doppia' ? 'Doppia' : 'Tripla') + ' #' + (index + 1) + '</div>';
    html += '<div class="multiple-odds">Quota: ' + multiple.totalOdds + '</div>';
    html += '<div class="multiple-roi ' + roiClass + '">ROI Atteso: ' + multiple.expectedROI + '%</div>';
    html += '<div class="multiple-matches">Win Rate Atteso: ' + multiple.expectedWinRate + '%</div>';
    
    html += '<table style="margin-top: 1rem; font-size: 0.8rem;">';
    html += '<thead><tr><th>Partita</th><th>Tip</th><th>Quota</th><th>Win Rate Storico</th></tr></thead><tbody>';
    
    multiple.matches.forEach(match => {
      html += '<tr>';
      html += '<td>' + match.partita + '</td>';
      html += '<td>' + match.tip + '</td>';
      html += '<td>' + match.quota + '</td>';
      html += '<td>' + match.historicalWinRate.toFixed(1) + '%</td>';
      html += '</tr>';
    });
    
    html += '</tbody></table>';
    html += '</div>';
  });
  
  container.innerHTML = html;
}

// Funzioni per la sezione Alert
function generateAlerts() {
  const threshold = parseInt(document.getElementById('alert-threshold').value) || 20;
  const period = parseInt(document.getElementById('alert-period').value) || 7;
  const container = document.getElementById('alerts-container');
  
  container.innerHTML = '<div class="loading"></div> 🔄 Generazione alert...';
  
  // Calcola data di inizio periodo
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - period);
  const startDateStr = startDate.toISOString().split('T')[0];
  
  // Filtra pronostici nel periodo
  const periodPredictions = allPredictions.filter(p => p.date >= startDateStr);
  
  if (periodPredictions.length === 0) {
    container.innerHTML = '<div class="alert warning">⚠️ Nessun pronostico trovato nel periodo selezionato.</div>';
    return;
  }
  
  // Calcola performance storica complessiva
  const historicalData = calculateHistoricalPerformance(allPredictions);
  
  // Calcola performance nel periodo
  const periodData = calculateHistoricalPerformance(periodPredictions);
  
  // Genera alert per anomalie
  const alerts = [];
  
  // Alert per leghe con performance anomala
  Object.keys(periodData).forEach(key => {
    const [tip, lega] = key.split('_');
    const periodPerf = periodData[key];
    const historicalPerf = historicalData[key] || { roi: 0, winRate: 0 };
    
    // Calcola differenza di ROI
    const roiDiff = periodPerf.roi - historicalPerf.roi;
    
    if (Math.abs(roiDiff) >= threshold) {
      alerts.push({
        type: roiDiff > 0 ? 'success' : 'danger',
        title: lega + ' - ' + tip,
        description: 'ROI nel periodo: ' + periodPerf.roi.toFixed(1) + '% (Media storica: ' + historicalPerf.roi.toFixed(1) + '%)',
        value: roiDiff.toFixed(1) + '%'
      });
    }
    
    // Calcola differenza di win rate
    const winRateDiff = periodPerf.winRate - historicalPerf.winRate;
    
    if (Math.abs(winRateDiff) >= threshold) {
      alerts.push({
        type: winRateDiff > 0 ? 'success' : 'warning',
        title: lega + ' - ' + tip,
        description: 'Win rate nel periodo: ' + periodPerf.winRate.toFixed(1) + '% (Media storica: ' + historicalPerf.winRate.toFixed(1) + '%)',
        value: winRateDiff.toFixed(1) + '%'
      });
    }
  });
  
  // Alert per sequenze di risultati anomale
  const userSequences = {};
  
  // Raggruppa per utente e data
  periodPredictions.forEach(p => {
    if (!userSequences[p.user]) {
      userSequences[p.user] = {};
    }
    
    if (!userSequences[p.user][p.date]) {
      userSequences[p.user][p.date] = {
        total: 0,
        wins: 0,
        losses: 0
      };
    }
    
    userSequences[p.user][p.date].total++;
    
    if (p.status === 'WIN') {
      userSequences[p.user][p.date].wins++;
    } else if (p.status === 'LOSE') {
      userSequences[p.user][p.date].losses++;
    }
  });
  
  // Controlla sequenze di vittorie/sconfitte
  Object.keys(userSequences).forEach(user => {
    const dates = Object.keys(userSequences[user]).sort();
    
    let winStreak = 0;
    let loseStreak = 0;
    let maxWinStreak = 0;
    let maxLoseStreak = 0;
    
    dates.forEach(date => {
      const dayData = userSequences[user][date];
      const winRate = dayData.wins / dayData.total;
      
      if (winRate >= 0.7) {
        winStreak++;
        loseStreak = 0;
        maxWinStreak = Math.max(maxWinStreak, winStreak);
      } else if (winRate <= 0.3) {
        loseStreak++;
        winStreak = 0;
        maxLoseStreak = Math.max(maxLoseStreak, loseStreak);
      } else {
        winStreak = 0;
        loseStreak = 0;
      }
    });
    
    if (maxWinStreak >= 3) {
      alerts.push({
        type: 'success',
        title: user + ' - Sequenza Positiva',
        description: 'Sequenza di ' + maxWinStreak + ' giorni con win rate ≥ 70%',
        value: maxWinStreak + ' giorni'
      });
    }
    
    if (maxLoseStreak >= 3) {
      alerts.push({
        type: 'danger',
        title: user + ' - Sequenza Negativa',
        description: 'Sequenza di ' + maxLoseStreak + ' giorni con win rate ≤ 30%',
        value: maxLoseStreak + ' giorni'
      });
    }
  });
  
  // Visualizza gli alert con spiegazioni dettagliate
  let html = '<h3>⚠️ Alert Pattern Anomali (Ultimi ' + period + ' giorni)</h3>';
  
  // Aggiungi spiegazione del funzionamento degli alert
  html += '<div class="alert info">';
  html += '<h4>📖 Come Funzionano gli Alert</h4>';
  html += '<p>Gli alert identificano pattern anomali confrontando la performance recente con quella storica:</p>';
  html += '<ul>';
  html += '<li><strong>ROI Anomalo:</strong> Quando il ROI nel periodo selezionato differisce significativamente dalla media storica</li>';
  html += '<li><strong>Win Rate Anomalo:</strong> Quando la percentuale di vittorie nel periodo differisce dalla media storica</li>';
  html += '<li><strong>Sequenze Positive/Negative:</strong> Quando si verificano 3+ giorni consecutivi con performance eccezionalmente positive o negative</li>';
  html += '</ul>';
  html += '<p>La soglia di ' + threshold + '% indica il minimo scostamento dalla media per generare un alert.</p>';
  html += '</div>';
  
  if (alerts.length === 0) {
    html += '<div class="alert info">ℹ️ Nessun pattern anomalo rilevato nel periodo selezionato.</div>';
    container.innerHTML = html;
    return;
  }
  
  // Ordina gli alert per gravità
  alerts.sort((a, b) => {
    const severityOrder = { danger: 0, warning: 1, info: 2, success: 3 };
    return severityOrder[a.type] - severityOrder[b.type];
  });
  
  alerts.forEach(alert => {
    html += '<div class="alert-item ' + alert.type + '">';
    html += '<div class="alert-title">' + alert.title + ' <span style="float: right; font-weight: bold;">' + alert.value + '</span></div>';
    html += '<div class="alert-description">' + alert.description + '</div>';
    html += '</div>';
  });
  
  container.innerHTML = html;
}

// Event listeners
document.getElementById('btn-preview').addEventListener('click', previewScoring);
document.getElementById('btn-estrai').addEventListener('click', estraiESalvaPronostici);
document.getElementById('btn-view-filtered').addEventListener('click', viewFilteredPredictions);
document.getElementById('btn-delete-filtered').addEventListener('click', deleteFilteredPredictions);
document.getElementById('btn-delete-user-all').addEventListener('click', deleteAllUserPredictions);
document.getElementById('btn-applica-filtri').addEventListener('click', applicaFiltriEStats);
document.getElementById('btn-reset-user').addEventListener('click', () => {
  document.getElementById('stats-user').value = 'both';
  applicaFiltriEStats();
});
document.getElementById('btn-reset-date').addEventListener('click', () => {
  document.getElementById('data-da').value = '';
  document.getElementById('data-a').value = '';
  applicaFiltriEStats();
});
document.getElementById('btn-clear-filters').addEventListener('click', () => {
  document.getElementById('filter-status').value = 'all';
  document.getElementById('filter-tip').value = 'all';
  document.getElementById('filter-lega').value = 'all';
  document.getElementById('filter-prob-min').value = '';
  document.getElementById('filter-quota-min').value = '';
  document.getElementById('filter-roi-min').value = '';
  document.getElementById('filter-winrate-min').value = '';
  applicaFiltriEStats();
});
document.getElementById('btn-aggiorna-risultati').addEventListener('click', aggiornaRisultati);
document.getElementById('btn-generate-multiple').addEventListener('click', generateMultiple);
document.getElementById('btn-generate-alerts').addEventListener('click', generateAlerts);

// Inizializzazione
initFirebase();
</script>
</body>
</html>