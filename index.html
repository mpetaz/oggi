<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ğŸ¯ AI Betting - Moreno & Marco</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #2d3748; line-height: 1.6; min-height: 100vh;
}

.container { max-width: 1400px; margin: 0 auto; padding: 2rem; }

.app-header { text-align: center; margin-bottom: 2rem; color: white; }
.app-header h1 { font-size: 2.5rem; font-weight: 800; margin-bottom: 0.5rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
.app-header p { font-size: 1.1rem; opacity: 0.9; }

nav.menu {
    background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); padding: 1.5rem;
    border-radius: 20px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1); margin-bottom: 2rem;
}

nav.menu ul { list-style: none; display: flex; gap: 1.5rem; justify-content: center; flex-wrap: wrap; }

nav.menu ul li button {
    background: linear-gradient(135deg, #667eea, #764ba2); border: none; color: white;
    padding: 1rem 2rem; cursor: pointer; border-radius: 25px; font-weight: 600; font-size: 1rem;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
}

nav.menu ul li button:hover, nav.menu ul li button.active {
    transform: translateY(-3px); box-shadow: 0 12px 30px rgba(102, 126, 234, 0.4);
}

.section {
    background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); padding: 2.5rem;
    border-radius: 25px; box-shadow: 0 15px 50px rgba(0, 0, 0, 0.1); margin-bottom: 2rem;
}

.section h2 { color: #4a5568; margin-bottom: 2rem; font-size: 1.8rem; font-weight: 700; text-align: center; position: relative; }

.section h2::after {
    content: ''; position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%);
    width: 60px; height: 3px; background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 2px;
}

.user-selection { background: rgba(102, 126, 234, 0.1); padding: 1.5rem; border-radius: 15px; margin-bottom: 2rem; }
.user-selection label { display: block; font-weight: 600; margin-bottom: 0.5rem; color: #4a5568; }

.scoring-controls {
    background: rgba(16, 185, 129, 0.1); padding: 1.5rem; border-radius: 15px; margin-bottom: 2rem;
    border: 2px solid rgba(16, 185, 129, 0.2);
}

.scoring-grid {
    display: grid; grid-template-columns: 1fr 1fr auto; gap: 1rem; align-items: end;
}

.database-controls {
    background: rgba(59, 130, 246, 0.1); padding: 1.5rem; border-radius: 15px; margin-bottom: 2rem;
    border: 2px solid rgba(59, 130, 246, 0.2);
}

.database-grid {
    display: grid; grid-template-columns: 1fr 1fr auto auto auto; gap: 1rem; align-items: end;
}

.filters-advanced {
    background: rgba(102, 126, 234, 0.05); padding: 1.5rem; border-radius: 15px; margin-bottom: 2rem;
    border: 2px solid rgba(102, 126, 234, 0.1);
}

.filters-grid {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; align-items: end;
}

.filter-group {
    display: flex; flex-direction: column;
}

.filter-group label {
    font-size: 0.9rem; margin-bottom: 0.5rem; color: #4a5568; font-weight: 600;
}

.filter-group select, .filter-group input {
    padding: 0.7rem; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 0.9rem;
}

.date-filters {
    display: grid; grid-template-columns: 1fr 1fr auto auto; gap: 1rem; align-items: end;
}

.user-filters {
    display: grid; grid-template-columns: 1fr auto; gap: 1rem; align-items: end; margin-bottom: 1rem;
}

.stats-simple { 
    display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-top: 2rem; 
}

.stat-box { 
    background: white; padding: 2rem; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); text-align: center; 
}

.stat-box h3 { 
    font-size: 3rem; margin-bottom: 0.5rem; font-weight: 800; 
}

.stat-box p { 
    color: #6b7280; font-weight: 600; font-size: 1rem; 
}

.stat-box.total h3 { color: #3b82f6; }
.stat-box.win h3 { color: #10b981; }
.stat-box.lose h3 { color: #ef4444; }
.stat-box.winrate h3.good { color: #10b981; }
.stat-box.winrate h3.bad { color: #ef4444; }

.helper-note {
    font-size: 0.85rem; color: #6b7280; font-style: italic; margin-top: 0.5rem;
}

input[type="number"] { width: 120px; padding: 0.8rem; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 1rem; background: white; }
input[type="number"]:focus { border-color: #667eea; outline: none; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }

select { width: 200px; padding: 0.8rem; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 1rem; background: white; cursor: pointer; }
select:focus { border-color: #667eea; outline: none; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }

form { display: grid; gap: 1.5rem; }
label { font-weight: 600; color: #4a5568; margin-bottom: 0.5rem; display: block; }

input[type="date"], input[type="file"] {
    width: 100%; padding: 1rem 1.2rem; border: 2px solid #e2e8f0; border-radius: 12px;
    font-size: 1rem; transition: all 0.3s ease; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

input[type="date"]:focus, input[type="file"]:focus {
    border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); outline: none; transform: translateY(-1px);
}

button.control-btn {
    padding: 1.2rem 2.5rem; font-weight: 600; border: none; border-radius: 15px; cursor: pointer;
    font-size: 1.1rem; margin-top: 1rem; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    text-transform: uppercase; letter-spacing: 0.5px;
}

button.control-btn.compact {
    padding: 0.8rem 1.5rem; font-size: 0.9rem; margin-top: 0;
}

button.control-btn.green { background: linear-gradient(135deg, #10b981, #059669); color: white; box-shadow: 0 6px 20px rgba(16, 185, 129, 0.3); }
button.control-btn.orange { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; box-shadow: 0 6px 20px rgba(245, 158, 11, 0.3); }
button.control-btn.red { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; box-shadow: 0 6px 20px rgba(239, 68, 68, 0.3); }
button.control-btn.blue { background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3); }
button.control-btn:hover { transform: translateY(-3px); }

#estratti-container, #pronostici-container, #statistiche-container {
    background: rgba(248, 250, 252, 0.8); border-radius: 15px; padding: 1.5rem; margin-top: 2rem;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05); max-height: 70vh; overflow-y: auto;
}

table { 
    width: 100%; border-collapse: separate; border-spacing: 0; margin-top: 1rem; 
    border-radius: 12px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-size: 0.7rem;
}

th { 
    background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 0.5rem 0.3rem; 
    text-align: left; font-weight: 600; text-transform: uppercase; letter-spacing: 0.2px; 
    font-size: 0.6rem;
}

td { 
    background: white; padding: 0.5rem 0.3rem; border-bottom: 1px solid #e2e8f0; 
    transition: background-color 0.2s ease; font-size: 0.65rem;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}

td:nth-child(1) { width: 60px; }
td:nth-child(2) { width: 70px; }
td:nth-child(3) { width: 90px; }
td:nth-child(4) { width: 150px; }
td:nth-child(5) { width: 50px; text-align: center; }
td:nth-child(6) { width: 50px; text-align: center; }
td:nth-child(7) { width: 50px; text-align: center; }
td:nth-child(8) { width: 70px; text-align: center; }
td:nth-child(9) { width: 60px; text-align: center; }

tr:hover td { background-color: #f8fafc; }
tr:last-child td { border-bottom: none; }

.user-badge { 
    padding: 0.3rem 0.6rem; border-radius: 8px; color: white; font-weight: 700; 
    font-size: 0.65rem; display: inline-block; min-width: 60px; text-align: center;
}
.user-badge.moreno { background: linear-gradient(135deg, #3b82f6, #1d4ed8); }
.user-badge.marco { background: linear-gradient(135deg, #10b981, #059669); }

.badge { 
    padding: 0.25rem 0.5rem; border-radius: 10px; color: white; font-weight: 600; 
    font-size: 0.6rem; text-align: center; display: inline-block; min-width: 45px;
}
.badge.excellent { background: linear-gradient(135deg, #10b981, #059669); }
.badge.good { background: linear-gradient(135deg, #f59e0b, #d97706); }
.badge.poor { background: linear-gradient(135deg, #ef4444, #dc2626); }
.badge.win { background: linear-gradient(135deg, #10b981, #059669); }
.badge.lose { background: linear-gradient(135deg, #ef4444, #dc2626); }
.badge.pending { background: linear-gradient(135deg, #f59e0b, #d97706); }

.loading { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(102, 126, 234, 0.3); border-radius: 50%; border-top-color: #667eea; animation: spin 1s ease-in-out infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

.alert { padding: 1rem; border-radius: 8px; margin: 1rem 0; border-left: 4px solid; }
.alert.success { background: rgba(16, 185, 129, 0.1); border-color: #10b981; color: #065f46; }
.alert.warning { background: rgba(245, 158, 11, 0.1); border-color: #f59e0b; color: #92400e; }
.alert.info { background: rgba(59, 130, 246, 0.1); border-color: #3b82f6; color: #1e3a8a; }

@media (max-width: 768px) {
    .container { padding: 1rem; }
    nav.menu ul { flex-direction: column; }
    .section { padding: 1.5rem; }
    nav.menu ul li button { width: 100%; }
    .app-header h1 { font-size: 2rem; }
    .scoring-grid { grid-template-columns: 1fr; }
    .database-grid { grid-template-columns: 1fr; }
    .date-filters { grid-template-columns: 1fr; }
    .user-filters { grid-template-columns: 1fr; }
    .filters-grid { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="container">

<div class="app-header">
<h1>ğŸ¯ AI Betting</h1>
<p>ğŸ‘¨â€ğŸ‘¦ Sistema Pronostici - Moreno & Marco</p>
</div>

<nav class="menu">
<ul>
<li><button id="btn-pronostici">ğŸ“Š Database Pronostici</button></li>
<li><button id="btn-inserisci" class="active">ğŸ¯ Inserisci & Salva</button></li>
<li><button id="btn-statistiche">ğŸ“Š Filtri e Statistiche</button></li>
</ul>
</nav>

<!-- SEZIONE PRONOSTICI -->
<div id="section-pronostici" class="section" style="display:none;">
<h2>ğŸ“Š Database Pronostici</h2>

<div class="user-selection">
<label for="view-user">ğŸ‘¥ Visualizza pronostici di:</label>
<select id="view-user">
<option value="both">ğŸ”µğŸŸ¢ Entrambi</option>
<option value="moreno">ğŸ”µ Solo Moreno</option>
<option value="marco">ğŸŸ¢ Solo Marco</option>
</select>
</div>

<div class="database-controls">
<h4 style="margin-bottom: 1rem; color: #3b82f6;">ğŸ—‚ï¸ Controlli Database</h4>
<div class="database-grid">
<div>
<label for="db-date-from">ğŸ“… Da:</label>
<input type="date" id="db-date-from"/>
<div class="helper-note">(lasciare vuote per tutto il database)</div>
</div>
<div>
<label for="db-date-to">ğŸ“… A:</label>
<input type="date" id="db-date-to"/>
</div>
<button type="button" id="btn-view-filtered" class="control-btn blue compact">ğŸ”µ Vedi Pronostici</button>
<button type="button" id="btn-delete-filtered" class="control-btn orange compact">ğŸŸ  Cancella Filtrati</button>
<button type="button" id="btn-delete-user-all" class="control-btn red compact">ğŸ’€ Cancella Tutto Utente</button>
</div>
</div>

<div id="pronostici-container">
<div style="text-align: center; padding: 3rem; color: #6b7280;">
<h3>ğŸ“Š Database Pronostici</h3>
<p>Usa i controlli sopra per vedere o gestire i pronostici</p>
</div>
</div>
</div>

<!-- SEZIONE INSERISCI -->
<div id="section-inserisci" class="section">
<h2>ğŸ¯ Inserisci e Salva Pronostici</h2>

<div class="user-selection">
<label for="current-user">ğŸ‘¤ Utente:</label>
<select id="current-user">
<option value="moreno">ğŸ”µ Moreno</option>
<option value="marco">ğŸŸ¢ Marco</option>
</select>
</div>

<div class="scoring-controls">
<h4 style="margin-bottom: 1rem; color: #10b981;">âš™ï¸ Controlli Scoring Avanzato</h4>
<div class="scoring-grid">
<div>
<label for="score-threshold">ğŸ¯ Soglia Punteggio Minimo:</label>
<input type="number" id="score-threshold" value="45" min="20" max="100"/>
<small style="color: #6b7280;">Salva tutte le partite con punteggio â‰¥ soglia</small>
</div>
<div>
<label for="max-selections">ğŸ”¢ Massimo Partite:</label>
<input type="number" id="max-selections" value="10" min="5" max="50"/>
<small style="color: #6b7280;">Limite massimo partite totali. PrioritÃ  a quelle VERDI (â‰¥50)</small>
</div>
<button type="button" id="btn-preview" class="control-btn orange compact">ğŸ‘ï¸ Anteprima</button>
</div>
</div>

<form id="form-inserisci">
<div>
<label for="input-data">ğŸ“… Data partite:</label>
<input type="date" id="input-data" required/>
</div>
<div>
<label for="file-giorno">ğŸ“„ File partite del giorno:</label>
<input type="file" id="file-giorno" accept=".csv" required/>
</div>
<div>
<label for="file-storico">ğŸ“Š File storico (per calcoli):</label>
<input type="file" id="file-storico" accept=".csv" required/>
</div>
<button type="button" id="btn-estrai" class="control-btn green">ğŸš€ Calcola e Salva Intelligente</button>
</form>
<div id="estratti-container"></div>
</div>

<!-- SEZIONE STATISTICHE -->
<div id="section-statistiche" class="section" style="display:none;">
<h2>ğŸ“Š Filtri e Statistiche</h2>

<div class="user-selection">
<h4 style="margin-bottom: 1rem;">ğŸ‘¥ Selezione Utente</h4>
<div class="user-filters">
<div>
<label for="stats-user">Visualizza partite di:</label>
<select id="stats-user">
<option value="both">ğŸ”µğŸŸ¢ Entrambi</option>
<option value="moreno">ğŸ”µ Solo Moreno</option>
<option value="marco">ğŸŸ¢ Solo Marco</option>
</select>
</div>
<button type="button" id="btn-reset-user" class="control-btn green compact">ğŸ”„ Reset</button>
</div>
</div>

<div class="user-selection">
<h4 style="margin-bottom: 1rem;">ğŸ“… Filtro Periodo</h4>
<div class="date-filters">
<div>
<label for="data-da">Da:</label>
<input type="date" id="data-da"/>
<div class="helper-note">(lasciare vuote per tutto il database)</div>
</div>
<div>
<label for="data-a">A:</label>
<input type="date" id="data-a"/>
</div>
<button type="button" id="btn-applica-filtri" class="control-btn green compact">ğŸ” Applica Filtri</button>
<button type="button" id="btn-reset-date" class="control-btn green compact">ğŸ”„ Reset Date</button>
</div>
</div>

<div class="filters-advanced">
<h4 style="margin-bottom: 1rem;">ğŸ” Filtri Avanzati (tipo Excel)</h4>
<div class="filters-grid">
<div class="filter-group">
<label for="filter-status">Status:</label>
<select id="filter-status">
<option value="all">ğŸ”„ Tutti</option>
<option value="WIN">âœ… Solo Vinte</option>
<option value="LOSE">âŒ Solo Perse</option>
<option value="PENDING">â³ Solo Pending</option>
</select>
</div>
<div class="filter-group">
<label for="filter-tip">Tip:</label>
<select id="filter-tip">
<option value="all">ğŸ¯ Tutti i Tip</option>
</select>
</div>
<div class="filter-group">
<label for="filter-lega">Lega:</label>
<select id="filter-lega">
<option value="all">ğŸ† Tutte le Leghe</option>
</select>
</div>
<div class="filter-group">
<label for="filter-prob-min">Prob Min %:</label>
<input type="number" id="filter-prob-min" placeholder="es: 80" min="0" max="100"/>
</div>
<div class="filter-group">
<label for="filter-quota-min">Quota Min:</label>
<input type="number" id="filter-quota-min" placeholder="es: 1.5" step="0.1" min="1"/>
</div>
<div class="filter-group" style="align-self: end;">
<button type="button" id="btn-clear-filters" class="control-btn orange compact">ğŸ§¹ Pulisci Filtri</button>
</div>
</div>
</div>

<div class="user-selection">
<h4 style="margin-bottom: 1rem;">ğŸ“„ Aggiorna Risultati</h4>
<div style="display: grid; grid-template-columns: 1fr auto; gap: 1rem; align-items: end;">
<div>
<label for="file-risultati">File TOTALI risultati:</label>
<input type="file" id="file-risultati" accept=".csv"/>
</div>
<button type="button" id="btn-aggiorna-risultati" class="control-btn orange compact">âœ… Aggiorna Status</button>
</div>
<div id="matching-info" style="margin-top: 1rem; font-size: 0.9rem; color: #6b7280;"></div>
</div>

<div class="stats-simple">
<div class="stat-box total">
<h3 id="stat-total">0</h3>
<p>Partite Totali</p>
</div>
<div class="stat-box win">
<h3 id="stat-wins">0</h3>
<p>Vinte</p>
</div>
<div class="stat-box lose">
<h3 id="stat-losses">0</h3>
<p>Perse</p>
</div>
<div class="stat-box winrate">
<h3 id="stat-winrate">0%</h3>
<p>Win-Rate</p>
</div>
</div>

<div id="statistiche-container">
<div style="text-align: center; padding: 2rem; color: #6b7280;">
<h3>ğŸ“Š Elenco Partite</h3>
<p>Applica filtri per vedere le partite del periodo/utente selezionato</p>
</div>
</div>

</div>

</div>

<script type="module">
let firebaseReady = false;
let db = null, currentUser = null;
let collection, addDoc, getDocs, doc, updateDoc, deleteDoc, where, query;
let allPredictions = [];
let fileRisultati = null;

async function initFirebase() {
    try {
        const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.1.0/firebase-app.js');
        const firestoreModule = await import('https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js');
        const authModule = await import('https://www.gstatic.com/firebasejs/10.1.0/firebase-auth.js');

        collection = firestoreModule.collection;
        addDoc = firestoreModule.addDoc;
        getDocs = firestoreModule.getDocs;
        doc = firestoreModule.doc;
        updateDoc = firestoreModule.updateDoc;
        deleteDoc = firestoreModule.deleteDoc;
        where = firestoreModule.where;
        query = firestoreModule.query;

        const { getFirestore, enableNetwork } = firestoreModule;
        const { getAuth, signInAnonymously, onAuthStateChanged } = authModule;

        const firebaseConfig = {
            apiKey: "AIzaSyDohOjXix2tRoEhm8vv1gCYrqXlNeXjbGM",
            authDomain: "oggi-17f48.firebaseapp.com",
            projectId: "oggi-17f48",
            storageBucket: "oggi-17f48.firebasestorage.app",
            messagingSenderId: "961828441770",
            appId: "1:961828441770:web:270382ebd68fb953ff8ad3"
        };

        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        const auth = getAuth(app);

        await enableNetwork(db);

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                firebaseReady = true;
                console.log('ğŸ”¥ Firebase connesso:', user.uid);
                loadAllPredictions();
            } else {
                signInAnonymously(auth);
            }
        });

    } catch (error) {
        console.error('âŒ Errore Firebase:', error);
    }
}

async function loadAllPredictions() {
    if (!firebaseReady) return;

    try {
        const snapshot = await getDocs(collection(db, 'aipredictions'));
        allPredictions = snapshot.docs.map(docSnap => ({
            id: docSnap.id,
            ...docSnap.data()
        }));

        console.log('ğŸ“Š Caricati', allPredictions.length, 'pronostici da Firebase');
        populateFilters();

    } catch (error) {
        console.error('âŒ Errore caricamento:', error);
    }
}

function populateFilters() {
    if (allPredictions.length === 0) return;

    const uniqueTips = [...new Set(allPredictions.map(p => p.tip))].sort();
    const filterTip = document.getElementById('filter-tip');
    filterTip.innerHTML = '<option value="all">ğŸ¯ Tutti i Tip</option>';
    uniqueTips.forEach(tip => {
        filterTip.innerHTML += '<option value="' + tip + '">' + tip + '</option>';
    });

    const uniqueLeagues = [...new Set(allPredictions.map(p => p.lega))].sort();
    const filterLega = document.getElementById('filter-lega');
    filterLega.innerHTML = '<option value="all">ğŸ† Tutte le Leghe</option>';
    uniqueLeagues.forEach(lega => {
        filterLega.innerHTML += '<option value="' + lega + '">' + lega + '</option>';
    });
}

const sections = {
  pronostici: document.getElementById('section-pronostici'),
  inserisci: document.getElementById('section-inserisci'),
  statistiche: document.getElementById('section-statistiche')
};

const buttons = {
  pronostici: document.getElementById('btn-pronostici'),
  inserisci: document.getElementById('btn-inserisci'),
  statistiche: document.getElementById('btn-statistiche')
};

function showSection(section) {
  Object.keys(sections).forEach(key => {
    if (key === section) {
      sections[key].style.display = 'block';
      buttons[key].classList.add('active');
    } else {
      sections[key].style.display = 'none';
      buttons[key].classList.remove('active');
    }
  });
}

showSection('inserisci');
buttons.pronostici.addEventListener('click', () => showSection('pronostici'));
buttons.inserisci.addEventListener('click', () => showSection('inserisci'));
buttons.statistiche.addEventListener('click', () => showSection('statistiche'));

let fileStorico = null;
let fileGiorno = null;

function parseCSV(text) {
  const lines = text.trim().split('\n').filter(line => line.trim());
  if (lines.length < 2) return [];

  const headerLine = lines[0];
  const headers = [];
  let inQuotes = false;
  let currentHeader = '';

  for (let i = 0; i < headerLine.length; i++) {
    const char = headerLine[i];
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      headers.push(currentHeader.trim().toLowerCase().replace(/['"]/g, ''));
      currentHeader = '';
    } else {
      currentHeader += char;
    }
  }
  if (currentHeader) {
    headers.push(currentHeader.trim().toLowerCase().replace(/['"]/g, ''));
  }

  const data = [];
  for (let lineIndex = 1; lineIndex < lines.length; lineIndex++) {
    const line = lines[lineIndex];
    const values = [];
    let inQuotes = false;
    let currentValue = '';

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        values.push(currentValue.trim().replace(/['"]/g, ''));
        currentValue = '';
      } else {
        currentValue += char;
      }
    }
    if (currentValue) {
      values.push(currentValue.trim().replace(/['"]/g, ''));
    }

    const row = {};
    headers.forEach((h, i) => { 
      row[h] = values[i] || ''; 
    });
    data.push(row);
  }

  return data;
}

function calculateScore(partita, legheSet, tipsSet) {
  let legaScore = 0, tipScore = 0, probScore = 0, quotaValid = true;

  const lega = (partita.lega || partita.Lega || '').toLowerCase().trim();
  if (legheSet.has(lega)) legaScore = 20;
  else if (lega.startsWith('eu-')) legaScore = 5;

  let tipNorm = (partita.tip || partita.Tip || '').trim();
  if (tipNorm) {
    tipNorm = tipNorm.replace(',', '.').toUpperCase();
    const val = parseFloat(tipNorm);
    if (!isNaN(val)) tipNorm = (val >= 0 ? '+' : '-') + Math.abs(val);
  }

  if (tipsSet.has(tipNorm)) tipScore = 20;
  else if (lega.startsWith('eu-')) tipScore = 5;

  const quota = parseFloat(String(partita.quota || partita.Quota || '').replace(',', '.')) || 0;
  if (quota < 1.20) quotaValid = false;

  const prob = parseFloat((partita.probabilitÃ  || partita.probabilita || partita['ProbabilitÃ '] || '').toString().replace('%', '')) || 0;

  if (prob <= 65) {
    probScore = 0;
  } else if (prob <= 77) {
    probScore = 5;
  } else {
    probScore = 20 + (prob - 78);
  }

  return { 
    legaScore, 
    tipScore, 
    probScore: Math.round(probScore), 
    totalScore: legaScore + tipScore + Math.round(probScore), 
    quotaValid, 
    quota, 
    prob 
  };
}

document.getElementById('file-storico').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(event) { 
      fileStorico = parseCSV(event.target.result); 
    };
    reader.readAsText(file);
  }
});

document.getElementById('file-giorno').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(event) { 
      fileGiorno = parseCSV(event.target.result); 
    };
    reader.readAsText(file);
  }
});

document.getElementById('file-risultati').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(event) { 
      fileRisultati = parseCSV(event.target.result);
      console.log('âœ… File risultati caricato:', fileRisultati.length, 'righe');
      document.getElementById('matching-info').innerHTML = 'ğŸ“Š <strong>File caricato:</strong> ' + fileRisultati.length + ' risultati';
    };
    reader.readAsText(file);
  }
});

function previewScoring() {
  if (!fileStorico || !fileGiorno) {
    alert('âš ï¸ Carica prima i file per vedere l anteprima!');
    return;
  }

  const scoreThreshold = parseInt(document.getElementById('score-threshold').value) || 45;
  const maxPartite = parseInt(document.getElementById('max-selections').value) || 10;
  const container = document.getElementById('estratti-container');
  container.innerHTML = '<div class="loading"></div> ğŸ”„ Anteprima intelligente...';

  try {
    const legheSet = new Set();
    const tipsSet = new Set();

    fileStorico.forEach(row => {
      const lega = (row.lega || row.Lega || '').toLowerCase().trim();
      const tip = (row.tip || row.Tip || '').trim();
      if (lega) legheSet.add(lega);
      if (tip) {
        let normalizedTip = tip.replace(',', '.').toUpperCase();
        const val = parseFloat(normalizedTip);
        if (!isNaN(val)) normalizedTip = (val >= 0 ? '+' : '-') + Math.abs(val);
        tipsSet.add(normalizedTip);
      }
    });

    let selections = fileGiorno.filter(row => {
      const lega = (row.lega || row.Lega || '').toLowerCase().trim();
      const tip = (row.tip || row.Tip || '').trim();

      let normalizedTip = tip.replace(',', '.').toUpperCase();
      const val = parseFloat(normalizedTip);
      if (!isNaN(val)) normalizedTip = (val >= 0 ? '+' : '-') + Math.abs(val);

      return legheSet.has(lega) && tipsSet.has(normalizedTip);
    });

    if (selections.length === 0) {
      container.innerHTML = '<div class="alert warning">âŒ Nessuna partita con leghe E tip storici trovata.</div>';
      return;
    }

    selections.forEach(s => Object.assign(s, calculateScore(s, legheSet, tipsSet)));

    const validMatches = selections.filter(m => m.quotaValid && m.totalScore >= scoreThreshold);
    validMatches.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const partiteVerdi = validMatches.filter(m => m.totalScore >= 50);
    const partiteGialle = validMatches.filter(m => m.totalScore >= 45 && m.totalScore < 50);
    const partiteRosse = validMatches.filter(m => m.totalScore < 45);

    // Simula selezione con limite
    let simulatedSelection = [];
    let spazio = maxPartite;

    const verdiOrdered = [...partiteVerdi].sort((a, b) => b.totalScore - a.totalScore);
    const gialleOrdered = [...partiteGialle].sort((a, b) => b.totalScore - a.totalScore);
    const rosseOrdered = [...partiteRosse].sort((a, b) => b.totalScore - a.totalScore);

    const verdiSel = verdiOrdered.slice(0, Math.min(spazio, verdiOrdered.length));
    simulatedSelection.push(...verdiSel);
    spazio -= verdiSel.length;

    if (spazio > 0) {
      const gialleSel = gialleOrdered.slice(0, Math.min(spazio, gialleOrdered.length));
      simulatedSelection.push(...gialleSel);
      spazio -= gialleSel.length;
    }

    if (spazio > 0) {
      const rosseSel = rosseOrdered.slice(0, Math.min(spazio, rosseOrdered.length));
      simulatedSelection.push(...rosseSel);
    }

    const finalVerdi = simulatedSelection.filter(m => m.totalScore >= 50).length;
    const finalGialle = simulatedSelection.filter(m => m.totalScore >= 45 && m.totalScore < 50).length;
    const finalRosse = simulatedSelection.filter(m => m.totalScore < 45).length;

    let html = '<div class="alert info">ğŸ‘ï¸ <strong>ANTEPRIMA INTELLIGENTE</strong> - Soglia: ' + scoreThreshold + ' | Limite: ' + maxPartite + ' partite</div>';
    html += '<h3>ğŸ” Simulazione Selezione</h3>';
    html += '<p style="margin: 1rem 0; font-size: 0.9rem;"><strong>Disponibili:</strong> ';
    html += '<span style="color: #10b981;">ğŸŸ¢ ' + partiteVerdi.length + ' VERDI (â‰¥50)</span> | ';
    html += '<span style="color: #f59e0b;">ğŸŸ¡ ' + partiteGialle.length + ' GIALLE (45-49)</span> | ';
    html += '<span style="color: #ef4444;">ğŸ”´ ' + partiteRosse.length + ' ROSSE (<45)</span></p>';

    html += '<p style="margin: 1rem 0; font-size: 0.9rem;"><strong>Verranno selezionate:</strong> ';
    html += '<span style="color: #10b981;">ğŸŸ¢ ' + finalVerdi + ' VERDI</span> | ';
    html += '<span style="color: #f59e0b;">ğŸŸ¡ ' + finalGialle + ' GIALLE</span> | ';
    html += '<span style="color: #ef4444;">ğŸ”´ ' + finalRosse + ' ROSSE</span>';
    html += ' = <strong>' + simulatedSelection.length + ' partite totali</strong></p>';

    if (partiteVerdi.length > finalVerdi) {
      html += '<div class="alert warning">âš ï¸ <strong>ATTENZIONE:</strong> ' + (partiteVerdi.length - finalVerdi) + ' partite VERDI verranno escluse per rispettare il limite di ' + maxPartite + ' partite.</div>';
    }

    container.innerHTML = html;

  } catch (error) {
    container.innerHTML = '<div class="alert warning">âŒ Errore: ' + error.message + '</div>';
  }
}

async function estraiESalvaPronostici() {
  const selectedDate = document.getElementById('input-data').value;
  const currentUserName = document.getElementById('current-user').value;
  const scoreThreshold = parseInt(document.getElementById('score-threshold').value) || 45;
  const maxPartite = parseInt(document.getElementById('max-selections').value) || 10;

  if (!selectedDate || !fileStorico || !fileGiorno) {
    alert('âš ï¸ Inserisci data e carica entrambi i file!');
    return;
  }

  if (!firebaseReady) {
    alert('âš ï¸ Firebase non ancora pronto!');
    return;
  }

  await loadAllPredictions();
  const esistenti = allPredictions.filter(p => 
    p.user === currentUserName && 
    p.date === selectedDate
  );

  if (esistenti.length > 0) {
    const conferma = confirm(
      'âš ï¸ ATTENZIONE! Trovate ' + esistenti.length + ' partite giÃ  inserite per ' + 
      selectedDate + ' di ' + currentUserName + '.\n\n' +
      'Continuando verranno AGGIUNTE alle esistenti (possibili duplicati).\n\n' +
      'Vuoi CANCELLARE prima le partite esistenti? (CONSIGLIATO)'
    );

    if (conferma) {
      const container = document.getElementById('estratti-container');
      container.innerHTML = '<div class="loading"></div> ğŸ—‘ï¸ Pulizia database...';

      for (const pred of esistenti) {
        await deleteDoc(doc(db, 'aipredictions', pred.id));
      }

      alert('ğŸ—‘ï¸ Cancellate ' + esistenti.length + ' partite esistenti! Ora inserisco le nuove.');
      await loadAllPredictions();
    } else {
      if (!confirm('âš ï¸ ATTENZIONE: Le nuove partite verranno AGGIUNTE a quelle esistenti!\nSicuro di continuare?')) {
        return;
      }
    }
  }

  const container = document.getElementById('estratti-container');
  container.innerHTML = '<div class="loading"></div> ğŸ”„ Selezione intelligente...';

  try {
    const legheSet = new Set();
    const tipsSet = new Set();

    fileStorico.forEach(row => {
      const lega = (row.lega || row.Lega || '').toLowerCase().trim();
      const tip = (row.tip || row.Tip || '').trim();
      if (lega) legheSet.add(lega);
      if (tip) {
        let normalizedTip = tip.replace(',', '.').toUpperCase();
        const val = parseFloat(normalizedTip);
        if (!isNaN(val)) normalizedTip = (val >= 0 ? '+' : '-') + Math.abs(val);
        tipsSet.add(normalizedTip);
      }
    });

    let selections = fileGiorno.filter(row => {
      const lega = (row.lega || row.Lega || '').toLowerCase().trim();
      const tip = (row.tip || row.Tip || '').trim();

      let normalizedTip = tip.replace(',', '.').toUpperCase();
      const val = parseFloat(normalizedTip);
      if (!isNaN(val)) normalizedTip = (val >= 0 ? '+' : '-') + Math.abs(val);

      return legheSet.has(lega) && tipsSet.has(normalizedTip);
    });

    if (selections.length === 0) {
      container.innerHTML = '<div class="alert warning">âŒ Nessuna partita con leghe E tip storici trovata.</div>';
      return;
    }

    selections.forEach(s => Object.assign(s, calculateScore(s, legheSet, tipsSet)));

    const validMatches = selections.filter(m => m.quotaValid && m.totalScore >= scoreThreshold);
    validMatches.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    if (validMatches.length === 0) {
      container.innerHTML = '<div class="alert warning">âŒ Nessuna partita raggiunge la soglia impostata.</div>';
      return;
    }

    const partiteVerdi = validMatches.filter(m => m.totalScore >= 50);
    const partiteGialle = validMatches.filter(m => m.totalScore >= 45 && m.totalScore < 50);
    const partiteRosse = validMatches.filter(m => m.totalScore < 45);

    console.log('ğŸŸ¢ Partite VERDI (â‰¥50):', partiteVerdi.length);
    console.log('ğŸŸ¡ Partite GIALLE (45-49):', partiteGialle.length);
    console.log('ğŸ”´ Partite ROSSE (<45):', partiteRosse.length);

    // SELEZIONE CON LIMITE
    let finalSelections = [];
    let spazio = maxPartite;

    const verdiOrdered = partiteVerdi.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const gialleOrdered = partiteGialle.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const rosseOrdered = partiteRosse.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const verdiSelezionate = verdiOrdered.slice(0, Math.min(spazio, verdiOrdered.length));
    finalSelections.push(...verdiSelezionate);
    spazio -= verdiSelezionate.length;

    if (spazio > 0) {
      const gialleSelezionate = gialleOrdered.slice(0, Math.min(spazio, gialleOrdered.length));
      finalSelections.push(...gialleSelezionate);
      spazio -= gialleSelezionate.length;
    }

    if (spazio > 0) {
      const rosseSelezionate = rosseOrdered.slice(0, Math.min(spazio, rosseOrdered.length));
      finalSelections.push(...rosseSelezionate);
    }

    finalSelections.sort((a, b) => {
      if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
      if (b.prob !== a.prob) return b.prob - a.prob;
      return b.quota - a.quota;
    });

    const verdiTagliate = partiteVerdi.length - verdiSelezionate.length;

    for (const match of finalSelections) {
      await addDoc(collection(db, 'aipredictions'), {
        date: selectedDate,
        user: currentUserName,
        lega: match.lega || match.Lega || '',
        partita: match.partita || match.Partita || '',
        tip: match.tip || match.Tip || '',
        quota: parseFloat(String(match.quota || match.Quota || '').replace(',', '.')) || 0,
        probabilita: match.prob,
        score: match.totalScore,
        status: 'PENDING',
        risultato: '',
        userid: currentUser.uid,
        createdat: new Date().toISOString()
      });
    }

    const userBadge = currentUserName === 'moreno' ? 
      '<span class="user-badge moreno">ğŸ”µ Moreno</span>' : 
      '<span class="user-badge marco">ğŸŸ¢ Marco</span>';

    let html = '<h3>ğŸ¯ SELEZIONE INTELLIGENTE - ' + finalSelections.length + ' PARTITE - ' + userBadge + ' - ' + selectedDate + '</h3>';

    html += '<div class="alert success">âœ… <strong>Salvate ' + finalSelections.length + ' partite!</strong> (Limite: ' + maxPartite + ') Soglia: ' + scoreThreshold + ' punti</div>';

    if (verdiTagliate > 0) {
      html += '<div class="alert info">âš ï¸ <strong>LIMITE RAGGIUNTO:</strong> Tagliate ' + verdiTagliate + ' partite VERDI per rispettare il limite di ' + maxPartite + ' partite.</div>';
    }

    const verdiFinali = finalSelections.filter(m => m.totalScore >= 50).length;
    const gialleFinali = finalSelections.filter(m => m.totalScore >= 45 && m.totalScore < 50).length;
    const rosseFinali = finalSelections.filter(m => m.totalScore < 45).length;

    html += '<p style="margin: 1rem 0; font-size: 0.9rem;"><strong>Selezione:</strong> ';
    html += '<span style="color: #10b981;">ğŸŸ¢ ' + verdiFinali + ' VERDI (â‰¥50)</span> | ';
    html += '<span style="color: #f59e0b;">ğŸŸ¡ ' + gialleFinali + ' GIALLE (45-49)</span> | ';
    html += '<span style="color: #ef4444;">ğŸ”´ ' + rosseFinali + ' ROSSE (<45)</span></p>';

    html += '<table><thead><tr><th>Pos</th><th>Tipo</th><th>Lega</th><th>Partita</th><th>Tip</th><th>Quota</th><th>Prob%</th><th>Score</th></tr></thead><tbody>';

    finalSelections.forEach((m, index) => {
      const badgeClass = m.totalScore >= 60 ? 'excellent' : m.totalScore >= 45 ? 'good' : 'poor';

      let tipoPartita = '';
      if (m.totalScore >= 50) {
        tipoPartita = '<span style="color: #10b981; font-weight: bold;">ğŸŸ¢</span>';
      } else if (m.totalScore >= 45) {
        tipoPartita = '<span style="color: #f59e0b; font-weight: bold;">ğŸŸ¡</span>';
      } else {
        tipoPartita = '<span style="color: #ef4444; font-weight: bold;">ğŸ”´</span>';
      }

      html += '<tr>';
      html += '<td><strong>' + (index + 1) + '</strong></td>';
      html += '<td>' + tipoPartita + '</td>';
      html += '<td>' + (m.lega || m.Lega || '') + '</td>';
      html += '<td><strong>' + (m.partita || m.Partita || '') + '</strong></td>';
      html += '<td><strong>' + (m.tip || m.Tip || '') + '</strong></td>';
      html += '<td><strong>' + (m.quota || m.Quota || '') + '</strong></td>';
      html += '<td><strong>' + m.prob + '%</strong></td>';
      html += '<td><span class="badge ' + badgeClass + '">' + m.totalScore + '</span></td>';
      html += '</tr>';
    });

    html += '</tbody></table>';
    container.innerHTML = html;

    await loadAllPredictions();

  } catch (error) {
    container.innerHTML = '<div class="alert warning">âŒ Errore: ' + error.message + '</div>';
    console.error('âŒ Errore salvataggio:', error);
  }
}

async function viewFilteredPredictions() {
  const viewUser = document.getElementById('view-user').value;
  const dateFrom = document.getElementById('db-date-from').value;
  const dateTo = document.getElementById('db-date-to').value;
  const container = document.getElementById('pronostici-container');

  container.innerHTML = '<div class="loading"></div> ğŸ“‚ Caricando...';

  await loadAllPredictions();

  let predictions = [...allPredictions];

  if (viewUser !== 'both') {
    predictions = predictions.filter(p => p.user === viewUser);
  }

  if (dateFrom || dateTo) {
    predictions = predictions.filter(p => {
      return (!dateFrom || p.date >= dateFrom) && (!dateTo || p.date <= dateTo);
    });
  }

  if (predictions.length === 0) {
    container.innerHTML = '<div class="alert warning">ğŸ“­ Nessun pronostico trovato con i filtri selezionati.</div>';
    return;
  }

  predictions.sort((a, b) => new Date(b.date) - new Date(a.date));

  let html = '<h3>ğŸ“Š Database Pronostici (' + predictions.length + ' totali)</h3>';

  const filtriAttivi = [];
  if (viewUser !== 'both') filtriAttivi.push('Utente: ' + viewUser);
  if (dateFrom || dateTo) filtriAttivi.push('Periodo: ' + (dateFrom || 'inizio') + ' - ' + (dateTo || 'fine'));

  if (filtriAttivi.length > 0) {
    html += '<p style="margin-bottom: 1rem; font-size: 0.9rem; color: #6b7280;"><strong>Filtri:</strong> ' + filtriAttivi.join(', ') + '</p>';
  }

  html += '<table><thead><tr><th>Data</th><th>Utente</th><th>Lega</th><th>Partita</th><th>Tip</th><th>Quota</th><th>Prob%</th><th>Status</th></tr></thead><tbody>';

  predictions.forEach(p => {
    const userBadge = p.user === 'moreno' ? 'moreno' : 'marco';
    const statusBadge = p.status === 'WIN' ? 'win' : p.status === 'LOSE' ? 'lose' : 'pending';

    html += '<tr>';
    html += '<td>' + p.date + '</td>';
    html += '<td><span class="user-badge ' + userBadge + '">' + (p.user === 'moreno' ? 'ğŸ”µ' : 'ğŸŸ¢') + ' ' + p.user + '</span></td>';
    html += '<td>' + p.lega + '</td>';
    html += '<td><strong>' + p.partita + '</strong></td>';
    html += '<td><strong>' + p.tip + '</strong></td>';
    html += '<td><strong>' + p.quota + '</strong></td>';
    html += '<td><strong>' + p.probabilita + '%</strong></td>';
    html += '<td><span class="badge ' + statusBadge + '">' + p.status + '</span></td>';
    html += '</tr>';
  });

  html += '</tbody></table>';
  container.innerHTML = html;
}

async function deleteFilteredPredictions() {
  const viewUser = document.getElementById('view-user').value;
  const dateFrom = document.getElementById('db-date-from').value;
  const dateTo = document.getElementById('db-date-to').value;

  await loadAllPredictions();

  let toDelete = [...allPredictions];

  if (viewUser !== 'both') {
    toDelete = toDelete.filter(p => p.user === viewUser);
  }

  if (dateFrom || dateTo) {
    toDelete = toDelete.filter(p => {
      return (!dateFrom || p.date >= dateFrom) && (!dateTo || p.date <= dateTo);
    });
  }

  if (toDelete.length === 0) {
    alert('â„¹ï¸ Nessuna partita da cancellare con i filtri selezionati.');
    return;
  }

  let confirmMsg = 'ğŸŸ  Cancellare ' + toDelete.length + ' partite';
  if (dateFrom || dateTo) {
    confirmMsg += ' del periodo ' + (dateFrom || 'inizio') + ' - ' + (dateTo || 'fine');
  }
  if (viewUser !== 'both') {
    confirmMsg += ' di ' + viewUser;
  }
  confirmMsg += '?';

  if (confirm(confirmMsg)) {
    try {
      for (const pred of toDelete) {
        await deleteDoc(doc(db, 'aipredictions', pred.id));
      }

      alert('ğŸ—‘ï¸ Cancellate ' + toDelete.length + ' partite!');
      await loadAllPredictions();
      viewFilteredPredictions();
    } catch (error) {
      console.error('âŒ Errore cancellazione:', error);
      alert('âŒ Errore durante la cancellazione');
    }
  }
}

async function deleteAllUserPredictions() {
  const viewUser = document.getElementById('view-user').value;

  if (viewUser === 'both') {
    alert('âš ï¸ Seleziona un utente specifico per cancellare tutto!');
    return;
  }

  if (confirm('ğŸ’€ ATTENZIONE! Cancellare TUTTI i pronostici di ' + viewUser + '?')) {
    if (confirm('ğŸš¨ Sei SICURO? Tutti i dati di ' + viewUser + ' verranno eliminati!')) {
      try {
        await loadAllPredictions();
        const userPredictions = allPredictions.filter(p => p.user === viewUser);

        for (const pred of userPredictions) {
          await deleteDoc(doc(db, 'aipredictions', pred.id));
        }

        alert('ğŸ’€ Cancellati tutti i ' + userPredictions.length + ' pronostici di ' + viewUser + '!');
        await loadAllPredictions();
        viewFilteredPredictions();
      } catch (error) {
        console.error('âŒ Errore cancellazione totale:', error);
        alert('âŒ Errore durante la cancellazione totale');
      }
    }
  }
}

async function applicaFiltriEStats() {
  const dateFrom = document.getElementById('data-da').value;
  const dateTo = document.getElementById('data-a').value;
  const statsUser = document.getElementById('stats-user').value;

  const filterStatus = document.getElementById('filter-status').value;
  const filterTip = document.getElementById('filter-tip').value;
  const filterLega = document.getElementById('filter-lega').value;
  const filterProbMin = document.getElementById('filter-prob-min').value;
  const filterQuotaMin = document.getElementById('filter-quota-min').value;

  const container = document.getElementById('statistiche-container');

  await loadAllPredictions();

  let predictions = [...allPredictions];

  if (statsUser !== 'both') {
    predictions = predictions.filter(p => p.user === statsUser);
  }

  if (dateFrom || dateTo) {
    predictions = predictions.filter(p => {
      return (!dateFrom || p.date >= dateFrom) && (!dateTo || p.date <= dateTo);
    });
  }

  if (filterStatus !== 'all') {
    predictions = predictions.filter(p => p.status === filterStatus);
  }

  if (filterTip !== 'all') {
    predictions = predictions.filter(p => p.tip === filterTip);
  }

  if (filterLega !== 'all') {
    predictions = predictions.filter(p => p.lega === filterLega);
  }

  if (filterProbMin) {
    predictions = predictions.filter(p => p.probabilita >= parseFloat(filterProbMin));
  }

  if (filterQuotaMin) {
    predictions = predictions.filter(p => p.quota >= parseFloat(filterQuotaMin));
  }

  if (predictions.length === 0) {
    container.innerHTML = '<div class="alert warning">ğŸ“­ Nessun pronostico corrisponde ai filtri selezionati.</div>';

    document.getElementById('stat-total').textContent = '0';
    document.getElementById('stat-wins').textContent = '0';
    document.getElementById('stat-losses').textContent = '0';
    document.getElementById('stat-winrate').textContent = '0%';
    document.getElementById('stat-winrate').className = '';
    return;
  }

  const totalMatches = predictions.length;
  const wonMatches = predictions.filter(p => p.status === 'WIN').length;
  const lostMatches = predictions.filter(p => p.status === 'LOSE').length;
  const pendingMatches = predictions.filter(p => p.status === 'PENDING').length;

  const completedMatches = wonMatches + lostMatches;
  const winRate = completedMatches > 0 ? ((wonMatches / completedMatches) * 100).toFixed(1) : 0;

  document.getElementById('stat-total').textContent = totalMatches;
  document.getElementById('stat-wins').textContent = wonMatches;
  document.getElementById('stat-losses').textContent = lostMatches;
  document.getElementById('stat-winrate').textContent = winRate + '%';

  const winRateElement = document.getElementById('stat-winrate');
  if (parseFloat(winRate) >= 80) {
    winRateElement.className = 'good';
  } else {
    winRateElement.className = 'bad';
  }

  predictions.sort((a, b) => new Date(b.date) - new Date(a.date));

  let html = '<h3>ğŸ“Š Elenco Partite Filtrate (' + predictions.length + ' totali)</h3>';

  let filtriAttivi = [];
  if (statsUser !== 'both') filtriAttivi.push('Utente: ' + statsUser);
  if (dateFrom || dateTo) filtriAttivi.push('Periodo: ' + (dateFrom || 'inizio') + ' - ' + (dateTo || 'fine'));
  if (filterStatus !== 'all') filtriAttivi.push('Status: ' + filterStatus);
  if (filterTip !== 'all') filtriAttivi.push('Tip: ' + filterTip);
  if (filterLega !== 'all') filtriAttivi.push('Lega: ' + filterLega);
  if (filterProbMin) filtriAttivi.push('Prob Min: ' + filterProbMin + '%');
  if (filterQuotaMin) filtriAttivi.push('Quota Min: ' + filterQuotaMin);

  if (filtriAttivi.length > 0) {
    html += '<p style="margin-bottom: 1rem; font-size: 0.9rem; color: #6b7280;"><strong>Filtri attivi:</strong> ' + filtriAttivi.join(', ') + '</p>';
  }

  html += '<table><thead><tr><th>Data</th><th>Utente</th><th>Lega</th><th>Partita</th><th>Tip</th><th>Quota</th><th>Prob%</th><th>Risultato</th><th>Status</th></tr></thead><tbody>';

  predictions.forEach(p => {
    const userBadge = p.user === 'moreno' ? 'moreno' : 'marco';
    const statusBadge = p.status === 'WIN' ? 'win' : p.status === 'LOSE' ? 'lose' : 'pending';

    html += '<tr>';
    html += '<td>' + p.date + '</td>';
    html += '<td><span class="user-badge ' + userBadge + '">' + (p.user === 'moreno' ? 'ğŸ”µ' : 'ğŸŸ¢') + ' ' + p.user + '</span></td>';
    html += '<td>' + p.lega + '</td>';
    html += '<td><strong>' + p.partita + '</strong></td>';
    html += '<td><strong>' + p.tip + '</strong></td>';
    html += '<td><strong>' + p.quota + '</strong></td>';
    html += '<td><strong>' + p.probabilita + '%</strong></td>';
    html += '<td><strong>' + (p.risultato || 'N/A') + '</strong></td>';
    html += '<td><span class="badge ' + statusBadge + '">' + p.status + '</span></td>';
    html += '</tr>';
  });

  html += '</tbody></table>';
  container.innerHTML = html;
}

async function aggiornaRisultati() {
  if (!fileRisultati) {
    alert('âš ï¸ Carica prima il file risultati!');
    return;
  }

  if (!firebaseReady) {
    alert('âš ï¸ Firebase non pronto!');
    return;
  }

  document.getElementById('matching-info').innerHTML = 'ğŸ”„ Elaborando...';

  await loadAllPredictions();
  const pending = allPredictions.filter(p => p.status === 'PENDING');

  if (pending.length === 0) {
    document.getElementById('matching-info').innerHTML = 'âœ… <strong>Tutti i pronostici sono giÃ  aggiornati!</strong>';
    return;
  }

  console.log('ğŸ¯ Aggiorno ' + pending.length + ' pronostici PENDING');

  let aggiornati = 0;
  let dettagli = [];
  let notFound = [];

  for (const pronostico of pending) {
    console.log('ğŸ” ' + pronostico.date + ' | ' + pronostico.lega + ' | ' + pronostico.partita + ' | ' + pronostico.tip);

    const risultatiGiorno = fileRisultati.filter(r => r.data === pronostico.date);

    if (risultatiGiorno.length === 0) {
      notFound.push(pronostico.date + ' - Nessun risultato per questa data');
      continue;
    }

    const risultatiLega = risultatiGiorno.filter(r => {
      const legaRisultato = r.lega.toLowerCase().trim();
      const legaPronostico = pronostico.lega.toLowerCase().trim();

      if (legaRisultato === legaPronostico) return true;
      if (legaRisultato.includes(legaPronostico) || legaPronostico.includes(legaRisultato)) return true;

      const paeseRisultato = legaRisultato.split('-')[1] || '';
      const paesePronostico = legaPronostico.split('-')[1] || '';
      if (paeseRisultato && paesePronostico && paeseRisultato === paesePronostico) {
        console.log('âœ¨ Match per paese: ' + paeseRisultato);
        return true;
      }

      return false;
    });

    if (risultatiLega.length === 0) {
      notFound.push(pronostico.date + ' - ' + pronostico.lega + ' - Lega non trovata');
      continue;
    }

    let matched = false;

    for (const risultato of risultatiLega) {
      function normalizeTip(tip) {
        return tip.toString().replace(',', '.').replace(/\s+/g, '').toUpperCase();
      }

      const tipRisNorm = normalizeTip(risultato.tip || '');
      const tipProNorm = normalizeTip(pronostico.tip || '');

      if (tipRisNorm !== tipProNorm) continue;

      const squadreRisultato = risultato.partita.toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 2);

      const squadrePronostico = pronostico.partita.toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 2);

      const squadreComuni = squadrePronostico.filter(s => 
        squadreRisultato.some(r => {
          if (r === s) return true;
          if (r.length >= 4 && s.length >= 4) {
            return r.includes(s) || s.includes(r);
          }
          return false;
        })
      );

      const matchPercentage = squadreComuni.length / Math.max(squadrePronostico.length, 1);
      const strongMatch = matchPercentage >= 0.5;
      const weakMatch = squadreComuni.length >= 1;

      console.log('ğŸ” Match squadre: ' + squadreComuni.length + '/' + squadrePronostico.length + ' (' + (matchPercentage * 100).toFixed(1) + '%)');

      if (strongMatch || (weakMatch && squadrePronostico.length <= 2)) {
        let nuovoStatus;
        if (risultato.esito === 'Vinto') {
          nuovoStatus = 'WIN';
        } else if (risultato.esito === 'Perso') {
          nuovoStatus = 'LOSE';
        } else {
          continue;
        }

        console.log('âœ… MATCH TROVATO! ' + pronostico.partita + ' â†’ ' + nuovoStatus);

        await updateDoc(doc(db, 'aipredictions', pronostico.id), {
          status: nuovoStatus,
          risultato: risultato.risultato || risultato.Risultato || 'N/A',
          updatedat: new Date().toISOString()
        });

        aggiornati++;
        dettagli.push({
          data: pronostico.date,
          user: pronostico.user,
          partita: pronostico.partita,
          status: nuovoStatus,
          risultato: risultato.risultato || risultato.Risultato || 'N/A',
          matchPercentage: (matchPercentage * 100).toFixed(1)
        });
        matched = true;
        break;
      }
    }

    if (!matched) {
      notFound.push(pronostico.date + ' - ' + pronostico.partita + ' - Partita non trovata (lega: ' + pronostico.lega + ')');
    }
  }

  console.log('ğŸ¯ COMPLETATO: ' + aggiornati + ' pronostici aggiornati');

  let html = '';

  if (aggiornati > 0) {
    html += 'âœ… <strong>Aggiornati ' + aggiornati + ' pronostici!</strong><br><br>';
    dettagli.slice(0, 5).forEach(d => {
      html += 'ğŸ“… ' + d.data + ' - ' + d.user + ': ' + d.partita + ' â†’ ' + d.status + ' (' + d.risultato + ') [Match: ' + d.matchPercentage + '%]<br>';
    });
    if (dettagli.length > 5) {
      html += '<br>... e altri ' + (dettagli.length - 5) + ' aggiornamenti!';
    }
  } else {
    html += 'âŒ <strong>Nessun match trovato.</strong>';
  }

  if (notFound.length > 0) {
    html += '<br><br>ğŸ” <strong>Partite non trovate (' + notFound.length + '):</strong><br>';
    notFound.slice(0, 3).forEach(nf => {
      html += 'â“ ' + nf + '<br>';
    });
    if (notFound.length > 3) {
      html += '... e altre ' + (notFound.length - 3) + ' partite non trovate.';
    }
  }

  document.getElementById('matching-info').innerHTML = html;

  if (aggiornati > 0) {
    alert('âœ… Completato! Aggiornati ' + aggiornati + ' pronostici su Firebase.');
    await loadAllPredictions();
    applicaFiltriEStats();
  } else {
    alert('âŒ Nessun pronostico aggiornato. Controlla che il file risultati contenga tutte le leghe e date necessarie.');
  }
}

function pulisciFiltri() {
  document.getElementById('filter-status').value = 'all';
  document.getElementById('filter-tip').value = 'all';
  document.getElementById('filter-lega').value = 'all';
  document.getElementById('filter-prob-min').value = '';
  document.getElementById('filter-quota-min').value = '';
  applicaFiltriEStats();
}

// EVENT LISTENERS
document.getElementById('btn-estrai').addEventListener('click', estraiESalvaPronostici);
document.getElementById('btn-preview').addEventListener('click', previewScoring);

document.getElementById('btn-view-filtered').addEventListener('click', viewFilteredPredictions);
document.getElementById('btn-delete-filtered').addEventListener('click', deleteFilteredPredictions);
document.getElementById('btn-delete-user-all').addEventListener('click', deleteAllUserPredictions);

document.getElementById('btn-applica-filtri').addEventListener('click', applicaFiltriEStats);
document.getElementById('btn-aggiorna-risultati').addEventListener('click', aggiornaRisultati);

document.getElementById('btn-reset-user').addEventListener('click', function() {
  document.getElementById('stats-user').value = 'both';
  applicaFiltriEStats();
});

document.getElementById('btn-reset-date').addEventListener('click', function() {
  document.getElementById('data-da').value = '';
  document.getElementById('data-a').value = '';
  applicaFiltriEStats();
});

document.getElementById('btn-clear-filters').addEventListener('click', pulisciFiltri);

['filter-status', 'filter-tip', 'filter-lega'].forEach(function(id) {
  document.getElementById(id).addEventListener('change', applicaFiltriEStats);
});

['filter-prob-min', 'filter-quota-min'].forEach(function(id) {
  document.getElementById(id).addEventListener('input', function() {
    clearTimeout(window.filterTimeout);
    window.filterTimeout = setTimeout(applicaFiltriEStats, 500);
  });
});

document.getElementById('input-data').value = new Date().toISOString().split('T')[0];

initFirebase();

console.log('ğŸš€ AI Betting LIMITE-10 caricato!');
</script>
</body>
</html>