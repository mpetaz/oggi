<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motore AI di Analisi e Previsione Scommesse v5.4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; color: #374151; }
        .card { background-color: #ffffff; border: 1px solid #e5e7eb; border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.07), 0 2px 4px -2px rgb(0 0 0 / 0.07); }
        .btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s ease-in-out; cursor: pointer; }
        .btn-primary { background-color: #2563eb; color: white; border: 1px solid transparent; }
        .btn-primary:hover { background-color: #1d4ed8; }
        .btn-primary:disabled { background-color: #9ca3af; cursor: not-allowed; }
        .btn-secondary { background-color: #ffffff; color: #374151; border: 1px solid #d1d5db; }
        .btn-secondary:hover { background-color: #f9fafb; }
        .file-input-label { display: block; padding: 0.75rem 1.25rem; background-color: #f9fafb; color: #6b7280; border: 2px dashed #d1d5db; border-radius: 0.5rem; cursor: pointer; text-align: center; transition: all 0.2s; }
        .file-input-label:hover { background-color: #f3f4f6; border-color: #9ca3af; }
        input[type="file"] { display: none; }
        .table-wrapper { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid #e5e7eb; }
        th { background-color: #f9fafb; font-weight: 600; color: #4b5563; text-transform: uppercase; font-size: 0.75rem; }
        tbody tr:hover { background-color: #f3f4f6; }
        #loader { display: none; border: 4px solid #e5e7eb; border-top: 4px solid #2563eb; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 2rem auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .view-selection-btn { padding: 1.5rem; font-size: 1.1rem; text-align: center; border: 2px solid #e5e7eb; transition: all 0.3s; }
        .view-selection-btn:hover { border-color: #3b82f6; background-color: #eff6ff; }
        .view-selection-btn:disabled { border-color: #e5e7eb; background-color: #f9fafb; color: #9ca3af; cursor: not-allowed; }
        .view-selection-btn:disabled .text-2xl { filter: grayscale(100%); }
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 8px; animation: pulse 2s infinite; }
        .status-red { background-color: #ef4444; }
        .status-green { background-color: #22c55e; }
        .status-yellow { background-color: #f59e0b; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        #notification {
            position: fixed; top: 1.25rem; right: 1.25rem; padding: 1rem; border-radius: 0.5rem; color: white; font-weight: 600;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: opacity 0.5s, transform 0.5s; z-index: 1000; transform: translateX(100%); opacity: 0;
        }
        #notification.show { transform: translateX(0); opacity: 1; }
        .notification-success { background-color: #22c55e; }
        .notification-error { background-color: #ef4444; }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8">

    <div id="notification"></div>

    <div class="max-w-7xl mx-auto space-y-8">
        
        <div class="text-center">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">Motore AI di Analisi v5.4</h1>
            <p id="db-status-text" class="mt-2 text-lg text-gray-600 flex items-center justify-center text-center">
                <span id="db-status-dot" class="status-dot status-yellow"></span>
                <span>Connessione a Firebase in corso...</span>
            </p>
        </div>
        
        <div id="main-app" class="hidden">
            <!-- WORKSPACE & ACTIONS -->
            <div id="workspace-section" class="card">
                <div id="initial-load-view">
                    <h2 class="text-xl font-bold text-gray-800 mb-2">1. Area di Lavoro</h2>
                    <p class="text-gray-600 mb-4">Imposta la data e carica il file con le partite da analizzare.</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-end">
                         <div>
                            <label class="block text-sm font-medium mb-2 text-gray-700" for="prediction-date">Data delle Previsioni</label>
                            <input type="date" id="prediction-date" class="w-full bg-white border border-gray-300 rounded-md p-2.5 text-gray-800 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2 text-gray-700" for="today-file">File Partite da Analizzare</label>
                            <label for="today-file" class="file-input-label" id="today-label"><span>Seleziona file partite (.csv)</span></label>
                            <input type="file" id="today-file" accept=".csv">
                        </div>
                    </div>
                </div>
                
                <div id="action-selection" class="mt-8">
                    <h2 class="text-xl font-bold text-gray-800 mb-4">2. Azioni</h2>
                     <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <button id="show-mpetaz-btn" class="view-selection-btn rounded-lg" disabled>
                            <div class="text-2xl mb-2">ðŸ¤–</div>
                            <h2 class="font-bold text-lg text-gray-800">Strategia Mpetaz</h2>
                        </button>
                        <button id="show-gemini-btn" class="view-selection-btn rounded-lg" disabled>
                            <div class="text-2xl mb-2">ðŸ§ </div>
                            <h2 class="font-bold text-lg text-gray-800">Strategia Gemini</h2>
                        </button>
                        <button id="show-stats-btn" class="view-selection-btn rounded-lg">
                            <div class="text-2xl mb-2">ðŸ“Š</div>
                            <h2 class="font-bold text-lg text-gray-800">Statistiche</h2>
                        </button>
                    </div>
                </div>
            </div>

            <!-- ACTION VIEWS -->
            <div id="action-view-container" class="hidden mt-8">
                 <div class="flex justify-end mb-4">
                    <button id="back-to-menu-btn" class="btn btn-secondary text-sm">Torna al Menu Principale</button>
                </div>
                <div id="mpetaz-view" class="card hidden"></div>
                <div id="gemini-view" class="card hidden"></div>
                <div id="stats-view" class="card hidden"></div>
            </div>

            <!-- Results Section -->
            <div id="results-section" class="space-y-8" style="display: none;"></div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, collection, getDocs, writeBatch, doc, query, where } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        let todayData = {}, mpetazHistoricalData = {}, geminiHistoricalData = {}, verificationData = {};
        let db;

        const firebaseConfig = {
            apiKey: "AIzaSyDohOjXix2tRoEhm8vv1gCYrqXlNeXjbGM",
            authDomain: "oggi-17f48.firebaseapp.com",
            projectId: "oggi-17f48",
            storageBucket: "oggi-17f48.firebasestorage.app",
            messagingSenderId: "961828441770",
            appId: "1:961828441770:web:270382ebd68fb953ff8ad3"
        };
        
        // DOM Elements
        const dbStatusText = document.getElementById('db-status-text');
        const mainApp = document.getElementById('main-app');
        const workspaceSection = document.getElementById('workspace-section');
        const predictionDateInput = document.getElementById('prediction-date');
        const todayFileInput = document.getElementById('today-file');
        const actionViewContainer = document.getElementById('action-view-container');
        const showMpetazBtn = document.getElementById('show-mpetaz-btn');
        const showGeminiBtn = document.getElementById('show-gemini-btn');
        const showStatsBtn = document.getElementById('show-stats-btn');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        const mpetazView = document.getElementById('mpetaz-view');
        const geminiView = document.getElementById('gemini-view');
        const statsView = document.getElementById('stats-view');
        const resultsSection = document.getElementById('results-section');
        const notification = document.getElementById('notification');
        let notificationTimeout;

        function showNotification(message, type = 'success') {
            clearTimeout(notificationTimeout);
            notification.textContent = message;
            notification.className = type === 'success' ? 'notification-success' : 'notification-error';
            notification.classList.add('show');
            notificationTimeout = setTimeout(() => { notification.classList.remove('show'); }, 5000);
        }

        async function initializeFirebase() {
             try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                const auth = getAuth(app);
                await signInAnonymously(auth);
                dbStatusText.innerHTML = `<span class="status-dot status-green"></span> <span>Connesso a Firebase!</span>`;
                mainApp.style.display = 'block';
                predictionDateInput.value = new Date().toISOString().split('T')[0];
            } catch (error) {
                console.error("Firebase connection error:", error);
                dbStatusText.innerHTML = `<span class="status-dot status-red"></span> <span>Errore di connessione a Firebase.</span>`
            }
        }
        
        const hideAllActionViews = () => {
            mpetazView.classList.add('hidden');
            geminiView.classList.add('hidden');
            statsView.classList.add('hidden');
            resultsSection.style.display = 'none';
        }
        
        const showActionView = (viewElement) => {
            workspaceSection.classList.add('hidden');
            actionViewContainer.classList.remove('hidden');
            hideAllActionViews();
            viewElement.classList.remove('hidden');
        }

        backToMenuBtn.addEventListener('click', () => {
             workspaceSection.classList.remove('hidden');
             actionViewContainer.classList.add('hidden');
             hideAllActionViews();
        });

        showMpetazBtn.addEventListener('click', () => {
            showActionView(mpetazView);
            mpetazView.innerHTML = generateStrategyHTML('mpetaz');
            document.getElementById('historical-file-mpetaz').addEventListener('change', (e) => handleFileUpload(e, 'mpetazHistorical', document.getElementById('historical-label-mpetaz')));
            document.getElementById('analyze-btn-mpetaz').addEventListener('click', () => analyze('mpetaz'));
        });

        showGeminiBtn.addEventListener('click', () => {
            showActionView(geminiView);
            geminiView.innerHTML = generateStrategyHTML('gemini');
            document.getElementById('historical-file-gemini').addEventListener('change', (e) => handleFileUpload(e, 'geminiHistorical', document.getElementById('historical-label-gemini')));
            document.getElementById('analyze-btn-gemini').addEventListener('click', () => analyze('gemini'));
        });

        showStatsBtn.addEventListener('click', async () => {
            showActionView(statsView);
            statsView.innerHTML = generateStatsHTML();
            document.getElementById('historical-file-verify').addEventListener('change', (e) => handleFileUpload(e, 'verification', document.getElementById('historical-label-verify')));
            document.getElementById('verify-btn').addEventListener('click', verifyPredictions);
            await displayStatistics();
        });
        
        function generateStrategyHTML(engine) {
            const title = engine === 'mpetaz' ? 'Strategia Mpetaz ðŸ¤–' : 'Strategia Gemini ðŸ§ ';
            return `
                <h2 class="text-2xl font-bold text-gray-900 mb-4">${title}</h2>
                <p class="mb-4 text-gray-600">Stai analizzando il file <strong>${todayData.name || 'N/A'}</strong> per la data <strong>${predictionDateInput.value}</strong>.</p>
                <div>
                    <label class="block text-sm font-medium mb-2 text-gray-700" for="historical-file-${engine}">Carica File Storico di Riferimento</label>
                    <label for="historical-file-${engine}" class="file-input-label" id="historical-label-${engine}"><span>Seleziona file storico (.csv)</span></label>
                    <input type="file" id="historical-file-${engine}" accept=".csv">
                </div>
                <div class="mt-6 text-center">
                    <button id="analyze-btn-${engine}" class="btn btn-primary w-full md:w-auto">Analizza e Salva Pronostici</button>
                </div>
                <div id="error-message-${engine}" class="mt-4 text-center text-red-600 font-semibold"></div>`;
        }
        
        function generateStatsHTML() {
            return `
                <h2 class="text-2xl font-bold text-gray-900 mb-4">Verifica e Statistiche Performance</h2>
                <div class="card bg-gray-50">
                     <h3 class="font-bold text-lg mb-2">Verifica Risultati Pronostici</h3>
                     <p class="text-gray-600 mb-4">Carica il file storico aggiornato per verificare i pronostici salvati.</p>
                     <div>
                        <label class="block text-sm font-medium mb-2 text-gray-700" for="historical-file-verify">Carica File Risultati</label>
                        <label for="historical-file-verify" class="file-input-label" id="historical-label-verify"><span>Seleziona file risultati (.csv)</span></label>
                        <input type="file" id="historical-file-verify" accept=".csv">
                    </div>
                    <button id="verify-btn" class="btn btn-primary mt-4">Verifica Risultati</button>
                </div>
                 <div id="stats-results-container" class="card mt-8"></div>`;
        }

        const parseCSV = (text) => {
            const lines = text.trim().replace(/\r/g, "").split('\n');
            const headerMap = { 'data': 'Data', 'lega': 'Lega', 'partita': 'Partita', 'risultato': 'Risultato', 'probabilitÃ ': 'ProbabilitÃ ', 'probabilita': 'ProbabilitÃ ', 'mercato': 'Mercato', 'tip': 'Tip', 'quota': 'Quota', 'esito': 'Vinto/Perso', 'ora': 'Ora' };
            const rawHeader = lines[0].split(',').map(h => h.trim().toLowerCase());
            const header = rawHeader.map(h => headerMap[h] || h.charAt(0).toUpperCase() + h.slice(1));
            return lines.slice(1).map(line => {
                if (!line.trim()) return null;
                const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => { let value = v.trim(); if (value.startsWith('"') && value.endsWith('"')) value = value.substring(1, value.length - 1); return value.trim(); });
                const entry = {};
                header.forEach((col, index) => { if (col && index < values.length) entry[col] = values[index]; });
                return entry;
            }).filter(Boolean);
        };

        const handleFileUpload = (event, dataType, labelElement) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const parsedData = parseCSV(e.target.result);
                    if (dataType === 'today') {
                        todayData.data = parsedData;
                        todayData.name = file.name;
                        showMpetazBtn.disabled = false;
                        showGeminiBtn.disabled = false;
                    } else if (dataType === 'mpetazHistorical') {
                        mpetazHistoricalData.data = parsedData;
                        mpetazHistoricalData.name = file.name;
                    } else if (dataType === 'geminiHistorical') {
                        geminiHistoricalData.data = parsedData;
                        geminiHistoricalData.name = file.name;
                    } else if (dataType === 'verification') {
                        verificationData.data = parsedData;
                        verificationData.name = file.name;
                    }
                    labelElement.querySelector('span').textContent = file.name;
                } catch (error) {
                    showNotification(`Errore nel parsing del file ${file.name}.`, 'error');
                }
            };
            reader.readAsText(file);
        };

        todayFileInput.addEventListener('change', (e) => handleFileUpload(e, 'today', document.getElementById('today-label')));

        function analyze(engine) {
            const historicalFile = engine === 'mpetaz' ? mpetazHistoricalData : geminiHistoricalData;
            const errorEl = document.getElementById(`error-message-${engine}`);
            const predictionDate = predictionDateInput.value;

            if (!predictionDate) {
                showNotification('Per favore, imposta una data valida nell\'Area di Lavoro Principale.', 'error');
                return;
            }
            if (!todayData.data || todayData.data.length === 0) {
                 showNotification('Errore: Ricarica il file delle partite da analizzare.', 'error');
                return;
            }
            if (!historicalFile.data || historicalFile.data.length === 0) {
                errorEl.textContent = 'Per favore, carica un file storico di riferimento.';
                return;
            }
            
            errorEl.textContent = '';
            resultsSection.style.display = 'block';
            resultsSection.innerHTML = '<div id="loader" style="display:block;"></div>';
            
            setTimeout(() => {
                let scoredMatches;
                if (engine === 'mpetaz') {
                    scoredMatches = runMpetazAnalysis(historicalFile.data, todayData.data);
                } else {
                    scoredMatches = runGeminiAnalysis(historicalFile.data, todayData.data);
                }
                
                if (scoredMatches) {
                     renderResults(scoredMatches, engine);
                     savePredictionsToFirebase(scoredMatches, engine, predictionDate);
                }
            }, 50);
        }
        
        async function savePredictionsToFirebase(matches, engine, predictionDate) {
            const predictionsRef = collection(db, "predictions");
            const q = query(predictionsRef, where("date", "==", predictionDate), where("engine", "==", engine));
            const existingPredictionsSnapshot = await getDocs(q);
            const deleteBatch = writeBatch(db);
            existingPredictionsSnapshot.forEach(doc => deleteBatch.delete(doc.ref));
            await deleteBatch.commit();
            const addBatch = writeBatch(db);
            const matchesToSave = matches.slice(0, 10);
            matchesToSave.forEach(match => {
                const newPredictionRef = doc(predictionsRef);
                const predictionData = {
                    date: predictionDate, engine: engine, match: match.Partita, league: match.Lega,
                    market: match.Mercato, tip: match.Tip, quota: match.Quota,
                    score: match.Punteggio, status: 'In Attesa'
                };
                addBatch.set(newPredictionRef, predictionData);
            });
            try {
                await addBatch.commit();
                showNotification(`${matchesToSave.length} nuovi pronostici per il ${predictionDate} (${engine}) salvati!`);
            } catch (error) {
                showNotification(`Errore nel salvataggio: ${error.message}`, 'error');
            }
        }
        
        async function verifyPredictions() {
            if (!verificationData.data || verificationData.data.length === 0) {
                showNotification('Carica un file di risultati per la verifica.', 'error');
                return;
            }
            const verifyBtn = document.getElementById('verify-btn');
            verifyBtn.disabled = true;
            verifyBtn.textContent = 'Verifica in corso...';
            const predictionsRef = collection(db, "predictions");
            const q = query(predictionsRef, where("status", "==", "In Attesa"));
            const pendingPredictionsSnapshot = await getDocs(q);
            if (pendingPredictionsSnapshot.empty) {
                showNotification('Nessun pronostico in attesa da verificare.');
                verifyBtn.disabled = false;
                verifyBtn.textContent = 'Verifica Risultati';
                return;
            }
            const batch = writeBatch(db);
            let verifiedCount = 0;
            pendingPredictionsSnapshot.forEach(predDoc => {
                const prediction = predDoc.data();
                const resultInHistory = verificationData.data.find(hist => hist.Partita === prediction.match && hist.Lega === prediction.league);
                if (resultInHistory && resultInHistory.esito) {
                    const newStatus = resultInHistory.esito.trim();
                    const docRef = doc(db, "predictions", predDoc.id);
                    batch.update(docRef, { status: newStatus });
                    verifiedCount++;
                }
            });
            try {
                await batch.commit();
                showNotification(`${verifiedCount} pronostici sono stati verificati e aggiornati!`);
            } catch (error) {
                showNotification(`Errore durante l'aggiornamento: ${error.message}`, 'error');
            }
            verifyBtn.disabled = false;
            verifyBtn.textContent = 'Verifica Risultati';
            await displayStatistics();
        }

        async function displayStatistics() {
            const statsContainer = document.getElementById('stats-results-container');
            statsContainer.innerHTML = 'Caricamento statistiche...';
            const predictionsSnapshot = await getDocs(collection(db, "predictions"));
            const allPredictions = predictionsSnapshot.docs.map(doc => doc.data());
            if (allPredictions.length === 0) {
                statsContainer.innerHTML = '<h3 class="font-bold text-lg mb-2">Statistiche Performance</h3><p>Nessun pronostico salvato.</p>';
                return;
            }
            const stats = {
                total: allPredictions.length,
                won: allPredictions.filter(p => p.status === 'Vinto').length,
                lost: allPredictions.filter(p => p.status === 'Perso').length,
                pending: allPredictions.filter(p => p.status === 'In Attesa').length,
                mpetaz: {
                    total: allPredictions.filter(p => p.engine === 'mpetaz' && p.status !== 'In Attesa').length,
                    won: allPredictions.filter(p => p.engine === 'mpetaz' && p.status === 'Vinto').length,
                },
                gemini: {
                    total: allPredictions.filter(p => p.engine === 'gemini' && p.status !== 'In Attesa').length,
                    won: allPredictions.filter(p => p.engine === 'gemini' && p.status === 'Vinto').length,
                }
            };
            const overallRate = stats.won + stats.lost > 0 ? ((stats.won / (stats.won + stats.lost)) * 100).toFixed(1) : 0;
            const mpetazRate = stats.mpetaz.total > 0 ? ((stats.mpetaz.won / stats.mpetaz.total) * 100).toFixed(1) : 0;
            const geminiRate = stats.gemini.total > 0 ? ((stats.gemini.won / stats.gemini.total) * 100).toFixed(1) : 0;
            statsContainer.innerHTML = `
                <h3 class="font-bold text-lg mb-4">Statistiche Performance Totali</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                    <div><p class="text-2xl font-bold">${stats.total}</p><p class="text-sm text-gray-500">Pronostici</p></div>
                    <div><p class="text-2xl font-bold text-green-600">${stats.won}</p><p class="text-sm text-gray-500">Vinti</p></div>
                    <div><p class="text-2xl font-bold text-red-600">${stats.lost}</p><p class="text-sm text-gray-500">Persi</p></div>
                    <div><p class="text-2xl font-bold text-blue-600">${overallRate}%</p><p class="text-sm text-gray-500">Successo</p></div>
                </div>
                 <hr class="my-6">
                 <h3 class="font-bold text-lg mb-4">Performance per Motore</h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="p-4 rounded-lg bg-gray-50"><h4 class="font-semibold text-center mb-2">ðŸ¤– Mpetaz</h4><p>Successo: <span class="font-bold">${mpetazRate}%</span> (${stats.mpetaz.won} / ${stats.mpetaz.total})</p></div>
                    <div class="p-4 rounded-lg bg-gray-50"><h4 class="font-semibold text-center mb-2">ðŸ§  Gemini</h4><p>Successo: <span class="font-bold">${geminiRate}%</span> (${stats.gemini.won} / ${stats.gemini.total})</p></div>
                 </div>
                 <p class="text-center mt-4 text-sm text-gray-500">${stats.pending} pronostici in attesa di verifica.</p>
            `;
        }
        
        const calculateFilteredStats = (data) => {
            const stats = { league: {}, tip: {}, specific: {}, market: {}, global: { won: 0, total: 0 } };
            data.forEach(row => {
                const { Lega, Mercato, Tip } = row;
                const result = row['Vinto/Perso'];
                if (Lega && Lega.toLowerCase().includes('cup')) return;
                if (!result || !Lega || !Mercato || !Tip) return;
                const won = (result.trim().toLowerCase() === 'vinto') ? 1 : 0;
                if (!stats.league[Lega]) stats.league[Lega] = { won: 0, total: 0 };
                stats.league[Lega].total++; stats.league[Lega].won += won;
                if (!stats.tip[Tip]) stats.tip[Tip] = { won: 0, total: 0 };
                stats.tip[Tip].total++; stats.tip[Tip].won += won;
                stats.global.total++; stats.global.won += won;
                const keySpecific = `${Lega}|${Mercato}|${Tip}`;
                if (!stats.specific[keySpecific]) stats.specific[keySpecific] = { won: 0, total: 0 };
                stats.specific[keySpecific].total++; stats.specific[keySpecific].won += won;
                const keyMarket = `${Lega}|${Mercato}`;
                if (!stats.market[keyMarket]) stats.market[keyMarket] = { won: 0, total: 0 };
                stats.market[keyMarket].total++; stats.market[keyMarket].won += won;
            });
            Object.values(stats.league).forEach(s => s.rate = s.total > 0 ? s.won / s.total : 0);
            Object.values(stats.tip).forEach(s => s.rate = s.total > 0 ? s.won / s.total : 0);
            return stats;
        };
        const runMpetazAnalysis = (historical, today) => {
            const stats = calculateFilteredStats(historical);
            const historicalLeagues = new Set(Object.keys(stats.league));
            const historicalTips = new Set(Object.keys(stats.tip));
            let minHistoricalProb = 101, maxHistoricalProb = 0;
            const validHistoricalData = historical.filter(row => !(row.Lega && row.Lega.toLowerCase().includes('cup')) && row.ProbabilitÃ );
            validHistoricalData.forEach(row => {
                const probValue = parseInt(String(row.ProbabilitÃ ).replace('%', ''));
                if (!isNaN(probValue)) {
                    if (probValue < minHistoricalProb) minHistoricalProb = probValue;
                    if (probValue > maxHistoricalProb) maxHistoricalProb = probValue;
                }
            });
            const scoredMatches = today.filter(match => {
                const quotaFloat = parseFloat(String(match.Quota).replace(',', '.'));
                return !(match.Lega && match.Lega.toLowerCase().includes('cup')) && !isNaN(quotaFloat) && quotaFloat >= 1.20;
            }).map(match => {
                const { Lega, Tip, Quota, ProbabilitÃ  } = match;
                if (!Lega || !Tip || !Quota || !ProbabilitÃ ) return null;
                let rawScore = 0; const maxRawScore = 75; 
                if (historicalLeagues.has(Lega)) rawScore += stats.league[Lega].rate * 20;
                else if (Lega.startsWith('EU-')) rawScore += 5;
                if (historicalTips.has(Tip)) rawScore += stats.tip[Tip].rate * 20;
                else if (Lega.startsWith('EU-')) rawScore += 5;
                const probValue = parseInt(String(ProbabilitÃ ).replace('%', ''));
                if (!isNaN(probValue)) {
                    if (probValue >= minHistoricalProb && probValue <= maxHistoricalProb) rawScore += 20;
                    else if (probValue >= minHistoricalProb - 3) rawScore += 10;
                    else if (probValue >= minHistoricalProb - 7) rawScore += 5;
                }
                const quotaFloat = parseFloat(String(Quota).replace(',', '.'));
                if (isNaN(quotaFloat)) return null;
                if (quotaFloat >= 1.40) rawScore += 15;
                else if (quotaFloat >= 1.20) rawScore += ((quotaFloat - 1.20) / (1.40 - 1.20)) * 15;
                return { ...match, Quota: quotaFloat, Punteggio: ((rawScore / maxRawScore) * 100).toFixed(2) };
            }).filter(Boolean);
            scoredMatches.sort((a, b) => b.Punteggio - a.Punteggio);
            return scoredMatches;
        };
        const runGeminiAnalysis = (historical, today) => {
            const stats = calculateFilteredStats(historical);
            const scoredMatches = today.filter(match => {
                const quotaFloat = parseFloat(String(match.Quota).replace(',', '.'));
                return !(match.Lega && match.Lega.toLowerCase().includes('cup')) && !isNaN(quotaFloat) && quotaFloat >= 1.20;
            }).map(match => {
                const { Lega, Mercato, Tip, Quota } = match;
                if (!Lega || !Mercato || !Tip || !Quota) return null;
                const keySpecific = `${Lega}|${Mercato}|${Tip}`, keyMarket = `${Lega}|${Mercato}`, keyLeague = Lega;
                let historicalStat = null, justification = "", confidence = 1.0; 
                if (stats.specific[keySpecific]) { historicalStat = stats.specific[keySpecific]; justification = `Dato specifico (${historicalStat.total}p)`;
                } else if (stats.market[keyMarket]) { historicalStat = stats.market[keyMarket]; justification = `Basato su mercato (${historicalStat.total}p)`; confidence = 0.95; 
                } else if (stats.league[keyLeague]) { historicalStat = stats.league[keyLeague]; justification = `Basato su lega (${historicalStat.total}p)`; confidence = 0.90; 
                } else { historicalStat = stats.global; justification = `Dato Globale (${historicalStat.total}p totali)`; confidence = 0.80; }
                const successRate = (historicalStat.total > 0) ? (historicalStat.won / historicalStat.total) * 100 : 0;
                const quotaFloat = parseFloat(String(Quota).replace(',', '.'));
                if (isNaN(quotaFloat)) return null;
                const valueScore = successRate * (Math.log(quotaFloat) + 1);
                const finalScore = ((successRate * 0.7) + (valueScore * 0.3)) * confidence;
                return { ...match, Quota: quotaFloat, Punteggio: finalScore.toFixed(2), Justification: `${(successRate).toFixed(1)}% successo storico. ${justification}` };
            }).filter(Boolean);
            scoredMatches.sort((a, b) => b.Punteggio - a.Punteggio);
            return scoredMatches;
        };
        const renderResults = (matches, mode) => {
            const resultsContainer = document.getElementById('results-section');
            resultsContainer.innerHTML = `
                <div id="loader"></div>
                <div id="top-10-container" class="card"></div>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div id="safe-bet-container" class="card"></div>
                    <div id="value-bet-container" class="card"></div>
                </div>`;
            const topTitle = mode === 'Mpetaz' ? 'ðŸ† Migliori Partite (Metodo Mpetaz)' : 'ðŸ§  Migliori Partite (Metodo Gemini)';
            const headers = ['Ora', 'Lega', 'Partita', 'Mercato', 'Tip', 'ProbabilitÃ ', 'Quota', 'Punteggio'];
            const columns = ['Ora', 'Lega', 'Partita', 'Mercato', 'Tip', 'ProbabilitÃ ', 'Quota', 'Punteggio'];
            const greenMatches = matches.filter(m => parseFloat(m.Punteggio) >= 80);
            let matchesToShow = greenMatches.length > 10 ? greenMatches : matches.slice(0, 10);
            if (mode === 'Gemini') { headers.push('Note Gemini'); columns.push('Justification'); }
            headers.push('Azioni'); columns.push('Azioni');
            renderTable(document.getElementById('top-10-container'), topTitle, headers, matchesToShow, columns);
            buildAndRenderMultiples(matches);
        };
        const renderTable = (container, title, headers, data, columns) => {
            let tableHTML = `<h2 class="text-xl font-bold text-gray-800 mb-4">${title}</h2>`;
            if (data.length === 0) { tableHTML += `<p class="text-gray-500">Nessuna partita ha superato i criteri di analisi.</p>`; container.innerHTML = tableHTML; return; }
            tableHTML += `<div class="table-wrapper"><table><thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead><tbody>`;
            data.forEach(row => {
                tableHTML += `<tr>`;
                columns.forEach(col => {
                    let cellValue = row[col] || '-';
                    if (col === 'Punteggio') {
                        const score = parseFloat(cellValue);
                        const color = score >= 80 ? 'bg-green-500' : score >= 60 ? 'bg-yellow-500' : 'bg-red-500';
                        cellValue = `<div class="w-full bg-gray-200 rounded-full h-2.5"><div class="${color} h-2.5 rounded-full" style="width: ${score}%"></div></div><span class="font-semibold text-gray-700">${cellValue}</span>`;
                    } else if (col === 'Quota' && typeof cellValue === 'number') { cellValue = cellValue.toFixed(2);
                    } else if (col === 'Justification') { cellValue = `<span class="text-sm italic text-gray-500">${cellValue}</span>`;
                    } else if (col === 'Azioni') {
                        const searchQuery = encodeURIComponent(`${row.Partita} orario partita`);
                        cellValue = `<a href="https://www.google.com/search?q=${searchQuery}" target="_blank" class="text-blue-600 hover:text-blue-800 font-semibold text-sm">Cerca Orario</a>`;
                    }
                    tableHTML += `<td>${cellValue}</td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table></div>`;
            container.innerHTML = tableHTML;
        };
        const buildAndRenderMultiples = (matches) => {
            const oddsMultiplier = 0.9;
            const valueMatches = [...matches].map(m => ({...m, value: m.Punteggio > 0 ? m.Punteggio / m.Quota : 0})).sort((a,b) => b.value - a.value);
            const safeBet = buildMultipla(matches, 2, oddsMultiplier);
            const valueBet = buildMultipla(valueMatches, 3, oddsMultiplier);
            const safeBetContainer = document.getElementById('safe-bet-container');
            const valueBetContainer = document.getElementById('value-bet-container');
            if (safeBet) renderMultipla(safeBetContainer, 'Multipla "Prudente" (Doppia)', safeBet, "Basata sulle 2 partite con il punteggio piÃ¹ alto.");
            else safeBetContainer.innerHTML = `<h2 class="text-xl font-bold text-gray-800 mb-4">Multipla "Prudente" (Doppia)</h2><p class="text-gray-500">Non ci sono abbastanza partite per creare una doppia.</p>`;
            if (valueBet) renderMultipla(valueBetContainer, 'Multipla "Value Net" (Tripla)', valueBet, "Basata sulle 3 partite con il miglior rapporto punteggio/quota.");
            else valueBetContainer.innerHTML = `<h2 class="text-xl font-bold text-gray-800 mb-4">Multipla "Value Net" (Tripla)</h2><p class="text-gray-500">Non ci sono abbastanza partite per creare una tripla di valore.</p>`;
        };
        const buildMultipla = (sortedMatches, numEvents, oddsMultiplier) => {
            if (sortedMatches.length < numEvents) return null;
            let multipla = { matches: [], totalOdds: 1, totalOddsAdjusted: 1 };
            const usedMatches = new Set();
            for (const match of sortedMatches) {
                if (multipla.matches.length >= numEvents) break;
                if (!usedMatches.has(match.Partita)) {
                    multipla.matches.push(match);
                    multipla.totalOdds *= match.Quota;
                    multipla.totalOddsAdjusted *= (match.Quota * oddsMultiplier);
                    usedMatches.add(match.Partita);
                }
            }
            return multipla.matches.length === numEvents ? multipla : null;
        };
        const renderMultipla = (container, title, multipla, justification) => {
            let html = `<h2 class="text-xl font-bold text-gray-800 mb-4">${title}</h2>`;
            html += `<div class="mb-4 space-y-2">
                <p><span class="font-semibold text-gray-600">Quota Stimata:</span> <span class="text-2xl font-bold text-blue-600">${multipla.totalOddsAdjusted.toFixed(2)}</span></p>
                <p class="text-sm text-gray-500"><span class="font-semibold">Quota Originale:</span> ${multipla.totalOdds.toFixed(2)}</p>
                <p class="text-sm italic text-gray-500">"${justification}"</p>
            </div>`;
            html += `<div class="table-wrapper"><table><thead><tr><th>Ora</th><th>Partita</th><th>Tip</th><th>Quota</th><th>Punteggio</th></tr></thead><tbody>`;
            multipla.matches.forEach(m => {
                html += `<tr><td>${m.Ora || '-'}</td><td>${m.Partita}</td><td>${m.Mercato}, ${m.Tip}</td><td>${m.Quota.toFixed(2)}</td><td>${m.Punteggio}</td></tr>`;
            });
            html += `</tbody></table></div>`;
            container.innerHTML = html;
        };

        // Initialize Firebase on page load
        initializeFirebase();

    </script>
</body>
</html>

