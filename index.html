<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TipsterAI - Pronostici</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.85) 100%);
            backdrop-filter: blur(10px);
        }

        .strategy-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .strategy-btn:active {
            transform: scale(0.95);
        }

        .strategy-btn.magic-ai {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 8px 24px rgba(245, 158, 11, 0.4);
            border: 2px solid #fbbf24;
        }

        .strategy-info {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .strategy-info:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .match-card {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            transition: all 0.3s ease;
        }

        .match-card:active {
            transform: translateY(2px);
        }

        .score-badge {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
        }

        .flag-btn {
            transition: all 0.2s ease;
        }

        .flag-btn.flagged {
            color: #f59e0b !important;
            transform: scale(1.2);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.4s ease-out;
        }
    </style>
</head>

<body class="text-white">
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="text-white text-2xl font-bold mb-4 animate-pulse">TipsterAI</div>
            <div class="text-blue-300 text-sm">Caricamento...</div>
        </div>
    </div>

    <!-- Login/Register Screen (hidden after login) -->
    <div id="login-container"
        class="hidden fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-40 px-4">
        <div class="bg-white rounded-2xl p-8 max-w-md w-full text-gray-800">
            <h2 id="auth-title" class="text-2xl font-bold mb-6 text-center">Accedi a TipsterAI</h2>

            <!-- Toggle Login/Register -->
            <div class="flex mb-6 bg-gray-100 rounded-lg p-1">
                <button id="toggle-login"
                    class="flex-1 py-2 rounded-lg font-semibold bg-purple-600 text-white transition">
                    Accedi
                </button>
                <button id="toggle-register" class="flex-1 py-2 rounded-lg font-semibold text-gray-600 transition">
                    Registrati
                </button>
            </div>

            <form id="auth-form" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-1">Email</label>
                    <input type="email" id="email" required
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Password</label>
                    <input type="password" id="password" required minlength="6"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none">
                    <div class="text-xs text-gray-500 mt-1">Minimo 6 caratteri</div>
                </div>
                <div id="auth-error" class="text-red-500 text-sm hidden"></div>
                <button type="submit" id="auth-submit-btn"
                    class="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-3 rounded-lg font-bold hover:opacity-90">
                    Accedi
                </button>
            </form>
        </div>
    </div>

    <!-- Main App -->
    <div id="app-container" class="hidden">
        <!-- Top Bar -->
        <div class="bg-gradient-to-r from-purple-700 to-blue-700 shadow-lg sticky top-0 z-40">
            <div class="container mx-auto px-4 py-4 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <img src="logo.png" alt="TipsterAI" class="h-10 w-10 rounded-lg">
                    <h1 class="text-2xl font-black">TipsterAI</h1>
                </div>
                <button id="logout-btn" class="text-sm hover:text-yellow-300 transition">
                    <i class="fa-solid fa-right-from-bracket mr-1"></i> Esci
                </button>
            </div>
        </div>

        <!-- Stats Dashboard -->
        <div id="stats-dashboard" class="container mx-auto px-4 py-6">
            <!-- Riga 1: Box grande totale -->
            <div class="stat-card rounded-xl p-4 text-center mb-3">
                <div class="text-gray-700 text-xs font-semibold mb-1">Pronostici da agosto 2025</div>
                <div id="stat-total" class="text-3xl font-black text-blue-800">-</div>
            </div>

            <!-- Riga 2: 3 box piccoli -->
            <div class="grid grid-cols-3 gap-3 mb-4">
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">Pronostici<br>VINTI</div>
                    <div id="stat-wins" class="text-xl font-black text-green-600">-</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">Pronostici<br>PERSI</div>
                    <div id="stat-losses" class="text-xl font-black text-red-600">-</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">WINRATE</div>
                    <div id="stat-winrate" class="text-xl font-black text-green-600">-</div>
                </div>
            </div>

            <div class="stat-card rounded-lg px-4 py-2 text-center">
                <div class="text-gray-600 text-xs">
                    <i class="fa-solid fa-sparkles mr-1"></i>
                    Aggiornata per nuovi Pronostici: <span id="last-update" class="font-semibold">-</span>
                </div>
            </div>
        </div>

        <!-- Strategies Page -->
        <div id="page-strategies" class="page active container mx-auto px-4 pb-24">
            <h2 class="text-2xl font-bold mb-4 text-center">üìä Seleziona una Strategia</h2>
            <div id="strategies-grid" class="grid grid-cols-2 md:grid-cols-3 gap-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Ranking Page -->
        <div id="page-ranking" class="page container mx-auto px-4 pb-24">
            <div class="flex items-center justify-between mb-4">
                <button id="back-to-strategies" class="text-sm hover:text-yellow-300">
                    <i class="fa-solid fa-arrow-left mr-1"></i> Tutte le Strategie
                </button>
                <h2 id="strategy-title" class="text-xl font-bold">-</h2>
            </div>

            <!-- Sorting Toggle -->
            <div class="flex gap-2 mb-4">
                <button id="sort-by-score"
                    class="flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm">
                    üìä Per Ranking
                </button>
                <button id="sort-by-time"
                    class="flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm">
                    üïê Per Orario
                </button>
            </div>

            <div id="matches-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- My Matches Page -->
        <div id="page-my-matches" class="page container mx-auto px-4 pb-24">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-bold">‚≠ê Le Mie Partite</h2>
                <button id="delete-all-matches-btn"
                    class="bg-red-600 text-white px-4 py-2 rounded-lg font-semibold text-sm hover:bg-red-700 transition">
                    <i class="fa-solid fa-trash mr-1"></i> Cancella Tutte
                </button>
            </div>

            <!-- Sorting Toggle for My Matches -->
            <div class="flex gap-2 mb-4">
                <button id="my-matches-sort-score"
                    class="flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm">
                    üìä Per Ranking
                </button>
                <button id="my-matches-sort-time"
                    class="flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm">
                    üïê Per Orario
                </button>
            </div>

            <div id="my-matches-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Bottom Nav -->
        <div class="fixed bottom-0 left-0 right-0 bg-gray-900 border-t border-gray-700 flex justify-around py-3 z-50">
            <button data-page="strategies" class="nav-btn flex flex-col items-center text-purple-400 transition">
                <i class="fa-solid fa-list text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Strategie</span>
            </button>
            <button data-page="my-matches"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-yellow-400 transition">
                <i class="fa-solid fa-star text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Mie Partite</span>
            </button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyCwAy4QfYlbxj4yBLnho3ZnO2_NaxzbVRQ",
            authDomain: "betmines-pronostici.firebaseapp.com",
            projectId: "betmines-pronostici",
            storageBucket: "betmines-pronostici.firebasestorage.app",
            messagingSenderId: "716119578109",
            appId: "1:716119578109:web:01e8b9dad7b17c91d63594"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // State
        let currentUser = null;
        let strategiesData = null;
        let selectedMatches = [];
        let currentStrategyId = null;  // Track current strategy for re-sorting
        let currentSortMode = 'score';  // 'score' or 'time'
        let isRegisterMode = false;  // Track if user is in registration mode
        let globalStats = { total: 0, wins: 0, losses: 0, winrate: 0 }; // Global stats for AI

        // Date formatting
        function formatDateIT(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            return `${day}/${month}/${year}`;
        }

        // Toggle between Login and Register
        document.getElementById('toggle-login').addEventListener('click', () => {
            isRegisterMode = false;
            document.getElementById('auth-title').textContent = 'Accedi a TipsterAI';
            document.getElementById('auth-submit-btn').textContent = 'Accedi';
            document.getElementById('toggle-login').className = 'flex-1 py-2 rounded-lg font-semibold bg-purple-600 text-white transition';
            document.getElementById('toggle-register').className = 'flex-1 py-2 rounded-lg font-semibold text-gray-600 transition';
        });

        document.getElementById('toggle-register').addEventListener('click', () => {
            isRegisterMode = true;
            document.getElementById('auth-title').textContent = 'Registrati a TipsterAI';
            document.getElementById('auth-submit-btn').textContent = 'Registrati';
            document.getElementById('toggle-login').className = 'flex-1 py-2 rounded-lg font-semibold text-gray-600 transition';
            document.getElementById('toggle-register').className = 'flex-1 py-2 rounded-lg font-semibold bg-purple-600 text-white transition';
        });

        // Clean up old matches (> 24h)
        async function cleanupOldMatches(userId) {
            try {
                const userMatchesDoc = await getDoc(doc(db, "users", userId, "data", "selected_matches"));
                if (!userMatchesDoc.exists()) return;

                const data = userMatchesDoc.data();
                const now = Date.now();
                const oneDayMs = 24 * 60 * 60 * 1000;

                // Filter out matches older than 24h
                const freshMatches = (data.matches || []).filter(m => {
                    const matchDate = new Date(m.data).getTime();
                    return (now - matchDate) < oneDayMs;
                });

                const removed = data.matches.length - freshMatches.length;
                if (removed > 0) {
                    await setDoc(doc(db, "users", userId, "data", "selected_matches"), {
                        matches: freshMatches,
                        updated: now
                    });
                    console.log(`[Auto-Cleanup] Removed ${removed} old matches (>24h)`);
                }

                selectedMatches = freshMatches;
            } catch (e) {
                console.error('[Auto-Cleanup] Error:', e);
            }
        }

        // Auth Check
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;

                // Auto-cleanup old matches
                await cleanupOldMatches(user.uid);

                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('app-container').classList.remove('hidden');
                await loadData();
            } else {
                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('login-container').classList.remove('hidden');
            }
        });

        // Login/Register
        document.getElementById('auth-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('auth-error');

            try {
                if (isRegisterMode) {
                    // REGISTER
                    await createUserWithEmailAndPassword(auth, email, password);
                    console.log('[Auth] User registered successfully');
                } else {
                    // LOGIN
                    await signInWithEmailAndPassword(auth, email, password);
                    console.log('[Auth] User logged in successfully');
                }
            } catch (e) {
                console.error('[Auth] Error:', e);

                // User-friendly error messages
                let errorMsg = 'Errore di autenticazione';
                if (e.code === 'auth/email-already-in-use') {
                    errorMsg = 'Email gi√† registrata. Usa il login.';
                } else if (e.code === 'auth/weak-password') {
                    errorMsg = 'Password troppo debole (min 6 caratteri)';
                } else if (e.code === 'auth/user-not-found' || e.code === 'auth/wrong-password') {
                    errorMsg = 'Email o password errati';
                } else if (e.code === 'auth/invalid-email') {
                    errorMsg = 'Email non valida';
                }

                errorDiv.textContent = errorMsg;
                errorDiv.classList.remove('hidden');
            }
        });

        // Logout
        document.getElementById('logout-btn').addEventListener('click', () => signOut(auth));

        // Load Data
        async function loadData() {
            try {
                // Load ALL strategies from strategy_results
                const strategiesDoc = await getDoc(doc(db, "system", "strategy_results"));
                if (!strategiesDoc.exists()) {
                    console.error('[Client] strategy_results not found!');
                    return;
                }

                const allStrategies = strategiesDoc.data();
                console.log('[Client] Raw strategies from DB:', Object.keys(allStrategies));

                // Filter: Show ONLY published strategies
                // Presets (all, winrate_80, italia, top_eu, cups, best_05_ht) are ALWAYS shown
                // Custom strategies need to check if they're published

                const presetIds = ['all', 'winrate_80', 'italia', 'top_eu', 'cups', 'best_05_ht'];
                strategiesData = {};

                for (const [stratId, stratData] of Object.entries(allStrategies)) {
                    // Skip if no name or no matches data
                    if (!stratData.name || !stratData.matches) {
                        console.warn(`[Client] Skipping ${stratId} - missing data`);
                        continue;
                    }

                    // Always include presets
                    if (presetIds.includes(stratId)) {
                        strategiesData[stratId] = stratData;
                        continue;
                    }

                    // For custom strategies, check if published
                    // (Custom strategies that are saved via Admin "Salva" button are automatically here)
                    // We include all non-preset strategies found in strategy_results
                    strategiesData[stratId] = stratData;
                }

                console.log('[Client] Filtered published strategies:', Object.keys(strategiesData));

                renderStats();
                renderStrategies();

                // Load user selected matches
                const userMatchesDoc = await getDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"));
                if (userMatchesDoc.exists()) {
                    selectedMatches = userMatchesDoc.data().matches || [];
                    console.log('[Client] Loaded selected matches:', selectedMatches.length);
                    updateMyMatchesCount(); // Initialize badge
                } else {
                    console.log('[Client] No selected matches found');
                }
            } catch (e) {
                console.error('[Client] Critical error loading data:', e);
            }
        }

        // Render Stats
        async function renderStats() {
            try {
                // Query all matches with results
                const matchesQuery = query(collection(db, "matches"), where("risultato", "!=", ""));
                const snapshot = await getDocs(matchesQuery);

                let total = 0;
                let wins = 0;
                let losses = 0;
                let lastDate = '';

                snapshot.forEach(doc => {
                    const m = doc.data();
                    total++;
                    if (m.esito === 'Vinto') wins++;
                    if (m.esito === 'Perso') losses++;
                    if (m.data > lastDate) lastDate = m.data;
                });

                const winrate = total > 0 ? ((wins / total) * 100).toFixed(1) : 0;

                // Update Global Stats for AI
                globalStats = { total, wins, losses, winrate };

                // Calculate next day for "new predictions"
                const nextDay = getNextDay(lastDate);

                document.getElementById('stat-total').textContent = total;
                document.getElementById('stat-wins').textContent = wins;
                document.getElementById('stat-losses').textContent = losses;
                document.getElementById('stat-winrate').textContent = winrate + '%';
                document.getElementById('last-update').textContent = formatDateLong(nextDay);
            } catch (e) {
                console.error('Error calculating stats:', e);
            }
        }

        // Get next day
        function getNextDay(dateString) {
            const date = new Date(dateString);
            date.setDate(date.getDate() + 1);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Format date in Italian long format
        function formatDateLong(dateString) {
            if (!dateString) return '';
            const months = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
                'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
            const [year, month, day] = dateString.split('-');
            return `${parseInt(day)} ${months[parseInt(month) - 1]} ${year}`;
        }

        // Render Strategies
        function renderStrategies() {
            const container = document.getElementById('strategies-grid');
            container.innerHTML = '';

            // Strategy descriptions
            const descriptions = {
                all: 'Tutte le partite pronosticate',
                winrate_80: 'Solo leghe con winrate superiore all\'80%',
                italia: 'Tutte le partite dei campionati Italiani',
                top_eu: 'Principali campionati europei (Premier, Liga, Bundesliga, Ligue 1, Serie A)',
                cups: 'Competizioni europee (Champions, Europa, Conference League)',
                best_05_ht: 'Partite Over 0.5 HT selezionate al 70%+',
                magic_ai: 'La magia dell\'AI con le sue scelte misteriose ü™Ñ'
            };

            Object.keys(strategiesData).forEach(stratId => {
                const strat = strategiesData[stratId];

                // Safety checks
                if (!strat || !strat.name) {
                    console.warn(`[Client] Skipping ${stratId} - invalid data`);
                    return;
                }

                const isMagicAI = stratId.toLowerCase().includes('magic') || (strat.name && strat.name.toLowerCase().includes('magic'));
                const card = document.createElement('button');
                card.className = `strategy-btn ${isMagicAI ? 'magic-ai' : ''} text-white rounded-xl p-6 shadow-lg transform hover:scale-105 transition`;

                const description = descriptions[stratId] || descriptions['magic_ai'] || 'Strategia personalizzata';

                card.innerHTML = `
                    <div class="strategy-info">?</div>
                    <div class="text-3xl mb-2">${getStrategyIcon(stratId, isMagicAI)}</div>
                    <div class="font-bold text-sm mb-1">${strat.name}</div>
                    <div class="text-xs opacity-80">${strat.totalMatches} partite</div>
                `;

                // Info button click
                const infoBtn = card.querySelector('.strategy-info');
                infoBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    alert(`${strat.name}\n\n${description}`);
                });

                card.addEventListener('click', () => showRanking(stratId, strat));
                container.appendChild(card);
            });
        }

        // Show Ranking
        function showRanking(stratId, strat, sortMode = 'score') {
            currentStrategyId = stratId;
            currentSortMode = sortMode;

            document.getElementById('strategy-title').textContent = strat.name;
            const container = document.getElementById('matches-container');
            container.innerHTML = '';

            if (strat.matches.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-300 py-12">Nessuna partita per questa strategia</div>';
            } else {
                // Clone and sort matches
                let sortedMatches = [...strat.matches];

                if (sortMode === 'time') {
                    // Sort by time (matches without time go last)
                    sortedMatches.sort((a, b) => {
                        if (!a.ora && !b.ora) return 0;
                        if (!a.ora) return 1;
                        if (!b.ora) return -1;
                        return a.ora.localeCompare(b.ora);
                    });

                    // Group by time and render with time headers
                    let currentTime = null;
                    let matchIndex = 0;

                    sortedMatches.forEach((m) => {
                        // Add time header if changed
                        if (m.ora && m.ora !== currentTime) {
                            currentTime = m.ora;
                            const timeHeader = document.createElement('div');
                            timeHeader.className = 'flex items-center gap-2 my-4 pt-4 border-t border-white/20';
                            timeHeader.innerHTML = `
                                <div class="text-2xl">üïê</div>
                                <div class="text-xl font-bold">${currentTime}</div>
                                <div class="text-sm text-gray-400 ml-auto">${countMatchesAtTime(sortedMatches, currentTime)} partite</div>
                            `;
                            container.appendChild(timeHeader);
                        }

                        const card = createMatchCard(m, matchIndex, stratId, false); // false = hide time in card
                        container.appendChild(card);
                        matchIndex++;
                    });
                } else {
                    // Render by score (no time headers)
                    sortedMatches.forEach((m, idx) => {
                        const card = createMatchCard(m, idx, stratId, true); // true = show time in card if available
                        container.appendChild(card);
                    });
                }
            }

            // Update button states
            updateSortButtons(sortMode);

            showPage('ranking');
        }

        // Helper: count matches at specific time
        function countMatchesAtTime(matches, time) {
            return matches.filter(m => m.ora === time).length;
        }

        // Update sort button visual states
        function updateSortButtons(activeMode) {
            const scoreBtn = document.getElementById('sort-by-score');
            const timeBtn = document.getElementById('sort-by-time');

            if (activeMode === 'score') {
                scoreBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
            } else {
                scoreBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
            }
        }

        // Create Match Card
        function createMatchCard(match, index, stratId, showTimeInCard = true) {
            const matchId = `${match.data}_${match.partita}`;
            const isFlagged = selectedMatches.some(sm => sm.id === matchId);

            const card = document.createElement('div');
            card.className = 'match-card rounded-xl p-5 shadow-lg fade-in';

            const indicationHTML = match.indication ? `
                <div class="${match.indication.bg} ${match.indication.color} px-4 py-2 rounded-xl text-center font-bold text-sm mb-3">
                    ${match.indication.text}
                </div>
            ` : '';

            const betfairHTML = match.betfairBadge ? `
                <div class="text-xs ${match.betfairBadge.color} mt-2 font-semibold">${match.betfairBadge.text}</div>
            ` : '';

            // HT Info section (when available and significant)
            const htHTML = match.info_ht && match.info_ht.trim() !== '' ? `
                <div class="mt-3 bg-purple-500/20 border border-purple-400/30 rounded-lg p-3">
                    <div class="text-xs font-bold text-purple-200 mb-1">üìä Primo Tempo (0.5 PT)</div>
                    <div class="text-sm text-purple-100">
                        Probabilit√†: <span class="font-black">${match.info_ht}</span>
                    </div>
                </div>
            ` : '';

            // Generate explanatory text for team stats
            const getStatsExplanation = (stats, isHome, tip) => {
                if (!stats || stats.total === 0) return '';

                const location = isHome ? 'casa' : 'trasferta';
                const tipDisplay = tip || match.tip;

                // Determine what the stats represent based on tip type
                let explanation = '';
                if (tipDisplay.startsWith('+')) {
                    // Over tip
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite, ha avuto esito <strong>${tipDisplay}</strong> in <strong>${stats.count}</strong> casi`;
                } else if (tipDisplay.startsWith('-')) {
                    // Under tip
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite, ha avuto esito <strong>${tipDisplay}</strong> in <strong>${stats.count}</strong> casi`;
                } else {
                    // 1X2 / DC
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite ${location}, esito favorevole in <strong>${stats.count}</strong> casi`;
                }

                return explanation;
            };

            const statsHTML = match.teamStats && match.teamStats.home && match.teamStats.away ? `
                <div class="mt-4 pt-4 border-t border-white/20">
                    <div class="text-xs font-bold mb-3 opacity-80">üìä Statistiche Squadre:</div>
                    <div class="space-y-3 text-xs">
                        <div class="bg-white/10 p-3 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <div class="font-semibold text-sm">üè† Casa</div>
                                <div class="text-${match.teamStats.home.color === 'green' ? 'green' : 'yellow'}-400 font-black text-lg">
                                    ${match.teamStats.home.percentage}%
                                </div>
                            </div>
                            <div class="text-gray-300 text-xs leading-relaxed">
                                ${getStatsExplanation(match.teamStats.home, true, match.tip)}
                            </div>
                        </div>
                        <div class="bg-white/10 p-3 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <div class="font-semibold text-sm">‚úàÔ∏è Trasferta</div>
                                <div class="text-${match.teamStats.away.color === 'green' ? 'green' : 'yellow'}-400 font-black text-lg">
                                    ${match.teamStats.away.percentage}%
                                </div>
                            </div>
                            <div class="text-gray-300 text-xs leading-relaxed">
                                ${getStatsExplanation(match.teamStats.away, false, match.tip)}
                            </div>
                        </div>
                    </div>
                </div>
            ` : '';

            card.innerHTML = `
                <div class="flex items-center justify-between mb-3">
                    <span class="text-3xl font-black text-purple-300">#${index + 1}</span>
                    <button class="flag-btn ${isFlagged ? 'flagged' : ''} text-2xl" data-match-id="${matchId}">
                        <i class="fa-${isFlagged ? 'solid' : 'regular'} fa-star"></i>
                    </button>
                    <span class="score-badge text-white px-4 py-2 rounded-full text-xl font-black">${match.score}</span>
                </div>
                
                ${showTimeInCard && match.ora ? `<div class="text-sm text-yellow-300 mb-2">üïê ${match.ora}</div>` : ''}
                
                <div class="text-2xl font-bold mb-2">${match.partita}</div>
                <div class="text-sm opacity-80 mb-3">${match.lega}</div>
                
                <div class="bg-white/10 rounded-lg p-3 mb-3">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-xs text-gray-300 mb-1">Tip Principale</div>
                            <div class="text-xl font-black text-blue-300">${match.tip} <span class="text-white">@${match.quota}</span></div>
                        </div>
                        <div class="text-right">
                            <div class="text-xs text-gray-300 mb-1">Probabilit√†</div>
                            <div class="text-lg font-bold text-white">${match.probabilita}%</div>
                        </div>
                    </div>
                </div>
                
                ${indicationHTML}
                ${htHTML}
                ${betfairHTML}
                ${statsHTML}
            `;

            // Flag button logic
            const flagBtn = card.querySelector('.flag-btn');
            flagBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFlag(matchId, match, stratId, flagBtn);
            });

            return card;
        }

        // Toggle Flag
        async function toggleFlag(matchId, match, stratId, btn) {
            const index = selectedMatches.findIndex(sm => sm.id === matchId);

            if (index >= 0) {
                // Remove
                selectedMatches.splice(index, 1);
                btn.classList.remove('flagged');
                btn.innerHTML = '<i class="fa-regular fa-star"></i>';
            } else {
                // Add
                selectedMatches.push({
                    id: matchId,
                    strategy: strategiesData[stratId].name,
                    ...match
                });
                btn.classList.add('flagged');
                btn.innerHTML = '<i class="fa-solid fa-star"></i>';
            }

            // Save to Firebase
            try {
                await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                    matches: selectedMatches,
                    updated: Date.now()
                });
            } catch (e) {
                console.error('Error saving selection:', e);
            }

            // Update My Matches count
            updateMyMatchesCount();
        }

        // Show My Matches
        function showMyMatches(sortMode = 'score') {
            const container = document.getElementById('my-matches-container');
            container.innerHTML = '';

            if (selectedMatches.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-300 py-12">Nessuna partita selezionata</div>';
                console.log('[Client] No matches to show');
            } else {
                console.log('[Client] Rendering', selectedMatches.length, 'matches');

                // Clone and sort
                let sortedMatches = [...selectedMatches];

                if (sortMode === 'time') {
                    // Sort by time
                    sortedMatches.sort((a, b) => {
                        if (!a.ora && !b.ora) return 0;
                        if (!a.ora) return 1;
                        if (!b.ora) return -1;
                        return a.ora.localeCompare(b.ora);
                    });

                    // Render with time headers
                    let currentTime = null;
                    let matchIndex = 0;

                    sortedMatches.forEach((m) => {
                        // Add time header if changed
                        if (m.ora && m.ora !== currentTime) {
                            currentTime = m.ora;
                            const timeHeader = document.createElement('div');
                            timeHeader.className = 'flex items-center gap-2 my-4 pt-4 border-t border-white/20';
                            timeHeader.innerHTML = `
                                <div class="text-2xl">üïê</div>
                                <div class="text-xl font-bold">${currentTime}</div>
                                <div class="text-sm text-gray-400 ml-auto">${sortedMatches.filter(x => x.ora === currentTime).length} partite</div>
                            `;
                            container.appendChild(timeHeader);
                        }

                        try {
                            const card = createMatchCard(m, matchIndex, null, false);
                            const flagBtn = card.querySelector('.flag-btn');
                            if (flagBtn) flagBtn.remove();
                            container.appendChild(card);
                        } catch (e) {
                            console.error('[Client] Error creating match card:', e, m);
                        }
                        matchIndex++;
                    });
                } else {
                    // Sort by score (default)
                    sortedMatches.sort((a, b) => (b.score || 0) - (a.score || 0));

                    sortedMatches.forEach((m, idx) => {
                        try {
                            const card = createMatchCard(m, idx, null, true);
                            const flagBtn = card.querySelector('.flag-btn');
                            if (flagBtn) flagBtn.remove();
                            container.appendChild(card);
                        } catch (e) {
                            console.error('[Client] Error creating match card:', e, m);
                        }
                    });
                }
            }

            // Update button states
            updateMyMatchesSortButtons(sortMode);
            // DON'T call showPage here - it's already called by the navigation button!
        }

        // Update My Matches sort button states
        function updateMyMatchesSortButtons(activeMode) {
            const scoreBtn = document.getElementById('my-matches-sort-score');
            const timeBtn = document.getElementById('my-matches-sort-time');

            if (activeMode === 'score') {
                scoreBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
            } else {
                scoreBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
            }
        }

        // Update My Matches Count
        function updateMyMatchesCount() {
            const navBtn = document.querySelector('[data-page="my-matches"]');
            const countBadge = navBtn.querySelector('.count-badge');

            if (selectedMatches.length > 0) {
                if (!countBadge) {
                    const badge = document.createElement('span');
                    badge.className = 'count-badge absolute top-0 right-0 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center font-bold';
                    badge.textContent = selectedMatches.length;
                    navBtn.style.position = 'relative';
                    navBtn.appendChild(badge);
                } else {
                    countBadge.textContent = selectedMatches.length;
                }
            } else if (countBadge) {
                countBadge.remove();
            }
        }

        // Navigation
        function showPage(pageName) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));

            if (pageName === 'strategies') {
                document.getElementById('page-strategies').classList.add('active');
            } else if (pageName === 'ranking') {
                document.getElementById('page-ranking').classList.add('active');
            } else if (pageName === 'my-matches') {
                showMyMatches();
                document.getElementById('page-my-matches').classList.add('active');
            }

            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if (btn.dataset.page === pageName) {
                    btn.classList.remove('text-gray-400');
                    btn.classList.add('text-purple-400');
                } else {
                    btn.classList.remove('text-purple-400');
                    btn.classList.add('text-gray-400');
                }
            });
        }

        // Event Listeners
        document.getElementById('back-to-strategies').addEventListener('click', () => showPage('strategies'));

        // Sort buttons
        document.getElementById('sort-by-score').addEventListener('click', () => {
            if (currentStrategyId && strategiesData[currentStrategyId]) {
                showRanking(currentStrategyId, strategiesData[currentStrategyId], 'score');
            }
        });

        document.getElementById('sort-by-time').addEventListener('click', () => {
            if (currentStrategyId && strategiesData[currentStrategyId]) {
                showRanking(currentStrategyId, strategiesData[currentStrategyId], 'time');
            }
        });

        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => showPage(btn.dataset.page));
        });

        // Delete all matches button
        document.getElementById('delete-all-matches-btn').addEventListener('click', async () => {
            if (selectedMatches.length === 0) {
                alert('Nessuna partita da cancellare');
                return;
            }

            if (!confirm(`Vuoi cancellare tutte le ${selectedMatches.length} partite salvate?\n\nQuesta azione √® irreversibile.`)) {
                return;
            }

            try {
                // Clear all matches
                selectedMatches = [];

                // Save to Firebase
                await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                    matches: [],
                    updated: Date.now()
                });

                // Update UI
                updateMyMatchesCount();
                showMyMatches();

                alert('‚úÖ Tutte le partite sono state cancellate');
            } catch (e) {
                console.error('[Delete All] Error:', e);
                alert('Errore durante la cancellazione');
            }
        });

        // My Matches sort buttons
        document.getElementById('my-matches-sort-score').addEventListener('click', () => {
            showMyMatches('score');
        });

        document.getElementById('my-matches-sort-time').addEventListener('click', () => {
            showMyMatches('time');
        });

        // Strategy Icons
        function getStrategyIcon(stratId, isMagicAI = false) {
            if (isMagicAI) return 'ü™Ñ';

            const icons = {
                all: 'üìä',
                winrate_80: 'üî•',
                italia: 'üáÆüáπ',
                top_eu: 'üåç',
                cups: 'üèÜ',
                best_05_ht: '‚ö°'
            };
            return icons[stratId] || 'üéØ';
        }
    </script>
</body>

<!-- AI CHATBOT WIDGET -->
<div id="ai-chat-widget" class="fixed bottom-6 right-6 z-50 flex flex-col items-end font-sans">
    <!-- Chat Window -->
    <div id="ai-chat-window"
        class="hidden bg-white w-80 h-96 rounded-2xl shadow-2xl border border-gray-200 flex flex-col mb-4 overflow-hidden transition-all transform origin-bottom-right">
        <!-- Header -->
        <div class="bg-gradient-to-r from-purple-600 to-blue-600 p-4 flex justify-between items-center text-white">
            <div class="flex items-center gap-2">
                <i class="fa-solid fa-robot"></i>
                <span class="font-bold text-sm">Antigravity AI</span>
            </div>
            <button id="close-chat-btn" class="hover:text-gray-200 transition">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>

        <!-- Messages Area -->
        <div id="chat-messages" class="flex-1 p-4 overflow-y-auto bg-gray-50 space-y-3 text-sm">
            <!-- Welcome Message -->
            <div class="flex justify-start">
                <div class="bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm max-w-[85%]">
                    <p class="text-gray-800">Ciao! üëã Sono l'assistente AI di Antigravity. Chiedimi pure come funzionano
                        le strategie o come gestire le tue partite!</p>
                </div>
            </div>
        </div>

        <!-- Input Area -->
        <div class="p-3 bg-white border-t border-gray-100">
            <form id="chat-form" class="flex gap-2">
                <input type="text" id="chat-input" placeholder="Scrivi una domanda..."
                    class="flex-1 p-2 border border-gray-300 rounded-lg text-sm text-gray-900 bg-white focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500">
                <button type="submit"
                    class="bg-purple-600 text-white p-2 rounded-lg hover:bg-purple-700 transition shadow-sm disabled:opacity-50">
                    <i class="fa-solid fa-paper-plane"></i>
                </button>
            </form>
        </div>
    </div>

    <!-- Toggle Button -->
    <button id="toggle-chat-btn"
        class="bg-gradient-to-r from-purple-600 to-blue-600 text-white w-14 h-14 rounded-full shadow-lg hover:shadow-xl transition transform hover:scale-105 flex items-center justify-center text-2xl">
        <i class="fa-solid fa-comment-dots"></i>
    </button>
</div>

<!-- AI Chatbot Logic -->
<script>
    // CONFIGURATION
    const GEMINI_API_KEY = "AIzaSyCmwIWnqiPa7g28LqmbfwhQwVkFIgOorJE"; // ‚ö†Ô∏è Replace with User's Key
    const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";

    // UI Elements
    const widget = document.getElementById('ai-chat-widget');
    const chatWindow = document.getElementById('ai-chat-window');
    const toggleBtn = document.getElementById('toggle-chat-btn');
    const closeBtn = document.getElementById('close-chat-btn');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('chat-input');
    const messagesContainer = document.getElementById('chat-messages');
    const chatHeaderTitle = chatWindow.querySelector('.font-bold');

    // Update Name
    chatHeaderTitle.textContent = "Aiuto Online di TipsterAI";

    // State
    let isOpen = false;
    let chatHistory = [];

    // Helper: Get User Name
    function getUserName() {
        if (currentUser && currentUser.email) {
            // Extract name from email (e.g., "mario" from "mario@gmail.com")
            const name = currentUser.email.split('@')[0];
            return name.charAt(0).toUpperCase() + name.slice(1);
        }
        return "Amico";
    }

    // Helper: Build Dynamic System Prompt
    function buildSystemPrompt() {
        const userName = getUserName();

        // Get Strategies from Global Scope
        let strategiesText = "";
        if (typeof strategiesData !== 'undefined' && strategiesData) {
            strategiesText = Object.values(strategiesData)
                .map(s => `- **${s.name}**: ${s.description || 'Strategia automatica basata su statistiche.'} (${s.totalMatches || 0} partite attive)`)
                .join('\n');
        } else {
            strategiesText = "- Nessuna strategia caricata al momento.";
        }

        return `
Sei **TipsterAI**, l'intelligenza artificiale ufficiale dell'app.
Parla al plurale o in terza persona come se fossi il team di esperti (es. "Noi di TipsterAI", "Gli esperti di TipsterAI", "La magia di TipsterAI").
Il tuo interlocutore si chiama **${userName}**.
Usa il suo nome ogni tanto, ma non iniziare ogni frase con "Ciao". Sii vario e naturale.

**I NOSTRI NUMERI STRAORDINARI:**
Abbiamo analizzato **${globalStats.total}** partite totali.
Vittorie: **${globalStats.wins}** üèÜ
Sconfitte: **${globalStats.losses}**
Winrate Attuale: **${globalStats.winrate}%** üî•
Usa questi numeri per vantarti dei risultati quando opportuno!

**LA TUA MISSIONE:**
Il nostro compito √® aiutare l'utente a selezionare, tra tutte le partite che si giocano oggi, quelle con la pi√π alta percentuale di successo.
Analizziamo migliaia di partite per offrire le migliori opportunit√†.
L'utente deve scegliere quale strategia utilizzare tra quelle proposte, e noi forniamo le partite pronte con tutte le informazioni per giocare nel bookmaker preferito.
Ricorda sempre di promuovere il **gioco responsabile**: il betting deve essere un divertimento, non una fonte di reddito garantita.

**COME RISPONDERE A "COME FUNZIONA?":**
Se l'utente chiede come funziona, rispondi con enfasi:
"Il nostro compito √® analizzare migliaia di partite ogni giorno per trovare quelle con la pi√π alta probabilit√† di successo. Tu devi solo scegliere una delle nostre strategie vincenti (come Magia AI o Winrate 80%) e noi ti mostriamo le migliori opportunit√† pronte da giocare. Semplice, veloce e basato sui dati!"

**STRATEGIE ATTIVE OGGI:**
${strategiesText}

**ELEMENTI APP:**
1. **Mie Partite**: L'utente pu√≤ salvare le partite preferite (stella ‚≠ê).
2. **Badge Rossi**: Indicano le "Partite Calde" o le opportunit√† attive per quella strategia. Pi√π alto √® il numero, pi√π occasioni ci sono!
3. **Filtri**: Si possono ordinare le partite per Ranking üìä (migliori prima) o Orario üïê.

**TONO DI VOCE:**
- Professionale ma amichevole ed entusiasta.
- Usa emoji calcistiche e "magic" (‚öΩ, ü™Ñ, üî•, üìä).
- Risposte concise (max 3-4 righe) ma complete.
`;
    }

    // Toggle Chat
    function toggleChat() {
        isOpen = !isOpen;
        if (isOpen) {
            chatWindow.classList.remove('hidden');
            toggleBtn.classList.add('hidden');
            setTimeout(() => input.focus(), 100);
        } else {
            chatWindow.classList.add('hidden');
            toggleBtn.classList.remove('hidden');
        }
    }

    toggleBtn.addEventListener('click', toggleChat);
    closeBtn.addEventListener('click', toggleChat);

    // Append Message to UI
    function appendMessage(text, sender) {
        const div = document.createElement('div');
        div.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

        const bubble = document.createElement('div');
        bubble.className = sender === 'user'
            ? 'bg-purple-600 text-white rounded-2xl rounded-tr-none p-3 shadow-sm max-w-[85%]'
            : 'bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm max-w-[85%] text-gray-800';

        bubble.innerHTML = text;
        div.appendChild(bubble);
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Show Loading
    function showLoading() {
        const div = document.createElement('div');
        div.id = 'ai-loading';
        div.className = 'flex justify-start';
        div.innerHTML = `
                <div class="bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm">
                    <div class="flex gap-1">
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.4s"></div>
                    </div>
                </div>`;
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function removeLoading() {
        const loading = document.getElementById('ai-loading');
        if (loading) loading.remove();
    }

    // Handle Submit
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const text = input.value.trim();
        if (!text) return;

        // UI Updates
        input.value = '';
        appendMessage(text, 'user');
        showLoading();

        try {
            // Generate Dynamic Prompt
            const currentSystemPrompt = buildSystemPrompt();

            // Prepare History
            const contents = [
                {
                    role: "user",
                    parts: [{ text: currentSystemPrompt + "\n\nDomanda Utente: " + text }]
                }
            ];

            // Call Gemini API (REST)
            const response = await fetch(`${API_URL}?key=${GEMINI_API_KEY}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    contents: contents
                })
            });

            const data = await response.json();

            if (!response.ok) {
                // Handle specific error for leaked key
                if (data.error && data.error.message && data.error.message.includes("API key not valid")) {
                    throw new Error("API Key non valida o revocata da Google.");
                }
                throw new Error(data.error?.message || "Errore API");
            }

            const markdownText = data.candidates[0].content.parts[0].text;

            // Simple Markdown to HTML
            const htmlText = markdownText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            removeLoading();
            appendMessage(htmlText, 'ai');

        } catch (error) {
            console.error("AI Error Details:", error);
            removeLoading();
            appendMessage(`‚ö†Ô∏è <strong>Errore Tecnico:</strong> ${error.message}<br><br>Se vedi "API Key leaked", devi rigenerare la chiave su Google AI Studio.`, 'ai');
        }
    });
</script>
</body>

</html>