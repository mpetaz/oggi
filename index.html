<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-50">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tipster-AI</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css" rel="stylesheet">
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .noUi-connect {
            background: #3b82f6;
        }

        .noUi-handle {
            border-radius: 9999px;
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        .tip-button.active {
            background-color: #3b82f6;
            color: white;
            border-color: #3b82f6;
            font-weight: 600;
        }

        .sortable-header {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .sortable-header:hover {
            background-color: #e5e7eb;
        }

        .sort-icon {
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .sortable-header.active .sort-icon {
            opacity: 1;
            color: #3b82f6;
        }

        .favorite-star {
            cursor: pointer;
            color: #d1d5db;
            transition: color 0.2s, transform 0.2s;
        }

        .favorite-star.is-favorite {
            color: #f59e0b;
        }

        .favorite-star:hover {
            transform: scale(1.2);
        }

        .team-green {
            color: #10b981;
            font-weight: 600;
        }

        .team-yellow {
            color: #f59e0b;
            font-weight: 600;
        }

        .team-red {
            color: #ef4444;
            font-weight: 600;
        }

        .team-gray {
            color: #9ca3af;
            font-weight: 500;
        }

        .team-black {
            color: #374151;
        }

        .score-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: bold;
        }

        .ht-badge-high {
            background-color: #10b981;
            color: white;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .ht-badge-medium {
            background-color: #f59e0b;
            color: white;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .ht-badge-low {
            background-color: #9ca3af;
            color: white;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .ht-badge-none {
            color: #d1d5db;
            font-size: 0.7rem;
        }
    </style>
</head>

<body class="h-full text-gray-800">
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-90 flex items-center justify-center z-50">
        <div id="login-container" class="bg-white p-8 rounded-2xl shadow-2xl max-w-md w-full hidden">
            <div class="text-center mb-6">
                <img src="logo.png" alt="Tipster-AI Logo" class="h-16 w-16 mx-auto mb-2 rounded-lg">
                <h2 class="text-2xl font-bold text-gray-900">Tipster-AI</h2>
                <p class="text-gray-500">Accedi per visualizzare i pronostici</p>
            </div>
            <form id="login-form" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="email"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" required>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="password"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" required>
                </div>
                <div class="text-right mb-2">
                    <a href="#" id="forgot-password-link" class="text-sm text-blue-600 hover:underline">Password
                        dimenticata?</a>
                </div>
                <div id="login-error" class="text-red-500 text-sm hidden mb-2"></div>
                <button type="submit" id="login-btn"
                    class="w-full bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700 transition-colors">Accedi</button>

                <div class="mt-4 text-center text-sm text-gray-600">
                    <span id="auth-mode-text">Non hai un account?</span>
                    <a href="#" id="toggle-auth-mode" class="text-blue-600 font-semibold hover:underline">Registrati</a>
                </div>
            </form>
        </div>
        <div id="loading-container" class="text-center max-w-md px-4">
            <div id="loading-spinner" class="text-white text-xl font-semibold animate-pulse mb-2">Inizializzazione...
            </div>
            <div id="auth-status"
                class="text-blue-200 text-sm font-mono bg-gray-800 p-2 rounded border border-gray-700">Attesa
                connessione...</div>
        </div>
    </div>

    <div class="min-h-full flex flex-col">
        <!-- Header -->
        <header class="bg-white shadow-sm sticky top-0 z-50">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between h-16">
                    <div class="flex items-center">
                        <img src="logo.png" alt="Tipster-AI Logo" class="h-10 w-10 mr-3 rounded-lg">
                        <h1 class="text-2xl font-bold text-gray-900">Tipster-AI</h1>
                    </div>
                    <div class="flex items-center space-x-4 flex-wrap hidden md:flex">
                        <button data-page="page-dashboard"
                            class="nav-button bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold shadow-sm hover:bg-blue-700 transition-colors text-sm">
                            <i class="fa-solid fa-chart-bar mr-1"></i>Dashboard
                        </button>
                        <button data-page="page-ranking"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-trophy mr-1"></i>Ranking
                        </button>
                        <div class="flex items-center gap-2 ml-4 border-l pl-4 border-gray-300">
                            <div id="user-info-display" class="hidden text-sm font-medium text-gray-700"></div>
                            <button id="profile-btn"
                                class="hidden bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg transition-colors flex items-center gap-2 text-sm font-semibold">
                                <i class="fa-solid fa-user"></i>
                                <span>Profilo</span>
                            </button>
                        </div>
                        </nav>
                    </div>
                </div>
        </header>

        <!-- Main Content -->
        <main class="flex-grow pb-20 md:pb-0">

            <!-- PAGINA DASHBOARD -->
            <div id="page-dashboard" class="page active max-w-7xl mx-auto px-2 sm:px-6 lg:px-8 py-4 md:py-8">
                <!-- Sticky Stats -->
                <div id="stats-container"
                    class="sticky top-16 md:top-0 z-40 bg-gray-50/95 backdrop-blur-sm py-2 md:py-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-2 md:gap-4 mb-4 md:mb-8 shadow-sm md:shadow-none border-b md:border-none border-gray-200 px-2 md:px-0 -mx-2 md:mx-0">
                </div>

                <!-- MODALE PROFILO -->
                <div id="profile-modal"
                    class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
                    <div class="bg-white rounded-xl p-6 w-full max-w-md shadow-2xl transform transition-all">
                        <div class="flex justify-between items-center mb-6">
                            <h3 class="text-xl font-bold text-gray-800">Profilo Utente</h3>
                            <button id="close-profile-modal" class="text-gray-500 hover:text-gray-700">
                                <i class="fa-solid fa-times text-xl"></i>
                            </button>
                        </div>

                        <div class="space-y-4">
                            <!-- Info -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Email</label>
                                <input type="text" id="profile-email" disabled
                                    class="w-full p-2 bg-gray-100 border rounded text-gray-600">
                            </div>

                            <!-- Alias -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Alias (Nome
                                    Visualizzato)</label>
                                <div class="flex gap-2">
                                    <input type="text" id="profile-alias" placeholder="Il tuo nome..."
                                        class="w-full p-2 border rounded focus:ring-2 focus:ring-blue-500 outline-none">
                                    <button id="save-alias-btn"
                                        class="bg-blue-600 text-white px-4 rounded hover:bg-blue-700">Salva</button>
                                </div>
                            </div>

                            <hr class="my-4 border-gray-200">

                            <!-- Cambio Password -->
                            <div>
                                <h4 class="font-semibold text-gray-800 mb-2">Cambia Password</h4>
                                <input type="password" id="new-password" placeholder="Nuova Password (min 6 car.)"
                                    class="w-full p-2 border rounded mb-2 focus:ring-2 focus:ring-blue-500 outline-none">
                                <button id="change-password-btn"
                                    class="w-full bg-gray-800 text-white py-2 rounded hover:bg-gray-900">Aggiorna
                                    Password</button>
                            </div>

                            <hr class="my-4 border-gray-200">

                            <!-- Logout -->
                            <button id="modal-logout-btn"
                                class="w-full bg-red-500 text-white py-3 rounded-lg font-bold hover:bg-red-600 transition-colors flex items-center justify-center gap-2">
                                <i class="fa-solid fa-right-from-bracket"></i> Disconnettiti
                            </button>
                        </div>
                    </div>
                </div>

                <!-- FIREBASE SDK -->
                <!-- Filters -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-8">
                    <div class="flex flex-col md:flex-row gap-4 mb-4 items-center">
                        <div class="relative w-full md:w-64 hidden"> <!-- Search moved below -->
                            <input type="text" id="search-input-hidden" placeholder="Cerca lega o squadra..."
                                class="w-full pl-10 pr-4 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                            <i
                                class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        </div>
                        <div class="flex items-center gap-2 w-full md:w-auto">
                            <label class="text-sm font-medium text-gray-700">Periodo:</label>
                            <input type="date" id="filter-date-start" class="p-2 border rounded-lg">
                            <input type="date" id="filter-date-end" class="p-2 border rounded-lg">
                        </div>
                    </div>

                    <!-- Saved Filters Section -->
                    <div class="border-t border-b border-gray-200 my-4 py-4">
                        <h4 class="text-sm font-medium text-gray-700 mb-2">Filtri Personalizzati</h4>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                            <div>
                                <label for="saved-filters-select" class="block text-xs font-medium text-gray-600">Carica
                                    una strategia</label>
                                <div class="flex gap-2">
                                    <select id="saved-filters-select"
                                        class="w-full p-2 border rounded-lg text-sm bg-gray-50">
                                        <option value="">Seleziona...</option>
                                    </select>
                                    <button id="load-filter-btn"
                                        class="bg-blue-600 text-white px-3 py-2 rounded-lg font-semibold text-sm w-full">Carica</button>
                                    <button id="delete-filter-btn"
                                        class="bg-red-500 text-white px-3 py-2 rounded-lg font-semibold text-sm hover:bg-red-600"
                                        title="Elimina Strategia Selezionata">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div>
                                <label for="new-filter-name" class="block text-xs font-medium text-gray-600">Salva
                                    strategia attuale</label>
                                <input type="text" id="new-filter-name" placeholder="Nome della strategia..."
                                    class="w-full p-2 border rounded-lg text-sm">
                            </div>
                            <div class="flex gap-2">
                                <button id="save-filter-btn"
                                    class="flex-1 bg-green-600 text-white px-4 py-2 rounded-lg font-semibold text-sm hover:bg-green-700">
                                    <i class="fa-solid fa-save mr-1"></i>Salva Strategia
                                </button>
                                <button id="reset-filters-btn"
                                    class="bg-gray-500 text-white px-3 py-2 rounded-lg text-sm hover:bg-gray-600">
                                    <i class="fa-solid fa-arrows-rotate"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <!-- LEFT COLUMN: Leagues -->
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <label class="block text-sm font-medium text-gray-700">Leghe</label>
                                <div>
                                    <button id="top-leagues-btn"
                                        class="text-xs text-purple-600 hover:underline font-bold mr-4">‚ö° Leghe >
                                        80%</button>
                                    <button id="update-favorites-btn"
                                        class="text-xs text-green-600 hover:underline font-semibold mr-2">Salva
                                        Preferiti</button>
                                    <button id="reset-leagues-btn"
                                        class="text-xs text-blue-600 hover:underline font-semibold">Azzera
                                        Leghe</button>
                                </div>
                            </div>
                            <div id="league-filters-grid" class="grid grid-cols-1 sm:grid-cols-2 gap-2"></div>
                        </div>

                        <!-- RIGHT COLUMN: Sliders & Tips -->
                        <div class="space-y-4">
                            <!-- Probabilit√† Slider + Inputs -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Probabilit√† (%)</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="prob-min-input" min="0" max="100" value="0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                    <div class="flex-1">
                                        <div id="probability-slider" class="mx-2"></div>
                                    </div>
                                    <input type="number" id="prob-max-input" min="0" max="100" value="100"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                </div>
                            </div>

                            <!-- Quota Slider + Inputs -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Quota</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="odds-min-input" min="1.0" max="10.0" step="0.01"
                                        value="1.0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                    <div class="flex-1">
                                        <div id="odds-slider" class="mx-2"></div>
                                    </div>
                                    <input type="number" id="odds-max-input" min="1.0" max="10.0" step="0.01"
                                        value="10.0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                </div>
                            </div>

                            <!-- Tips -->
                            <div class="pt-2">
                                <div class="flex justify-between items-center mb-1">
                                    <label class="block text-sm font-medium text-gray-700">Tips</label>
                                    <button id="reset-tips-btn"
                                        class="text-xs text-blue-600 hover:underline font-semibold">Azzera Tips</button>
                                </div>
                                <div id="tip-filters-container"
                                    class="w-full p-2 border rounded-lg bg-gray-50 flex flex-wrap gap-2"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Match List -->
                <div id="match-list-container" class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <!-- Search Bar Row -->
                    <div class="mb-4">
                        <div class="relative w-full">
                            <input type="text" id="search-input" placeholder="üîç Cerca lega, squadra o tip..."
                                class="w-full pl-10 pr-4 py-2 border-2 border-blue-100 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-blue-50/30">
                            <i
                                class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-blue-400"></i>
                        </div>
                    </div>

                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">Partite filtrate (<span id="filtered-count">0</span>)</h3>

                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-gray-700 whitespace-nowrap">Ordina per:</label>
                            <select id="dashboard-sort-select" class="p-2 border rounded-lg text-sm">
                                <option value="data-desc">üìÖ Data (recente)</option>
                                <option value="orario-asc">‚è∞ Orario (cronologico)</option>
                                <option value="lega">Lega</option>
                                <option value="quota">Quota</option>
                            </select>
                        </div>
                    </div>
                    <div class="max-h-[60vh] overflow-y-auto custom-scrollbar">
                        <table class="w-full text-sm text-left">
                            <thead class="bg-gray-100 text-xs uppercase sticky top-0">
                                <tr>
                                    <th class="p-3 font-semibold sortable-header" data-sort="data">Data <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="lega">Lega <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="partita">Partita <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <!-- Mercato Removed -->
                                    <th class="p-3 font-semibold sortable-header" data-sort="tip">Tip <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center">Ris.</th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="probabilita">
                                        Prob. <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="quota">
                                        Quota <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center" title="Over 0.5 HT - Info primo tempo">HT
                                    </th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="esito">
                                        Esito <i class="fa-solid fa-sort sort-icon"></i></th>
                                </tr>
                            </thead>
                            <tbody id="match-list-body" class="divide-y"></tbody>
                        </table>
                    </div>
                </div>
            </div>



            <!-- PAGINA RANKING -->
            <div id="page-ranking" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Filtri Ranking -->
                <!-- Filtri Ranking (Collapsible on Mobile) -->
                <div class="bg-white rounded-2xl shadow-md border border-gray-200 mb-6 overflow-hidden">
                    <div class="p-4 md:p-6 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                        onclick="document.getElementById('ranking-filters-content').classList.toggle('hidden'); document.getElementById('ranking-filters-arrow').classList.toggle('rotate-180')">
                        <div>
                            <h2 class="text-xl md:text-2xl font-bold text-gray-800">üèÜ Ranking Partite</h2>
                            <p class="text-xs md:text-sm text-gray-500">Filtra e genera pronostici</p>
                        </div>
                        <i id="ranking-filters-arrow"
                            class="fa-solid fa-chevron-down text-gray-400 transition-transform duration-300"></i>
                    </div>

                    <div id="ranking-filters-content" class="p-4 md:p-6">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <!-- Prima riga -->
                            <div>
                                <label class="block text-xs font-bold text-gray-700 mb-1 uppercase tracking-wide">Data
                                    Partite</label>
                                <input type="date" id="ranking-date"
                                    class="w-full p-3 bg-gray-50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none transition-all">
                            </div>
                            <div>
                                <label
                                    class="block text-xs font-bold text-gray-700 mb-1 uppercase tracking-wide">Strategia</label>
                                <select id="ranking-filter-select"
                                    class="w-full p-3 bg-gray-50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none transition-all">
                                    <option value="">Nessun filtro (tutte le partite)</option>
                                </select>
                            </div>
                        </div>

                        <div class="mb-6">
                            <label class="block text-xs font-bold text-gray-700 mb-1 uppercase tracking-wide">Max
                                Partite</label>
                            <input type="number" id="ranking-max-matches" value="20" min="1" max="50"
                                class="w-full p-3 bg-gray-50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none transition-all">
                        </div>

                        <button id="generate-ranking-btn"
                            class="w-full bg-gradient-to-r from-blue-600 to-indigo-700 text-white py-3.5 rounded-xl font-bold shadow-lg shadow-blue-500/30 hover:shadow-blue-500/50 hover:scale-[1.02] transition-all active:scale-95">
                            <i class="fa-solid fa-magic mr-2"></i>Genera Ranking
                        </button>
                    </div>
                </div>

                <!-- Toggle Visualizzazione v3.5.3 -->
                <div id="ranking-view-toggle" class="mb-4 hidden">
                    <div class="bg-white p-4 rounded-lg shadow border border-gray-200">
                        <div class="flex items-center space-x-2">
                            <button id="view-by-tip-btn"
                                class="flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white">
                                <i class="fa-solid fa-chart-bar mr-2"></i>Per Tip e Ranking
                            </button>
                            <button id="view-by-time-btn"
                                class="flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300">
                                <i class="fa-solid fa-clock mr-2"></i>Per Orario
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Risultati Ranking -->
                <div id="ranking-results"></div>
            </div>



        </main>

        <!-- BOTTOM NAVIGATION (Mobile Only) -->
        <div
            class="fixed bottom-0 left-0 w-full bg-white border-t border-gray-200 flex justify-around items-center py-3 z-50 md:hidden shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)]">
            <button data-page="page-dashboard"
                class="nav-button flex flex-col items-center text-gray-500 hover:text-blue-600 transition-colors w-full">
                <i class="fa-solid fa-chart-bar text-xl mb-1"></i>
                <span class="text-xs font-medium">Dashboard</span>
            </button>
            <button data-page="page-ranking"
                class="nav-button flex flex-col items-center text-gray-500 hover:text-blue-600 transition-colors w-full">
                <i class="fa-solid fa-trophy text-xl mb-1"></i>
                <span class="text-xs font-medium">Ranking</span>
            </button>
            <button id="mobile-profile-btn"
                class="flex flex-col items-center text-gray-500 hover:text-blue-600 transition-colors w-full">
                <i class="fa-solid fa-user text-xl mb-1"></i>
                <span class="text-xs font-medium">Profilo</span>
            </button>
        </div>
    </div>

    <!-- Modal -->
    <div id="modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-2xl p-6 max-w-md mx-4">
            <h3 id="modal-title" class="text-xl font-bold mb-4"></h3>
            <p id="modal-message" class="mb-6"></p>
            <div class="flex justify-end space-x-4">
                <button id="modal-cancel" class="bg-gray-200 px-4 py-2 rounded-lg font-semibold">Annulla</button>
                <button id="modal-confirm"
                    class="bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold">Conferma</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, doc, getDoc, setDoc, addDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut, sendPasswordResetEmail, updatePassword, sendEmailVerification, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";

        // ==================== GLOBAL ERROR HANDLER ====================
        window.onerror = function (msg, url, line, col, error) {
            const debugBar = document.getElementById('debug-bar');
            if (debugBar) {
                debugBar.innerHTML = `ERROR: ${msg} at line ${line}`;
                debugBar.classList.remove('bg-yellow-400');
                debugBar.classList.add('bg-red-500', 'text-white');
            }
            return false;
        };

        // ==================== CONFIGURAZIONE FIREBASE CORRETTA ====================
        const firebaseConfig = {
            apiKey: "AIzaSyCwAy4QfYlbxj4yBLnho3ZnO2_NaxzbVRQ", // Chiave fornita dall'utente
            authDomain: "betmines-pronostici.firebaseapp.com",
            projectId: "betmines-pronostici",
            storageBucket: "betmines-pronostici.firebasestorage.app",
            messagingSenderId: "716119578109",
            appId: "1:716119578109:web:01e8b9dad7b17c91d63594"
        };

        let db;
        let auth;

        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            auth.languageCode = 'it'; // Force Italian language for emails and auth pages
        } catch (error) {
            console.error("Critical Firebase Init Error:", error);
            document.getElementById('auth-status').textContent = "Errore critico inizializzazione.";
            document.getElementById('auth-status').classList.add('text-red-400');
        }

        // ==================== GLOBAL STATE ====================
        let allMatches = [];
        let filteredMatches = [];
        let savedFilters = [];
        let favoriteLeagues = [];
        let stagedFavoriteLeagues = [];
        let sortState = { column: 'data', direction: 'desc' };
        let lastGeneratedRanking = null;

        // HT MERGE STATE
        let rawMainData = [];
        let rawHtData = [];

        // API FOOTBALL CONFIG
        const API_FOOTBALL_KEY = '62706d306e456ad02769b5bf985b8973';
        const API_FOOTBALL_URL = 'https://v3.api-football.com';

        // MATCH TIMES CACHE (Firebase - condiviso tutti utenti, 24h)
        const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 ore

        // Ottieni orario da Firebase cache
        async function getTimeFromCache(date, partita) {
            try {
                const key = `${date}_${partita.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const docSnap = await getDoc(doc(db, "match_times_temp", key));

                if (!docSnap.exists()) return null;

                const data = docSnap.data();

                // Check se >24h
                if (Date.now() - data.timestamp > CACHE_DURATION) {
                    // Expired, cancella
                    await deleteDoc(doc(db, "match_times_temp", key));
                    return null;
                }

                return data.ora;
            } catch (e) {
                console.error('[CACHE] Error getting time:', e);
                return null;
            }
        }
        let dailyFixturesCache = null; // Bulk cache giornaliero

        // ==================== FUZZY MATCHING ====================

        // Levenshtein distance
        function levenshteinDistance(a, b) {
            const matrix = [];

            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[b.length][a.length];
        }

        // Fuzzy match team name
        function fuzzyMatchTeam(csvTeam, apiTeams) {
            const csvNorm = csvTeam.toLowerCase().trim();
            let bestMatch = null;
            let bestScore = Infinity;

            for (let apiTeam of apiTeams) {
                const apiNorm = apiTeam.toLowerCase().trim();

                // Match esatto
                if (csvNorm === apiNorm) return apiTeam;

                // Contains
                if (csvNorm.includes(apiNorm) || apiNorm.includes(csvNorm)) {
                    const distance = levenshteinDistance(csvNorm, apiNorm);
                    if (distance < bestScore) {
                        bestScore = distance;
                        bestMatch = apiTeam;
                    }
                }

                // Levenshtein
                const distance = levenshteinDistance(csvNorm, apiNorm);
                if (distance < bestScore) {
                    bestScore = distance;
                    bestMatch = apiTeam;
                }
            }

            // Accetta solo se distance < 5
            return bestScore < 5 ? bestMatch : null;
        }

        // ==================== BULK API FOOTBALL ====================

        // Carica tutte le fixtures del giorno (1 chiamata bulk)
        async function loadDailyFixtures(date) {
            console.log(`[API DEBUG] Loading fixtures for ${date}...`);

            // Check localStorage
            const cacheKey = `fixtures_${date}`;
            const cached = localStorage.getItem(cacheKey);

            if (cached) {
                const data = JSON.parse(cached);
                // Valido per 6 ore
                if (Date.now() - data.timestamp < 6 * 60 * 60 * 1000) {
                    console.log(`[API DEBUG] Using cached fixtures for ${date} (${data.fixtures.length} matches)`);
                    dailyFixturesCache = data.fixtures;
                    return data.fixtures;
                }
            }

            // Fetch da API
            try {
                console.log(`[API DEBUG] Fetching from API-Football...`);
                const url = `${API_FOOTBALL_URL}/fixtures?date=${date}`;
                console.log(`[API DEBUG] URL: ${url}`);

                const response = await fetch(url, {
                    headers: {
                        'x-rapidapi-key': API_FOOTBALL_KEY,
                        'x-rapidapi-host': 'v3.api-football.com'
                    }
                });

                console.log(`[API DEBUG] Response status: ${response.status}`);

                if (!response.ok) {
                    console.error(`[API DEBUG] API error: ${response.status} ${response.statusText}`);
                    return [];
                }

                const data = await response.json();

                console.log(`[API DEBUG] Response data:`, data);

                const fixtures = data.response || [];
                console.log(`[API DEBUG] Loaded ${fixtures.length} fixtures`);

                // Salva in localStorage
                localStorage.setItem(cacheKey, JSON.stringify({
                    fixtures: fixtures,
                    timestamp: Date.now()
                }));

                dailyFixturesCache = fixtures;

                return fixtures;
            } catch (e) {
                console.error('[API DEBUG] Error fetching fixtures:', e);
                return [];
            }
        }

        // Trova fixture matchante con fuzzy matching
        function findMatchingFixture(csvMatch, fixtures) {
            if (!fixtures || fixtures.length === 0) return null;

            const [csvHome, csvAway] = csvMatch.split(' - ').map(t => t.trim());

            // Estrai tutti i nomi team dall'API
            const apiTeams = fixtures.flatMap(f => [
                f.teams.home.name,
                f.teams.away.name
            ]);

            // Fuzzy match
            const homeMatch = fuzzyMatchTeam(csvHome, apiTeams);
            const awayMatch = fuzzyMatchTeam(csvAway, apiTeams);

            if (!homeMatch || !awayMatch) return null;

            // Trova fixture con entrambi i team
            const fixture = fixtures.find(f =>
                f.teams.home.name === homeMatch &&
                f.teams.away.name === awayMatch
            );

            return fixture;
        }

        // Ottieni orario da bulk cache
        function getTimeFromBulkCache(date, match) {
            if (!dailyFixturesCache) return null;

            const fixture = findMatchingFixture(match, dailyFixturesCache);
            if (!fixture || !fixture.fixture || !fixture.fixture.date) return null;

            // Converti UTC a ora italiana
            const utcDate = new Date(fixture.fixture.date);
            const italianTime = new Date(utcDate.getTime() + (1 * 60 * 60 * 1000)); // UTC+1

            const hours = String(italianTime.getHours()).padStart(2, '0');
            const minutes = String(italianTime.getMinutes()).padStart(2, '0');

            return `${hours}:${minutes}`;
        }

        // ODDS CORRELATIONS LOOKUP TABLE - CALIBRATE SU 12,414 MATCH REALI
        // Aggiornato v3.3 con dati storici effettivi
        const ODDS_CORRELATIONS = {
            "+1.5": {
                "+2.5": {
                    // Basato su analisi: Over1.5@1.00-1.15 ‚Üí 63.5% Over2.5 ‚Üí @1.65
                    "1.00-1.15": [1.58, 1.72],
                    "1.10-1.20": [1.60, 1.75],
                    // Over1.5@1.15-1.25 ‚Üí 56.5% Over2.5 ‚Üí @1.86
                    "1.15-1.25": [1.78, 1.95],
                    "1.20-1.30": [1.80, 2.00],
                    // Over1.5@1.25-1.35 ‚Üí 51.6% Over2.5 ‚Üí @2.03
                    "1.25-1.35": [1.95, 2.15],
                    "1.30-1.40": [2.00, 2.20],
                    // Over1.5@1.35-1.50 ‚Üí 42.6% Over2.5 ‚Üí @2.47
                    "1.35-1.50": [2.35, 2.60],
                    "1.40-1.50": [2.40, 2.65]
                },
                "+3.5": {
                    // Basato su: Over1.5@1.00-1.15 ‚Üí 43.1% Over3.5 ‚Üí @2.44
                    "1.00-1.15": [2.30, 2.55],
                    "1.10-1.20": [2.35, 2.60],
                    // Over1.5@1.15-1.25 ‚Üí 34.5% Over3.5 ‚Üí @3.04
                    "1.15-1.25": [2.90, 3.20],
                    "1.20-1.30": [2.95, 3.25],
                    // Over1.5@1.25-1.35 ‚Üí 29.7% Over3.5 ‚Üí @3.54
                    "1.25-1.35": [3.35, 3.75],
                    "1.30-1.40": [3.45, 3.85]
                },
                "-2.5": {
                    "1.10-1.20": [2.50, 3.00],
                    "1.20-1.30": [2.20, 2.70],
                    "1.30-1.40": [2.00, 2.40]
                }
            },
            "+2.5": {
                "+3.5": {
                    "1.10-1.20": [1.50, 1.75],
                    "1.20-1.30": [1.70, 2.00],
                    "1.30-1.40": [1.90, 2.30],
                    "1.40-1.60": [2.10, 2.60]
                },
                "+4.5": {
                    "1.10-1.20": [2.30, 2.80],
                    "1.20-1.30": [2.50, 3.00],
                    "1.30-1.40": [2.70, 3.30]
                },
                "-3.5": {
                    "1.10-1.20": [2.00, 2.40],
                    "1.20-1.30": [1.80, 2.20],
                    "1.30-1.40": [1.60, 2.00]
                }
            }
        };

        // TOP LEGHE PER OVER (dalla nostra analisi)
        const TOP_OVER_LEAGUES = [
            'EU-FIN Kakkonen', 'EU-TUR Turkish Cup', 'EU-SVK Slovakia Cup',
            'EU-NOR Eliteserien', 'EU-NOR Obos-Ligaen', 'EU-FIN Veikkausliiga',
            'EU-NLD Eredivisie', 'EU-Champions League', 'NA-USA Major League Soccer',
            'EU-EST Meistriliiga', 'EU-SWE Ettan: North', 'EU-WAL Premier League',
            'EU-DEU 3. Liga', 'EU-SWE Ettan: South', 'EU-POL 1. Liga'
        ];

        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', async () => {
            const loadingOverlay = document.getElementById('loading-overlay');
            const authStatus = document.getElementById('auth-status');


            // --- GESTIONE AUTH ---
            const loginContainer = document.getElementById('login-container');
            const loadingContainer = document.getElementById('loading-container');
            const loginForm = document.getElementById('login-form');
            const loginError = document.getElementById('login-error');
            const toggleAuthModeBtn = document.getElementById('toggle-auth-mode');
            const authModeText = document.getElementById('auth-mode-text');
            const loginBtn = document.getElementById('login-btn');
            const forgotPasswordLink = document.getElementById('forgot-password-link');

            // Profile Elements
            const profileBtn = document.getElementById('profile-btn');
            const profileModal = document.getElementById('profile-modal');
            const closeProfileModal = document.getElementById('close-profile-modal');
            const profileEmail = document.getElementById('profile-email');
            const profileAlias = document.getElementById('profile-alias');
            const saveAliasBtn = document.getElementById('save-alias-btn');
            const newPasswordInput = document.getElementById('new-password');
            const changePasswordBtn = document.getElementById('change-password-btn');
            const modalLogoutBtn = document.getElementById('modal-logout-btn');
            const userInfoDisplay = document.getElementById('user-info-display');

            let isLoginMode = true;

            toggleAuthModeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                isLoginMode = !isLoginMode;
                if (isLoginMode) {
                    loginBtn.textContent = "Accedi";
                    authModeText.textContent = "Non hai un account?";
                    toggleAuthModeBtn.textContent = "Registrati";
                    forgotPasswordLink.classList.remove('hidden');
                } else {
                    loginBtn.textContent = "Registrati";
                    authModeText.textContent = "Hai gi√† un account?";
                    toggleAuthModeBtn.textContent = "Accedi";
                    forgotPasswordLink.classList.add('hidden');
                }
                loginError.classList.add('hidden');
            });

            async function authenticate() {
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        // Se l'utente √® anonimo (magari rimasto loggato dall'admin app), lo buttiamo fuori
                        if (user.isAnonymous) {
                            console.log("Utente anonimo rilevato. Logout forzato.");
                            await signOut(auth);
                            return;
                        }

                        // Logged in (Email/Password)

                        // EMAIL VERIFICATION CHECK
                        if (!user.emailVerified) {
                            console.log("User email not verified:", user.email);
                            loadingContainer.classList.add('hidden');
                            loginContainer.classList.remove('hidden');

                            // Show Verification Modal
                            showModal("Verifica Email Richiesta",
                                `Per accedere, devi verificare il tuo indirizzo email <b>${user.email}</b>.<br>Controlla la tua casella di posta (e lo SPAM).<br><br>
                                <button id="resend-verification-btn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full mt-2">Invia nuova email di verifica</button>`,
                                () => {
                                    signOut(auth); // Sign out when modal closes
                                }
                            );

                            // Attach listener to dynamic button
                            setTimeout(() => {
                                const resendBtn = document.getElementById('resend-verification-btn');
                                if (resendBtn) {
                                    resendBtn.addEventListener('click', async () => {
                                        try {
                                            await sendEmailVerification(user);
                                            resendBtn.textContent = "Email Inviata!";
                                            resendBtn.disabled = true;
                                            resendBtn.classList.add('opacity-50', 'cursor-not-allowed');
                                        } catch (e) {
                                            console.error("Error resending verification:", e);
                                            alert("Errore nell'invio. Riprova pi√π tardi.");
                                        }
                                    });
                                }
                            }, 100);

                            return; // STOP HERE
                        }

                        loginContainer.classList.add('hidden');
                        loadingContainer.classList.remove('hidden');
                        authStatus.textContent = "Autenticato. Caricamento dati...";
                        authStatus.className = "text-green-400 text-sm font-mono bg-gray-800 p-2 rounded border border-green-700";

                        // Setup Profile UI
                        if (profileBtn) {
                            profileBtn.classList.remove('hidden');
                        }
                        if (userInfoDisplay) userInfoDisplay.classList.remove('hidden');
                        profileEmail.value = user.email || 'Utente';

                        // Load Alias
                        try {
                            const userDoc = await getDoc(doc(db, "users", user.uid));
                            if (userDoc.exists() && userDoc.data().alias) {
                                const alias = userDoc.data().alias;
                                profileAlias.value = alias;
                                userInfoDisplay.textContent = `Ciao, ${alias}`;
                            } else {
                                userInfoDisplay.textContent = `Ciao, ${user.email ? user.email.split('@')[0] : 'Utente'}`;
                            }
                        } catch (e) {
                            console.error("Error loading profile:", e);
                        }

                        await startApp();
                    } else {
                        // Not logged in
                        loadingOverlay.classList.remove('hidden'); // SHOW LOGIN SCREEN
                        loadingContainer.classList.add('hidden');
                        loginContainer.classList.remove('hidden');
                        if (profileBtn) profileBtn.classList.add('hidden');
                        if (userInfoDisplay) userInfoDisplay.classList.add('hidden');
                    }
                });
            }

            // Registration Logic is handled within loginForm submit

            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const email = document.getElementById('email').value;
                const password = document.getElementById('password').value;
                loginError.classList.add('hidden');

                if (isLoginMode) {
                    // LOGIN FLOW
                    try {
                        await setPersistence(auth, browserLocalPersistence);
                        await signInWithEmailAndPassword(auth, email, password);
                        // onAuthStateChanged handles the rest (including verification check)
                    } catch (error) {
                        console.error("Login Error:", error);
                        let msg = "Email o password non validi.";
                        if (error.code === 'auth/user-not-found') msg = "Utente non trovato.";
                        if (error.code === 'auth/wrong-password') msg = "Password errata.";
                        if (error.code === 'auth/too-many-requests') msg = "Troppi tentativi. Riprova pi√π tardi.";
                        loginError.textContent = msg;
                        loginError.classList.remove('hidden');
                    }
                } else {
                    // REGISTRATION FLOW
                    if (password.length < 6) {
                        loginError.textContent = "La password deve essere di almeno 6 caratteri.";
                        loginError.classList.remove('hidden');
                        return;
                    }

                    try {
                        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                        const user = userCredential.user;

                        // Send Verification Email
                        await sendEmailVerification(user);

                        // Create User Doc
                        await setDoc(doc(db, "users", user.uid), {
                            email: email,
                            createdAt: Date.now(),
                            role: 'user'
                        });

                        showModal("Registrazione Completata",
                            `Account creato con successo!<br><b>Abbiamo inviato un'email di verifica a ${email}.</b><br>Verifica la tua email prima di accedere.`,
                            () => {
                                signOut(auth); // Force logout so they have to login again after verification
                                window.location.reload();
                            }
                        );
                    } catch (error) {
                        console.error("Registration Error:", error);
                        let msg = "Errore durante la registrazione.";
                        if (error.code === 'auth/email-already-in-use') msg = "Email gi√† registrata.";
                        if (error.code === 'auth/weak-password') msg = "Password troppo debole.";
                        if (error.code === 'auth/invalid-email') msg = "Email non valida.";
                        loginError.textContent = msg;
                        loginError.classList.remove('hidden');
                    }
                }
            });

            // Forgot Password Logic
            // Forgot Password Logic
            document.getElementById('forgot-password-link').addEventListener('click', async (e) => {
                e.preventDefault();
                const email = document.getElementById('email').value.trim();
                if (!email) {
                    showModal("Attenzione", "Inserisci la tua email nel campo Email per resettare la password.", () => { });
                    return;
                }

                console.log("Attempting password reset for:", email);

                try {
                    await sendPasswordResetEmail(auth, email);
                    console.log("Password reset email sent successfully.");
                    showModal("Email Inviata", `Un'email di reset √® stata inviata a <b>${email}</b>.<br>Controlla anche nello SPAM. <b> üòâ</b>`, () => { });
                } catch (error) {
                    console.error("Reset Password Error:", error);
                    let errorMsg = "Impossibile inviare email di reset.";
                    if (error.code === 'auth/user-not-found') {
                        errorMsg = "Nessun account trovato con questa email.";
                    } else if (error.code === 'auth/invalid-email') {
                        errorMsg = "Indirizzo email non valido.";
                    }
                    showModal("Errore", errorMsg, () => { });
                }
            });

            // --- PROFILE MODAL LOGIC ---
            profileBtn.addEventListener('click', () => {
                profileModal.classList.remove('hidden');
                profileModal.classList.add('flex');
            });

            closeProfileModal.addEventListener('click', () => {
                profileModal.classList.add('hidden');
                profileModal.classList.remove('flex');
            });

            saveAliasBtn.addEventListener('click', async () => {
                if (!auth.currentUser) return;
                const newAlias = profileAlias.value.trim();
                if (newAlias === '') {
                    showModal("Attenzione", "L'alias non pu√≤ essere vuoto.", () => { });
                    return;
                }
                try {
                    await setDoc(doc(db, "users", auth.currentUser.uid), { alias: newAlias }, { merge: true });
                    userInfoDisplay.textContent = `Ciao, ${newAlias}`;
                    showModal("Successo", "Alias aggiornato con successo!", () => { });
                } catch (e) {
                    console.error("Error saving alias:", e);
                    showModal("Errore", "Impossibile salvare l'alias.", () => { });
                }
            });

            changePasswordBtn.addEventListener('click', async () => {
                if (!auth.currentUser) return;
                const newPassword = newPasswordInput.value;
                if (newPassword.length < 6) {
                    showModal("Attenzione", "La nuova password deve essere di almeno 6 caratteri.", () => { });
                    return;
                }
                try {
                    await updatePassword(auth.currentUser, newPassword);
                    newPasswordInput.value = '';
                    showModal("Successo", "Password aggiornata con successo!", () => { });
                } catch (e) {
                    console.error("Error changing password:", e);
                    showModal("Errore", "Impossibile aggiornare la password. Potrebbe essere necessario riautenticarsi.", () => { });
                }
            });

            modalLogoutBtn.addEventListener('click', async () => {
                try {
                    await signOut(auth);
                    profileModal.classList.add('hidden');
                    profileModal.classList.remove('flex');
                    showModal("Disconnesso", "Sei stato disconnesso con successo.", () => { });
                } catch (e) {
                    console.error("Error logging out:", e);
                    showModal("Errore", "Impossibile disconnettersi.", () => { });
                }
            });


            // --- START APP LOGIC ---
            let lastLoadTime = 0;
            async function startApp() {
                try {
                    await loadAllMatches();
                    lastLoadTime = Date.now();
                    await loadFavorites();
                    setupFilters();
                    populateFilters();
                    applyFiltersAndRender();
                    await loadSavedFilters();

                    showPage('page-dashboard');
                    loadingOverlay.classList.add('hidden');
                } catch (e) {
                    console.error("Data Load Error:", e);
                    authStatus.textContent = "Errore caricamento dati Firestore.";
                    authStatus.classList.add('text-red-400');
                }
            }

            // Avvia flusso auth
            authenticate();

            // UI Elements
            const pages = document.querySelectorAll('.page');
            const navButtons = document.querySelectorAll('.nav-button');
            const filterDateStart = document.getElementById('filter-date-start');
            const filterDateEnd = document.getElementById('filter-date-end');
            const leagueFiltersGrid = document.getElementById('league-filters-grid');
            const tipFiltersContainer = document.getElementById('tip-filters-container');
            const probabilitySliderEl = document.getElementById('probability-slider');
            const oddsSliderEl = document.getElementById('odds-slider');
            const probMinInput = document.getElementById('prob-min-input');
            const probMaxInput = document.getElementById('prob-max-input');
            const oddsMinInput = document.getElementById('odds-min-input');
            const oddsMaxInput = document.getElementById('odds-max-input');
            const searchInput = document.getElementById('search-input');
            const sortableHeaders = document.querySelectorAll('.sortable-header');

            // Sliders Dashboard
            noUiSlider.create(probabilitySliderEl, {
                start: [0, 100],
                connect: true,
                range: { min: 0, max: 100 },
                step: 1,
                tooltips: false
            });

            noUiSlider.create(oddsSliderEl, {
                start: [1.0, 10.0],
                connect: true,
                range: { min: 1.0, max: 10.0 },
                step: 0.01,
                tooltips: false
            });

            // Sincronizzazione SLIDER ‚Üí INPUT (Probabilit√†)
            probabilitySliderEl.noUiSlider.on('update', (values) => {
                probMinInput.value = parseInt(values[0]);
                probMaxInput.value = parseInt(values[1]);
            });

            probabilitySliderEl.noUiSlider.on('set', () => {
                applyFiltersAndRender();
            });

            // Sincronizzazione INPUT ‚Üí SLIDER (Probabilit√†)
            probMinInput.addEventListener('change', () => {
                const min = parseInt(probMinInput.value) || 0;
                const max = parseInt(probMaxInput.value) || 100;
                if (min <= max) {
                    probabilitySliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            probMaxInput.addEventListener('change', () => {
                const min = parseInt(probMinInput.value) || 0;
                const max = parseInt(probMaxInput.value) || 100;
                if (min <= max) {
                    probabilitySliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            // Sincronizzazione SLIDER ‚Üí INPUT (Quota)
            oddsSliderEl.noUiSlider.on('update', (values) => {
                oddsMinInput.value = parseFloat(values[0]).toFixed(2);
                oddsMaxInput.value = parseFloat(values[1]).toFixed(2);
            });

            oddsSliderEl.noUiSlider.on('set', () => {
                applyFiltersAndRender();
            });

            // Sincronizzazione INPUT ‚Üí SLIDER (Quota)
            oddsMinInput.addEventListener('change', () => {
                const min = parseFloat(oddsMinInput.value) || 1.0;
                const max = parseFloat(oddsMaxInput.value) || 10.0;
                if (min <= max) {
                    oddsSliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            oddsMaxInput.addEventListener('change', () => {
                const min = parseFloat(oddsMinInput.value) || 1.0;
                const max = parseFloat(oddsMaxInput.value) || 10.0;
                if (min <= max) {
                    oddsSliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            // Buttons
            const resetFiltersBtn = document.getElementById('reset-filters-btn');
            const resetLeaguesBtn = document.getElementById('reset-leagues-btn');
            const resetTipsBtn = document.getElementById('reset-tips-btn');
            const saveFilterBtn = document.getElementById('save-filter-btn');
            const loadFilterBtn = document.getElementById('load-filter-btn');
            const deleteFilterBtn = document.getElementById('delete-filter-btn');
            const updateFavoritesBtn = document.getElementById('update-favorites-btn');

            // Dates - Dashboard VUOTA all'inizio
            filterDateStart.value = '';
            filterDateEnd.value = '';

            // Altre pagine mantengono data odierna
            const today = new Date();

            document.getElementById('ranking-date').value = today.toISOString().split('T')[0];

            // ==================== NAVIGATION ====================
            function showPage(pageId) {
                pages.forEach(p => p.classList.remove('active'));
                document.getElementById(pageId).classList.add('active');

                navButtons.forEach(btn => {
                    // Reset styles
                    btn.classList.remove('bg-blue-600', 'text-white', 'text-blue-600');
                    btn.classList.add('text-gray-500', 'text-gray-700', 'bg-gray-200'); // Reset generic

                    // Check if button matches page
                    if (btn.dataset.page === pageId) {
                        // Desktop style
                        if (btn.classList.contains('shadow-sm')) {
                            btn.classList.remove('bg-gray-200', 'text-gray-700');
                            btn.classList.add('bg-blue-600', 'text-white');
                        }
                        // Mobile style (icon + text)
                        else {
                            btn.classList.remove('text-gray-500');
                            btn.classList.add('text-blue-600');
                        }
                    } else {
                        // Inactive Desktop
                        if (btn.classList.contains('shadow-sm')) {
                            btn.classList.remove('bg-blue-600', 'text-white');
                            btn.classList.add('bg-gray-200', 'text-gray-700');
                        }
                        // Inactive Mobile
                        else {
                            btn.classList.remove('text-blue-600');
                            btn.classList.add('text-gray-500');
                        }
                    }
                });
            }

            navButtons.forEach(btn => btn.addEventListener('click', (e) => showPage(e.currentTarget.dataset.page)));

            // ==================== LOAD DATA ====================
            async function loadAllMatches() {
                try {
                    const matchesCol = collection(db, "matches");
                    const snapshot = await getDocs(matchesCol);
                    allMatches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    allMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                } catch (e) {
                    console.error('Error loading matches:', e);
                    allMatches = [];
                }
            }

            function normalizeLega(lega) {
                return lega.replace(/\s+/g, ' ').trim();
            }

            // ==================== FILTERS ====================
            function setupFilters() {
                searchInput.addEventListener('input', applyFiltersAndRender);
                filterDateStart.addEventListener('change', applyFiltersAndRender);
                filterDateEnd.addEventListener('change', applyFiltersAndRender);
            }

            function categorizeLeague(leagueName) {
                if (stagedFavoriteLeagues.includes(leagueName)) return '‚≠ê Preferiti';
                if (leagueName.startsWith('EU-Champions League') || leagueName.startsWith('EU-Europa League') || leagueName.startsWith('EU-Europa Conference League')) return 'Coppe Europee';
                if (leagueName.includes('WCQ') || leagueName.endsWith('-NAZ')) return 'Competizioni Nazionali';
                if (/(Cup|Coppa|Copa|Beker|Ta√ßa)/i.test(leagueName)) return 'Coppe Nazionali';

                const continentMatch = leagueName.match(/^(AS|AF|NA|SA|OC)-/);
                if (continentMatch) return 'Resto del Mondo';

                const europeanPrefixes = ['EU-'];
                if (europeanPrefixes.some(prefix => leagueName.startsWith(prefix))) return 'Europa';

                return 'Non Classificati';
            }

            function populateFilters() {
                // Leagues categorizzate
                const leagues = [...new Set(allMatches.map(m => m.lega))];
                const categorized = leagues.reduce((acc, league) => {
                    const category = categorizeLeague(league);
                    if (!acc[category]) acc[category] = [];
                    acc[category].push(league);
                    return acc;
                }, {});

                const categoryOrder = ['‚≠ê Preferiti', 'Europa', 'Resto del Mondo', 'Coppe Europee', 'Competizioni Nazionali', 'Coppe Nazionali', 'Non Classificati'];
                leagueFiltersGrid.innerHTML = '';

                // Change container style to flex column for accordions
                leagueFiltersGrid.className = 'flex flex-col gap-2';

                categoryOrder.forEach(category => {
                    if (!categorized[category] || categorized[category].length === 0) return;

                    const details = document.createElement('details');
                    details.className = 'group bg-gray-50 border rounded-lg overflow-hidden shadow-sm';
                    // Open Favorites by default - DISABLED per user request
                    // if (category === '‚≠ê Preferiti') details.open = true;

                    const leaguesInCategory = categorized[category].sort().map(league => `
                        <div class="flex items-center justify-between p-2 hover:bg-blue-50 border-b border-gray-100 last:border-0 transition-colors">
                            <label class="flex items-center space-x-3 cursor-pointer flex-grow">
                                <input type="checkbox" value="${league}" class="league-checkbox form-checkbox h-4 w-4 rounded text-blue-600 border-gray-300 focus:ring-blue-500">
                                <span class="text-sm text-gray-700" title="${league}">${league}</span>
                            </label>
                            <i class="fa-solid fa-star favorite-star ${stagedFavoriteLeagues.includes(league) ? 'is-favorite' : ''} text-gray-300 hover:text-yellow-400 transition-colors cursor-pointer p-1" data-league="${league}"></i>
                        </div>`).join('');

                    details.innerHTML = `
                        <summary class="flex items-center justify-between p-3 cursor-pointer bg-white hover:bg-gray-50 transition-colors list-none select-none">
                            <div class="flex items-center space-x-2 font-semibold text-gray-700">
                                <input type="checkbox" class="category-select-all form-checkbox h-4 w-4 rounded text-blue-600 border-gray-300 focus:ring-blue-500" onclick="event.stopPropagation()">
                                <span>${category}</span>
                                <span class="text-xs font-normal text-gray-500 bg-gray-100 px-2 py-0.5 rounded-full">${categorized[category].length}</span>
                            </div>
                            <i class="fa-solid fa-chevron-down text-gray-400 transition-transform duration-200 group-open:rotate-180"></i>
                        </summary>
                        <div class="max-h-96 overflow-y-auto custom-scrollbar bg-white border-t border-gray-100">
                            ${leaguesInCategory}
                        </div>`;

                    leagueFiltersGrid.appendChild(details);
                });

                leagueFiltersGrid.querySelectorAll('.league-checkbox').forEach(cb => {
                    cb.addEventListener('change', applyFiltersAndRender);
                });

                leagueFiltersGrid.querySelectorAll('.category-select-all').forEach(masterCb => {
                    masterCb.addEventListener('change', (e) => {
                        const isChecked = e.target.checked;
                        const details = e.target.closest('details');
                        details.querySelectorAll('.league-checkbox').forEach(leagueCb => {
                            leagueCb.checked = isChecked;
                        });
                        applyFiltersAndRender();
                    });
                });

                leagueFiltersGrid.querySelectorAll('.favorite-star').forEach(star => {
                    star.addEventListener('click', handleFavoriteToggle);
                });

                // Predefined Tips by Market
                const predefinedTips = {
                    '1X2': ['1', 'X', '2'],
                    'Doppia Chance': ['1X', '12', 'X2'],
                    'Under/Over': ['-1.5', '+1.5', '-2.5', '+2.5', '-3.5', '+3.5'],
                    'Gol/No Gol': ['S√¨', 'No']
                };

                tipFiltersContainer.innerHTML = `<div class="grid grid-cols-2 md:grid-cols-4 gap-4">${Object.entries(predefinedTips).map(([market, tips]) => {
                    const tipButtons = tips.map(tip => `
                        <button data-tip="${tip}" class="tip-button w-full px-2 py-1 text-xs rounded-full border border-gray-300 bg-white hover:bg-gray-100 transition-colors">${tip}</button>
                    `).join('');
                    return `
                        <div>
                            <h4 class="font-semibold text-xs uppercase text-gray-500 mb-2">${market}</h4>
                            <div class="flex flex-wrap gap-2">${tipButtons}</div>
                        </div>
                    `;
                }).join('')}</div>`;

                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('active');
                        applyFiltersAndRender();
                    });
                });
            }

            function applyFiltersAndRender(customSort = null) {
                const selectedLeagues = Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value);
                const selectedTips = Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip);
                const [probMin, probMax] = probabilitySliderEl.noUiSlider.get().map(v => parseInt(v));
                const [oddsMin, oddsMax] = oddsSliderEl.noUiSlider.get().map(v => parseFloat(v));
                const searchTerm = searchInput.value.toLowerCase().trim();
                const dateStart = filterDateStart.value ? new Date(filterDateStart.value) : null;
                const dateEnd = filterDateEnd.value ? new Date(filterDateEnd.value) : null;

                filteredMatches = allMatches.filter(m => {
                    if (selectedLeagues.length > 0 && !selectedLeagues.includes(m.lega)) return false;
                    if (selectedTips.length > 0 && !selectedTips.includes(m.tip)) return false;
                    if (m.probabilita < probMin || m.probabilita > probMax) return false;
                    if (m.quota < oddsMin || m.quota > oddsMax) return false;

                    if (searchTerm) {
                        const matchText = `${m.lega} ${m.partita}`.toLowerCase();
                        if (!matchText.includes(searchTerm)) return false;
                    }

                    if (dateStart || dateEnd) {
                        const matchDate = new Date(m.data || '2000-01-01');
                        if (dateStart && matchDate < dateStart) return false;
                        if (dateEnd && matchDate > dateEnd) return false;
                    }

                    return true;
                });

                sortAndRenderMatches(customSort);
                updateStatsDisplay(filteredMatches);
            }

            function updateStatsDisplay(matches) {
                // SOLO partite con esito (vinte o perse)
                const matchesWithOutcome = matches.filter(m => m.esito === 'Vinto' || m.esito === 'Perso');
                const won = matchesWithOutcome.filter(m => m.esito === 'Vinto').length;
                const lost = matchesWithOutcome.filter(m => m.esito === 'Perso').length;
                const winRate = matchesWithOutcome.length > 0 ? (won / matchesWithOutcome.length) * 100 : 0;
                const totalStake = matchesWithOutcome.length;
                const profit = matchesWithOutcome.reduce((acc, m) => acc + (m.esito === 'Vinto' ? m.quota - 1 : -1), 0);
                const roi = totalStake > 0 ? (profit / totalStake * 100) : 0;

                const statsContainer = document.getElementById('stats-container');
                statsContainer.innerHTML = `
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-blue-600">${matchesWithOutcome.length}</div><div class="text-xs text-gray-600">Totale</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-green-600">${won}</div><div class="text-xs text-gray-600">Vinte</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-red-600">${lost}</div><div class="text-xs text-gray-600">Perse</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold ${winRate >= 70 ? 'text-green-600' : 'text-red-600'}">${winRate.toFixed(1)}%</div><div class="text-xs text-gray-600">Winrate</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold ${roi >= 0 ? 'text-green-600' : 'text-red-600'}">${roi.toFixed(1)}%</div><div class="text-xs text-gray-600">ROI</div></div>
                `;
            }

            function sortAndRenderMatches(customSort = null) {
                let sorted;

                // v3.5.3: Custom sort da dropdown
                if (customSort) {
                    const sortSelect = document.getElementById('dashboard-sort-select');
                    const sortValue = customSort || (sortSelect ? sortSelect.value : 'data-desc');

                    sorted = [...filteredMatches].sort((a, b) => {
                        if (sortValue === 'orario-asc') {
                            // Ordina per orario cronologico
                            const timeA = a.time || '99:99';
                            const timeB = b.time || '99:99';
                            return timeA.localeCompare(timeB);
                        } else if (sortValue === 'data-desc') {
                            return new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01');
                        } else if (sortValue === 'lega') {
                            return (a.lega || '').localeCompare(b.lega || '');
                        } else if (sortValue === 'quota') {
                            return (a.quota || 0) - (b.quota || 0);
                        }
                        return 0;
                    });
                } else {
                    // Sort normale da header click
                    const { column, direction } = sortState;
                    sorted = [...filteredMatches].sort((a, b) => {
                        const valA = a[column];
                        const valB = b[column];
                        let comparison = 0;
                        if (typeof valA === 'string') comparison = valA.localeCompare(valB);
                        else comparison = valA - valB;
                        return direction === 'asc' ? comparison : -comparison;
                    });
                }

                renderMatchList(sorted);
                updateSortIcons();
            }

            function renderMatchList(matches) {
                const tbody = document.getElementById('match-list-body');
                document.getElementById('filtered-count').textContent = matches.length;

                const displayMatches = matches.slice(0, 200);
                const now = new Date();

                tbody.innerHTML = displayMatches.map(m => {
                    const esitoClass = m.esito === 'Vinto' ? 'text-green-600 font-bold' : m.esito === 'Perso' ? 'text-red-600 font-bold' : '';

                    // Processo info HT
                    let htDisplay = '<span class="ht-badge-none">-</span>';
                    if (m.info_ht && m.info_ht.trim() !== '') {
                        // Estraggo prob da "76% (@1.33)"
                        const probMatch = m.info_ht.match(/(\d+)%/);
                        if (probMatch) {
                            const htProb = parseInt(probMatch[1]);
                            let badgeClass = 'ht-badge-low';
                            if (htProb >= 75) badgeClass = 'ht-badge-high';
                            else if (htProb >= 60) badgeClass = 'ht-badge-medium';

                            htDisplay = `<span class="${badgeClass}">${m.info_ht}</span>`;
                        }
                    }

                    // Processo ORA con badge smart
                    let timeDisplay = '<span class="text-gray-400">-</span>';
                    if (m.time && m.time.trim() !== '') {
                        const matchTime = m.time;
                        const [hours, minutes] = matchTime.split(':').map(n => parseInt(n));

                        // Crea date per confronto (oggi con orario partita)
                        const matchDate = new Date();
                        matchDate.setHours(hours, minutes, 0, 0);

                        const diffMinutes = (matchDate - now) / (1000 * 60);

                        // Badge logica
                        if (Math.abs(diffMinutes) <= 15) {
                            // LIVE (¬±15 min)
                            timeDisplay = `<span class="text-red-600 font-bold">üî¥ ${matchTime}</span>`;
                        } else if (diffMinutes > 0 && diffMinutes <= 60) {
                            // IMMINENTE (<60 min)
                            timeDisplay = `<span class="text-orange-600 font-bold">‚è∞ ${matchTime}</span>`;
                        } else {
                            // Normale
                            timeDisplay = `<span class="text-gray-700">${matchTime}</span>`;
                        }
                    }

                    return `
                        <tr class="hover:bg-gray-50">
                            <td class="p-3 text-xs">${m.data}</td>
                            <td class="p-3 text-xs">${m.lega}</td>
                            <td class="p-3 text-xs font-medium">${m.partita}</td>
                            <!-- Mercato Removed -->
                            <td class="p-3 text-xs font-semibold">${m.tip}</td>
                            <td class="p-3 text-xs text-center">${m.risultato || '-'}</td>
                            <td class="p-3 text-xs text-center">${m.probabilita}%</td>
                            <td class="p-3 text-xs text-center font-bold">${m.quota}</td>
                            <td class="p-3 text-xs text-center w-48 whitespace-nowrap">${htDisplay}</td> <!-- Expanded HT -->
                            <td class="p-3 text-xs text-center ${esitoClass}">${m.esito || '-'}</td>
                        </tr>
                    `;
                }).join('');

                if (matches.length > 200) {
                    tbody.innerHTML += `<tr><td colspan="9" class="p-3 text-center text-sm text-gray-500">Mostrati primi 200 di ${matches.length}</td></tr>`;
                }
            }

            function updateSortIcons() {
                document.querySelectorAll('.sortable-header').forEach(header => {
                    const icon = header.querySelector('.sort-icon');
                    if (header.dataset.sort === sortState.column) {
                        header.classList.add('active');
                        if (sortState.direction === 'asc') {
                            icon.classList.remove('fa-sort', 'fa-sort-down');
                            icon.classList.add('fa-sort-up');
                        } else {
                            icon.classList.remove('fa-sort', 'fa-sort-up');
                            icon.classList.add('fa-sort-down');
                        }
                    } else {
                        header.classList.remove('active');
                        icon.classList.remove('fa-sort-up', 'fa-sort-down');
                        icon.classList.add('fa-sort');
                    }
                });
            }

            sortableHeaders.forEach(header => header.addEventListener('click', (e) => {
                const newColumn = e.currentTarget.dataset.sort;
                if (sortState.column === newColumn) {
                    sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.column = newColumn;
                    sortState.direction = ['data', 'probabilita', 'quota'].includes(newColumn) ? 'desc' : 'asc';
                }
                sortAndRenderMatches();
            }));

            // ==================== FAVORITES ====================
            const loadFavorites = async () => {
                if (!auth.currentUser) return;
                try {
                    const favDocRef = doc(db, "users", auth.currentUser.uid, "preferences", "favorites");
                    const docSnap = await getDoc(favDocRef);
                    if (docSnap.exists()) {
                        favoriteLeagues = docSnap.data().leagues || [];
                        stagedFavoriteLeagues = [...favoriteLeagues];
                    }
                } catch (e) {
                    console.error("Error loading favorites:", e);
                }
            };

            const handleUpdateFavorites = async () => {
                if (!auth.currentUser) return;
                try {
                    const userFavRef = doc(db, "users", auth.currentUser.uid, "preferences", "favorites");
                    await setDoc(userFavRef, { leagues: stagedFavoriteLeagues }, { merge: true });
                    favoriteLeagues = [...stagedFavoriteLeagues];
                    showModal("Successo", "Preferiti salvati correttamente!", () => { });
                    populateFilters(); // Refresh UI
                } catch (e) {
                    console.error("Error saving favorites:", e);
                    showModal("Errore", "Impossibile salvare i preferiti.", () => { });
                }
            };

            const handleFavoriteToggle = (e) => {
                const star = e.target;
                const leagueName = star.dataset.league;

                if (stagedFavoriteLeagues.includes(leagueName)) {
                    // Remove from favorites
                    stagedFavoriteLeagues = stagedFavoriteLeagues.filter(l => l !== leagueName);
                    star.classList.remove('is-favorite');
                    star.classList.add('text-gray-300');
                } else {
                    // Add to favorites
                    stagedFavoriteLeagues.push(leagueName);
                    star.classList.add('is-favorite');
                    star.classList.remove('text-gray-300');
                }

                // DO NOT call populateFilters() here to avoid re-rendering the whole list
                // The user will click "Aggiorna Preferiti" or "Salva Preferiti" to apply changes
            };
            updateFavoritesBtn.addEventListener('click', handleUpdateFavorites);

            // Mobile Profile Button
            document.getElementById('mobile-profile-btn').addEventListener('click', () => {
                profileModal.classList.remove('hidden');
                profileModal.classList.add('flex');
            });

            // TOP LEAGUES FILTER
            const handleSelectTopLeagues = async () => {
                // CHECK FOR UPDATES
                try {
                    const metadataDoc = await getDoc(doc(db, "system", "metadata"));
                    if (metadataDoc.exists()) {
                        const serverTime = metadataDoc.data().lastUpdated;
                        if (serverTime && serverTime > lastLoadTime) {
                            showModal("Dati Aggiornati Disponibili",
                                "Sono state rilevate modifiche al database (es. correzione nomi leghe).<br>Vuoi ricaricare i dati per avere statistiche precise?",
                                async () => {
                                    await loadAllMatches(); // Reloads data
                                    handleSelectTopLeagues(); // Retry filter
                                }
                            );
                            return; // Stop execution until reload
                        }
                    }
                } catch (e) {
                    console.error("Error checking metadata:", e);
                }

                // 1. Calculate stats based on ALL matches
                const stats = analyzeLeaguePerformance(allMatches);

                let selectedCount = 0;
                let selectedLeaguesNames = [];

                // Reset current selection
                document.querySelectorAll('.league-checkbox').forEach(cb => cb.checked = false);

                const checkboxes = document.querySelectorAll('.league-checkbox');

                checkboxes.forEach(cb => {
                    const originalLeagueName = cb.value;
                    const lookupKey = originalLeagueName.toLowerCase().trim();

                    if (stats[lookupKey] && stats[lookupKey].overallWinrate > 79) {
                        cb.checked = true;
                        selectedCount++;
                        selectedLeaguesNames.push(`${originalLeagueName} (${stats[lookupKey].overallWinrate}%)`);

                        // Force open the accordion
                        const details = cb.closest('details');
                        if (details) {
                            details.open = true;
                        }
                    }
                });

                if (selectedCount === 0) {
                    showModal("Info", "Nessuna lega trovata con Winrate > 79%.", () => { });
                    return;
                }

                // Apply filters immediately
                applyFiltersAndRender();

                // Notify user
                const listHtml = selectedLeaguesNames.slice(0, 10).join('<br>') + (selectedLeaguesNames.length > 10 ? `<br>...e altre ${selectedLeaguesNames.length - 10}` : '');
                showModal("Filtro Applicato", `Selezionate <b>${selectedCount}</b> leghe con Winrate > 80%:<br><div class="text-sm text-gray-600 my-2 max-h-40 overflow-y-auto">${listHtml}</div>Puoi affinare ulteriormente la selezione.`, () => { });
            };

            document.getElementById('top-leagues-btn').addEventListener('click', handleSelectTopLeagues);

            // ==================== SAVED FILTERS ====================
            async function loadSavedFilters() {
                if (!auth.currentUser) return;
                try {
                    const strategiesCol = collection(db, "users", auth.currentUser.uid, "strategies");
                    const snapshot = await getDocs(strategiesCol);
                    savedFilters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                    // Popola dropdown Dashboard
                    const select = document.getElementById('saved-filters-select');
                    select.innerHTML = '<option value="">Seleziona...</option>' + savedFilters.map(f => `<option value="${f.id}">${f.name}</option>`).join('');

                    // Popola dropdown Ranking con opzione speciale BEST 0.5 HT
                    const rankingSelect = document.getElementById('ranking-filter-select');
                    rankingSelect.innerHTML = '<option value="">Nessun filtro (tutte le partite)</option>' +
                        '<option value="BEST_05HT" style="background: linear-gradient(to right, #fef3c7, #fde68a); font-weight: bold;">‚ö° BEST 0.5 HT (Auto)</option>' +
                        savedFilters.map(f => `<option value="${f.id}">${f.name}</option>`).join('');
                } catch (e) {
                    console.error("Error loading strategies:", e);
                }
            };

            const handleSaveFilter = async () => {
                if (!auth.currentUser) return;
                const name = document.getElementById('new-filter-name').value;
                if (!name) {
                    showModal("Attenzione", "Inserisci un nome per la strategia.", () => { });
                    return;
                }

                // Capture current state
                const currentFilterState = {
                    leagues: Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value),
                    tips: Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip),
                    prob: probabilitySliderEl.noUiSlider.get().map(v => parseInt(v)),
                    odds: oddsSliderEl.noUiSlider.get().map(v => parseFloat(v)),
                    startDate: filterDateStart.value,
                    endDate: filterDateEnd.value
                };

                try {
                    await addDoc(collection(db, "users", auth.currentUser.uid, "strategies"), {
                        name: name,
                        state: currentFilterState,
                        createdAt: Date.now()
                    });
                    await loadSavedFilters(); // Reload list
                    document.getElementById('new-filter-name').value = ''; // Reset input
                    showModal("Successo", "Strategia salvata!", () => { });
                } catch (e) {
                    console.error("Error saving strategy:", e);
                    showModal("Errore", "Impossibile salvare la strategia.", () => { });
                }
            };

            const handleLoadFilter = () => {
                const selectedId = document.getElementById('saved-filters-select').value;
                if (!selectedId) return;
                const selectedFilter = savedFilters.find(f => f.id === selectedId);
                if (!selectedFilter) return;

                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));

                selectedFilter.state.leagues.forEach(league => {
                    const cb = leagueFiltersGrid.querySelector(`input.league-checkbox[value="${league}"]`);
                    if (cb) cb.checked = true;
                });
                selectedFilter.state.tips.forEach(tip => {
                    const btn = tipFiltersContainer.querySelector(`.tip-button[data-tip="${tip}"]`);
                    if (btn) btn.classList.add('active');
                });

                probabilitySliderEl.noUiSlider.set(selectedFilter.state.prob);
                oddsSliderEl.noUiSlider.set(selectedFilter.state.odds);
                filterDateStart.value = selectedFilter.state.startDate;
                filterDateEnd.value = selectedFilter.state.endDate;

                applyFiltersAndRender();
            };

            const handleDeleteFilter = async () => {
                if (!auth.currentUser) return;
                const selectedId = document.getElementById('saved-filters-select').value;
                if (!selectedId) {
                    showModal("Attenzione", "Seleziona una strategia da eliminare.", () => { });
                    return;
                }

                if (!confirm("Sei sicuro di voler eliminare questa strategia?")) return;

                try {
                    await deleteDoc(doc(db, "users", auth.currentUser.uid, "strategies", selectedId));
                    await loadSavedFilters(); // Reload list
                    // Reset filters
                    document.getElementById('saved-filters-select').value = "";
                    showModal("Successo", "Strategia eliminata.", () => { });
                } catch (e) {
                    console.error("Error deleting strategy:", e);
                    showModal("Errore", "Impossibile eliminare la strategia.", () => { });
                }
            };

            saveFilterBtn.addEventListener('click', handleSaveFilter);
            loadFilterBtn.addEventListener('click', handleLoadFilter);
            deleteFilterBtn.addEventListener('click', handleDeleteFilter);

            // ==================== RESET FILTERS ====================
            resetLeaguesBtn.addEventListener('click', () => {
                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                applyFiltersAndRender();
            });

            resetTipsBtn.addEventListener('click', () => {
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));
                applyFiltersAndRender();
            });

            resetFiltersBtn.addEventListener('click', () => {
                filterDateStart.value = '';
                filterDateEnd.value = '';
                searchInput.value = '';
                resetLeaguesBtn.click();
                resetTipsBtn.click();
                const probRange = probabilitySliderEl.noUiSlider.options.range;
                const oddsRange = oddsSliderEl.noUiSlider.options.range;
                probabilitySliderEl.noUiSlider.set([probRange.min, probRange.max]);
                oddsSliderEl.noUiSlider.set([oddsRange.min, oddsRange.max]);
                applyFiltersAndRender();
            });



            // ==================== TARGET ODDS SYSTEM ====================

            // Estrai odds da info_ht
            function extractHtOdds(infoHt) {
                if (!infoHt || infoHt.trim() === '') return null;

                const oddsMatch = infoHt.match(/@([\d.]+)/);
                if (oddsMatch) {
                    return parseFloat(oddsMatch[1]);
                }
                return null;
            }

            // Stima range odds basato su correlazioni
            function estimateOddsRange(tipAttuale, oddsAttuale, tipTarget) {
                // Trova range nella lookup table
                const correlations = ODDS_CORRELATIONS[tipAttuale]?.[tipTarget];
                if (!correlations) {
                    // Fallback: calcolo matematico
                    const probAttuale = 1 / oddsAttuale;
                    const probTarget = probAttuale * 0.70; // Stima conservativa
                    const oddsTarget = 1 / probTarget;

                    return {
                        min: Math.round((oddsTarget * 0.90) * 100) / 100,
                        max: Math.round((oddsTarget * 1.10) * 100) / 100,
                        avg: oddsTarget
                    };
                }

                // Cerca range corretto
                for (let range in correlations) {
                    const [minRange, maxRange] = range.split('-').map(Number);
                    if (oddsAttuale >= minRange && oddsAttuale <= maxRange) {
                        const [minOdds, maxOdds] = correlations[range];
                        return {
                            min: minOdds,
                            max: maxOdds,
                            avg: (minOdds + maxOdds) / 2
                        };
                    }
                }

                // Fallback se non trovato range esatto
                const probAttuale = 1 / oddsAttuale;
                const probTarget = probAttuale * 0.70;
                const oddsTarget = 1 / probTarget;

                return {
                    min: Math.round((oddsTarget * 0.90) * 100) / 100,
                    max: Math.round((oddsTarget * 1.10) * 100) / 100,
                    avg: oddsTarget
                };
            }

            // Ottieni odds target (reale o stimato)
            function getTargetOdds(match, tipTarget) {
                if (!tipTarget || tipTarget === '') {
                    // Nessun target specificato, usa tip attuale
                    return {
                        source: 'data',
                        odds: match.quota,
                        min: match.quota,
                        max: match.quota,
                        display: `@${match.quota.toFixed(2)}`,
                        isEstimate: false
                    };
                }

                // CASO 1: Target √® 0.5 HT - abbiamo dato reale!
                if (tipTarget === '0.5HT') {
                    const htOdds = extractHtOdds(match.info_ht);
                    if (htOdds) {
                        return {
                            source: 'data',
                            odds: htOdds,
                            min: htOdds,
                            max: htOdds,
                            display: `@${htOdds.toFixed(2)}`,
                            isEstimate: false
                        };
                    }
                    return null; // HT non disponibile
                }

                // CASO 2: Target √® stesso tip - abbiamo dato reale!
                if (tipTarget === match.tip) {
                    return {
                        source: 'data',
                        odds: match.quota,
                        min: match.quota,
                        max: match.quota,
                        display: `@${match.quota.toFixed(2)}`,
                        isEstimate: false
                    };
                }

                // CASO 3: Target diverso - usa lookup table (pi√π accurato)
                const estimate = estimateOddsRange(match.tip, match.quota, tipTarget);
                return {
                    source: 'estimate',
                    odds: estimate.avg,
                    min: estimate.min,
                    max: estimate.max,
                    display: `@${estimate.min.toFixed(2)}-${estimate.max.toFixed(2)}`,
                    isEstimate: true
                };
            }

            // Calcola green con odds precise
            function calculateGreen(backStake, backOdds, layOdds) {
                const liability = backStake * (layOdds - 1);
                const backProfit = backStake * (backOdds - 1);

                // Green se lay vince (back perde)
                const greenLay = liability;
                // Green se back vince (lay perde)
                const greenBack = backProfit - liability;

                // Usa il minore per essere conservativi
                return Math.min(greenLay, greenBack);
            }

            // Calcola green range con odds stimate
            function calculateGreenRange(backStake, backOdds, layOddsMin, layOddsMax) {
                const greenMin = calculateGreen(backStake, backOdds, layOddsMin);
                const greenMax = calculateGreen(backStake, backOdds, layOddsMax);

                return {
                    min: greenMin,
                    max: greenMax,
                    avg: (greenMin + greenMax) / 2
                };
            }

            // ==================== MATCH TIMES SYSTEM ====================

            // Carica cache orari da Firebase
            // Ottieni orario da API Football
            async function getTimeFromAPIFootball(date, teamHome, teamAway) {
                try {
                    const response = await fetch(`${API_FOOTBALL_URL}/fixtures?date=${date}&team=${teamHome}`, {
                        headers: {
                            'x-rapidapi-key': API_FOOTBALL_KEY,
                            'x-rapidapi-host': 'v3.api-football.com'
                        }
                    });

                    if (!response.ok) {
                        console.error("API Football error:", response.status);
                        return null;
                    }

                    const data = await response.json();

                    if (data.response && data.response.length > 0) {
                        // Cerca match che contiene entrambe le squadre
                        const match = data.response.find(m => {
                            const home = normalizeKey(m.teams.home.name);
                            const away = normalizeKey(m.teams.away.name);
                            const searchHome = normalizeKey(teamHome);
                            const searchAway = normalizeKey(teamAway);

                            return (home.includes(searchHome) || searchHome.includes(home)) &&
                                (away.includes(searchAway) || searchAway.includes(away));
                        });

                        if (match && match.fixture && match.fixture.date) {
                            // Converti UTC a ora italiana (UTC+1 o UTC+2)
                            const utcDate = new Date(match.fixture.date);
                            const italianTime = new Date(utcDate.getTime() + (2 * 60 * 60 * 1000)); // UTC+2 per ora solare

                            const hours = String(italianTime.getHours()).padStart(2, '0');
                            const minutes = String(italianTime.getMinutes()).padStart(2, '0');

                            return `${hours}:${minutes}`;
                        }
                    }

                    return null;
                } catch (e) {
                    console.error("API Football fetch error:", e);
                    return null;
                }
            }

            // Ottieni orario match (usa cache -> API)
            async function getMatchTime(date, match) {
                // 1. Prova cache Firebase
                const cached = getTimeFromCache(date, match);
                if (cached) return cached;

                // 2. Prova bulk cache (localStorage)
                const bulkTime = getTimeFromBulkCache(date, match);
                if (bulkTime) {
                    // Salva in cache Firebase per prossime volte
                    await saveTimeToCache(date, match, bulkTime);
                    return bulkTime;
                }

                // 3. Fallback: chiamata API singola (non dovrebbe servire)
                const teams = match.split(' - ');
                if (teams.length !== 2) return null;

                const teamHome = teams[0].trim();
                const teamAway = teams[1].trim();

                const time = await getTimeFromAPIFootball(date, teamHome, teamAway);

                if (time) {
                    await saveTimeToCache(date, match, time);
                }

                return time;
            }

            // ==================== POISSON ODDS CALCULATOR ====================

            // Calcola probabilit√† Poisson
            function poissonProbability(lambda, k) {
                let prob = Math.exp(-lambda);
                for (let i = 1; i <= k; i++) {
                    prob *= lambda / i;
                }
                return prob;
            }

            // Stima lambda da quota esistente
            function estimateLambda(tip, quota, prob) {
                // Usa probabilit√† reale per calcolo accurato
                const impliedProb = prob / 100;

                // Calcolo matematico basato su distribuzione Poisson
                if (tip === '+0.5') {
                    // P(X >= 1) = impliedProb
                    // Lambda = -ln(1 - impliedProb)
                    return -Math.log(1 - impliedProb);
                } else if (tip === '+1.5') {
                    // P(X >= 2) = impliedProb
                    // Approssimazione: lambda ‚âà 1.5 + (impliedProb - 0.5) * 3
                    const baseLambda = 2.0;
                    const adjustment = (impliedProb - 0.75) * 2;
                    return Math.max(1.5, Math.min(4.0, baseLambda + adjustment));
                } else if (tip === '+2.5') {
                    const baseLambda = 3.0;
                    const adjustment = (impliedProb - 0.60) * 2;
                    return Math.max(2.5, Math.min(5.0, baseLambda + adjustment));
                } else if (tip === '+3.5') {
                    const baseLambda = 4.0;
                    const adjustment = (impliedProb - 0.45) * 2;
                    return Math.max(3.5, Math.min(6.0, baseLambda + adjustment));
                }

                // Default fallback
                return 2.5;
            }

            // Calcola quota target con Poisson
            function calculatePoissonOdds(tipCurrent, quotaCurrent, probCurrent, tipTarget) {
                const lambda = estimateLambda(tipCurrent, quotaCurrent, probCurrent);

                let targetProb = 0;

                if (tipTarget === '+0.5') {
                    // P(X >= 1) = 1 - P(X = 0)
                    targetProb = 1 - poissonProbability(lambda, 0);
                } else if (tipTarget === '+1.5') {
                    // P(X >= 2) = 1 - P(X=0) - P(X=1)
                    targetProb = 1 - poissonProbability(lambda, 0) - poissonProbability(lambda, 1);
                } else if (tipTarget === '+2.5') {
                    // P(X >= 3)
                    targetProb = 1 - poissonProbability(lambda, 0) - poissonProbability(lambda, 1) - poissonProbability(lambda, 2);
                } else if (tipTarget === '+3.5') {
                    // P(X >= 4)
                    let sum = 0;
                    for (let k = 0; k <= 3; k++) {
                        sum += poissonProbability(lambda, k);
                    }
                    targetProb = 1 - sum;
                } else if (tipTarget === '-2.5') {
                    // P(X < 3) = P(X=0) + P(X=1) + P(X=2)
                    targetProb = poissonProbability(lambda, 0) + poissonProbability(lambda, 1) + poissonProbability(lambda, 2);
                }

                if (targetProb <= 0 || targetProb >= 1) return null;

                const targetOdds = 1 / targetProb;

                return {
                    odds: targetOdds,
                    prob: Math.round(targetProb * 100),
                    source: 'poisson'
                };
            }

            // ==================== AI TRADING ADVISOR ====================

            // V3.4.5.1 - BOLLINO BETFAIR INTELLIGENTE
            function generateBetfairBadge(match, is05HT = false, team1Stats = null, team2Stats = null) {
                const tip = (match.tip || '').trim().toUpperCase();
                const score = match.score || 0;

                // Estrai HT prob se disponibile
                let htProb = 0;
                if (match.info_ht && match.info_ht.trim() !== '') {
                    const htMatch = match.info_ht.match(/(\d+)%/);
                    if (htMatch) htProb = parseInt(htMatch[1]);
                }

                let betfairBadge = null;

                // SPECIALE: Filtro BEST 0.5 HT ‚Üí Badge dinamico basato su prolificit√†
                if (is05HT && htProb >= 70 && score >= 50 && team1Stats && team2Stats) {
                    // Calcola prolificit√† media squadre per Over 2.5
                    const team1Over25 = team1Stats.total >= 5 ? (team1Stats.count / team1Stats.total) * 100 : 0;
                    const team2Over25 = team2Stats.total >= 5 ? (team2Stats.count / team2Stats.total) * 100 : 0;
                    const avgProlificita = (team1Over25 + team2Over25) / 2;

                    // Badge dinamico basato su prolificit√†
                    if (avgProlificita >= 75) {
                        betfairBadge = {
                            text: 'Betfair Back Over 2.5',
                            color: 'bg-yellow-100 text-yellow-700 border-yellow-300'
                        };
                    } else if (avgProlificita >= 60) {
                        betfairBadge = {
                            text: 'Betfair Back Over 1.5',
                            color: 'bg-yellow-100 text-yellow-700 border-yellow-300'
                        };
                    } else if (avgProlificita < 50 && avgProlificita >= 30) {
                        betfairBadge = {
                            text: 'Betfair Lay Under 2.5',
                            color: 'bg-yellow-100 text-yellow-700 border-yellow-300'
                        };
                    }
                    // Se < 30% o 50-60% ‚Üí nessun badge (poco affidabile)
                }
                // OVER con HT alto + score buono ‚Üí Back Over 2.5
                else if (tip.startsWith('+') && htProb >= 70 && score >= 35) {
                    betfairBadge = {
                        text: 'Betfair Back Over 2.5',
                        color: 'bg-purple-100 text-purple-700 border-purple-300'
                    };
                }
                // OVER con squadre molto prolifiche ‚Üí Back Over 2.5
                else if (tip.startsWith('+') && score >= 45) {
                    betfairBadge = {
                        text: 'Betfair Back Over 2.5',
                        color: 'bg-purple-100 text-purple-700 border-purple-300'
                    };
                }
                // UNDER con score buono ‚Üí Lay Over 2.5
                else if (tip.startsWith('-') && score >= 40) {
                    betfairBadge = {
                        text: 'Betfair Lay Over 2.5',
                        color: 'bg-purple-100 text-purple-700 border-purple-300'
                    };
                }
                // 1X2 / DC equilibrata ‚Üí Lay The Draw
                else if ((tip.includes('X') || tip.includes('12')) && score >= 30) {
                    betfairBadge = {
                        text: 'Betfair Lay The Draw',
                        color: 'bg-purple-100 text-purple-700 border-purple-300'
                    };
                }

                return betfairBadge;
            }

            // ==================== TOOLTIP SYSTEM ====================

            function generateScoreTooltip(match, scoreDetails) {
                return `
                    <div class="text-left">
                        <div class="font-bold mb-2 text-center">SCORE BREAKDOWN</div>
                        <div class="text-sm space-y-1">
                            <div>Lega: <span class="font-semibold">+${scoreDetails.legaScore || 0}</span></div>
                            <div>Tip: <span class="font-semibold">+${scoreDetails.tipScore || 0}</span></div>
                            <div>Prob: <span class="font-semibold">+${scoreDetails.probScore || 0}</span> (${match.probabilita}%)</div>
                            ${scoreDetails.htBonus ? `<div>HT Boost: <span class="font-semibold text-green-600">+${scoreDetails.htBonus}</span></div>` : ''}
                            <div class="border-t pt-1 mt-1">Totale: <span class="font-bold text-lg">${scoreDetails.totalScore || 0}</span></div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t text-gray-600">
                            <div>80+ = ECCELLENTE üî•</div>
                            <div>60-79 = BUONO ‚ö°</div>
                            <div>40-59 = MEDIO üí°</div>
                            <div>&lt;40 = BASSO ‚ö†Ô∏è</div>
                        </div>
                    </div>
                `;
            }

            function generateStatsTooltip(homeWins, awayWins) {
                const homeColor = homeWins >= 7 ? 'üü¢' : homeWins >= 4 ? 'üü°' : 'üî¥';
                const awayColor = awayWins >= 7 ? 'üü¢' : awayWins >= 4 ? 'üü°' : 'üî¥';

                return `
                    <div class="text-left">
                        <div class="font-bold mb-2 text-center">FORM SQUADRE</div>
                        <div class="text-sm space-y-1">
                            <div>${homeColor} Casa: <span class="font-semibold">${homeWins} W</span> ultimi 10</div>
                            <div>${awayColor} Trasferta: <span class="font-semibold">${awayWins} W</span> ultimi 10</div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t text-gray-600">
                            <div>üü¢ 7+ = OTTIMA</div>
                            <div>üü° 4-6 = MEDIA</div>
                            <div>üî¥ 0-3 = SCARSA</div>
                        </div>
                    </div>
                `;
            }

            // ==================== HT MERGE FUNCTIONS ====================
            function normalizeKey(str) {
                // Normalizza stringa per matching squadre (rimuove accenti, lowercase, solo alfanumerici)
                return str.normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "")
                    .toLowerCase()
                    .replace(/[^a-z0-9]/g, "");
            }

            function mergeMainWithHT() {
                // Se non ho dati main, non posso fare merge
                if (rawMainData.length === 0) return rawMainData;

                // Se non ho dati HT, ritorno main senza modifiche
                if (rawHtData.length === 0) return rawMainData;

                // Creo mappa HT: chiave = squadre normalizzate
                const htMap = {};
                rawHtData.forEach(htRow => {
                    const partita = String(htRow.Partita || '').trim();
                    if (!partita) return;

                    // Normalizzo nome partita (Home + Away senza spazi/accenti)
                    const normalized = normalizeKey(partita);

                    // Salvo prob e quota HT
                    const probHT = parseInt(String(htRow['Probabilit√†'] || htRow.Probabilit√† || '0').replace('%', '').trim()) || 0;
                    const quotaHT = parseFloat(String(htRow.Quota || '0').replace(',', '.').trim()) || 0;

                    if (probHT > 0 && quotaHT > 0) {
                        htMap[normalized] = { prob: probHT, quota: quotaHT.toFixed(2) };
                    }
                });

                // Arricchisco Main con info HT
                return rawMainData.map(mainRow => {
                    const partita = String(mainRow.Partita || '').trim();
                    const normalized = normalizeKey(partita);

                    // Cerco match in HT map
                    if (htMap[normalized]) {
                        const htInfo = htMap[normalized];
                        mainRow.info_ht = `${htInfo.prob}% (@${htInfo.quota})`;
                    } else {
                        mainRow.info_ht = '';
                    }

                    return mainRow;
                });
            }




            // ==================== RANKING ====================

            // v3.5.3: State globale per visualizzazione ranking (DEVE essere qui!)
            let currentRankingView = 'by-tip'; // 'by-tip' o 'by-time'
            let currentRankingData = null; // Salva dati ranking per toggle

            document.getElementById('generate-ranking-btn').addEventListener('click', async () => {
                const rankingDate = document.getElementById('ranking-date').value;
                const maxMatches = parseInt(document.getElementById('ranking-max-matches').value);
                const selectedFilterId = document.getElementById('ranking-filter-select').value;

                if (!rankingDate) {
                    alert('Seleziona data!');
                    return;
                }

                const resultsContainer = document.getElementById('ranking-results');
                resultsContainer.innerHTML = '<div class="bg-white p-6 rounded-xl shadow text-center"><div class="animate-pulse text-lg">üîÑ Generazione ranking... <br><span class="text-sm text-gray-500">(Recupero orari in corso...)</span></div></div>';

                try {
                    // Partite del giorno senza risultato
                    let todayMatches = allMatches.filter(m => m.data === rankingDate && !m.risultato);

                    // APPLICA FILTRO SE SELEZIONATO
                    let filterName = "Tutte le partite";

                    // FILTRO SPECIALE: BEST 0.5 HT
                    if (selectedFilterId === 'BEST_05HT') {
                        filterName = "‚ö° BEST 0.5 HT (Auto)";

                        todayMatches = todayMatches.filter(m => {
                            // Requisito 1: HT prob disponibile e >= 70%
                            if (!m.info_ht || m.info_ht.trim() === '') return false;
                            const htMatch = m.info_ht.match(/(\d+)%/);
                            if (!htMatch) return false;
                            const htProb = parseInt(htMatch[1]);
                            if (htProb < 70) return false;

                            // Requisito 2: Tip Over (squadre prolifiche)
                            if (!m.tip.startsWith('+')) return false;

                            return true;
                        });
                    }
                    // FILTRI NORMALI
                    else if (selectedFilterId) {
                        const selectedFilter = savedFilters.find(f => f.id === selectedFilterId);
                        if (selectedFilter) {
                            filterName = selectedFilter.name;
                            const filterState = selectedFilter.state;

                            // Applica filtri
                            todayMatches = todayMatches.filter(m => {
                                // Filtro leghe
                                if (filterState.leagues && filterState.leagues.length > 0) {
                                    if (!filterState.leagues.includes(m.lega)) return false;
                                }

                                // Filtro tips
                                if (filterState.tips && filterState.tips.length > 0) {
                                    if (!filterState.tips.includes(m.tip)) return false;
                                }

                                // Filtro probabilit√†
                                if (filterState.prob) {
                                    const [minProb, maxProb] = filterState.prob.map(v => parseInt(v));
                                    if (m.probabilita < minProb || m.probabilita > maxProb) return false;
                                }

                                // Filtro odds
                                if (filterState.odds) {
                                    const [minOdds, maxOdds] = filterState.odds.map(v => parseFloat(v));
                                    if (m.quota < minOdds || m.quota > maxOdds) return false;
                                }

                                return true;
                            });
                        }
                    }

                    if (todayMatches.length === 0) {
                        resultsContainer.innerHTML = '<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita per quella data con i filtri selezionati!</div>';
                        return;
                    }

                    const leaguePerformance = analyzeLeaguePerformance(allMatches);

                    // Calcola score per tutte le partite
                    const rankedMatches = todayMatches.map(m => {
                        // Se filtro BEST 0.5 HT, usa score speciale
                        const score = selectedFilterId === 'BEST_05HT'
                            ? calculateScore05HT(m, allMatches)
                            : calculateScore(m, new Set([m.lega.toLowerCase()]), new Set([m.tip]), leaguePerformance, allMatches);
                        return {
                            ...m,
                            score: score.totalScore,
                            scoreDetails: score // Salva dettagli per tooltip
                        };
                    }).filter(m => m.score > 0); // Solo partite con score > 0

                    if (rankedMatches.length === 0) {
                        resultsContainer.innerHTML = `<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita disponibile con i filtri selezionati</div>`;
                        return;
                    }

                    // Raggruppa per tip
                    const byTip = {};
                    rankedMatches.forEach(m => {
                        if (!byTip[m.tip]) byTip[m.tip] = [];
                        byTip[m.tip].push(m);
                    });

                    // Ordina ogni gruppo per score
                    Object.keys(byTip).forEach(tip => {
                        byTip[tip].sort((a, b) => b.score - a.score);
                        byTip[tip] = byTip[tip].slice(0, maxMatches);
                    });

                    // CARICA ORARI da Firebase cache temporanea
                    const allRankedMatches = Object.values(byTip).flat();
                    let loadedTimes = 0;

                    for (let match of allRankedMatches) {
                        const ora = await getTimeFromCache(match.data, match.partita);
                        if (ora) {
                            match.time = ora;
                            loadedTimes++;
                        }
                    }

                    console.log(`[CACHE] Orari recuperati: ${loadedTimes}/${allRankedMatches.length}`);

                    if (loadedTimes === 0) {
                        console.log('[INFO] Nessun orario in cache. Carica CSV con colonna "Ora".');
                    }
                    if (loadedTimes > 0) {
                        console.log(`Loaded ${loadedTimes} match times for ranking`);
                    }

                    // SALVA DATI PER TRACKING
                    lastGeneratedRanking = {
                        timestamp: new Date().toISOString(),
                        data_partite: rankingDate,
                        filtro_nome: filterName,
                        filtro_id: selectedFilterId || null,
                        partite_by_tip: {},
                        stats: {
                            totale_partite: rankedMatches.length,
                            tips_count: Object.keys(byTip).length
                        }
                    };

                    // Organizza partite per tip
                    Object.keys(byTip).forEach(tip => {
                        lastGeneratedRanking.partite_by_tip[tip] = byTip[tip].map(m => ({
                            partita: m.partita,
                            lega: m.lega,
                            tip: m.tip,
                            mercato: m.mercato,
                            quota: m.quota,
                            probabilita: m.probabilita,
                            score: m.score,
                            esito: null // Verr√† aggiornato quando carichi risultati
                        }));
                    });

                    // v3.5.3: Salva dati per toggle visualizzazione
                    currentRankingData = {
                        byTip,
                        rankingDate,
                        filterName,
                        rankedMatches,
                        todayMatches,
                        selectedFilterId,
                        maxMatches
                    };

                    // v3.5.3: Render default (per tip)
                    currentRankingView = 'by-tip';
                    renderRankingByTip(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId, maxMatches);

                } catch (e) {
                    console.error('Error:', e);
                    resultsContainer.innerHTML = `<div class="bg-red-50 p-6 rounded-xl text-center">‚ùå Errore: ${e.message}</div>`;
                }
            });

            // ==================== v3.5.3: VISUALIZZAZIONE RANKING & ORDINAMENTO ====================

            // v3.5.3: Funzione setup tooltip listeners (riattiva dopo re-render)
            function setupTooltipListeners() {
                // Tooltip gi√† gestiti da event delegation globale nel codice esistente
                // Questa funzione √® placeholder per compatibilit√†
            }

            // Funzione render ranking per tip (default)
            function renderRankingByTip(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId, maxMatches) {
                const resultsContainer = document.getElementById('ranking-results');
                const toggleContainer = document.getElementById('ranking-view-toggle');

                // Mostra toggle
                toggleContainer.classList.remove('hidden');

                // Render tip blocks (codice esistente)
                const tipBlocks = Object.keys(byTip).sort().map(tip => {
                    const matches = byTip[tip];
                    const sectionTitle = selectedFilterId === 'BEST_05HT' ? '‚ö° BEST 0.5 HT' : `üìä ${tip}`;
                    const sectionSubtitle = selectedFilterId === 'BEST_05HT'
                        ? `${matches.length} partite selezionate automaticamente`
                        : `${matches.length} partite (max ${maxMatches} per tip)`;

                    return `
                        <div class="bg-white p-6 rounded-xl shadow mb-6">
                            <h3 class="text-2xl font-bold mb-3">${sectionTitle}</h3>
                            <div class="text-sm text-gray-600 mb-4">${sectionSubtitle}</div>
                            <div class="space-y-3">
                                ${matches.map((m, idx) => renderMatchCard(m, idx, selectedFilterId)).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                resultsContainer.innerHTML = `
                    <div class="mb-6 bg-gradient-to-r from-purple-500 to-blue-500 text-white p-6 rounded-xl shadow">
                        <h2 class="text-3xl font-bold mb-2">üèÜ Ranking ${rankingDate}</h2>
                        <div class="text-lg mb-1">üìä Filtro: <span class="font-bold">${filterName}</span></div>
                        <div class="text-sm opacity-90 mb-3">
                            ‚úÖ ${rankedMatches.length} partite totali su ${todayMatches.length} filtrate ‚Ä¢ ${Object.keys(byTip).length} tip diverse
                        </div>
                        <button id="save-ranking-btn" class="bg-white text-purple-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                            <i class="fa-solid fa-save mr-2"></i>Salva Ranking per Tracking ML
                        </button>
                        <button id="export-csv-btn" class="bg-white text-blue-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md">
                            <i class="fa-solid fa-download mr-2"></i>Esporta CSV Strategie
                        </button>
                    </div>
                    ${tipBlocks}
                `;

                // Re-attach event listeners
                document.getElementById('save-ranking-btn').addEventListener('click', saveRankingForTracking);
                document.getElementById('export-csv-btn').addEventListener('click', exportRankingCSV);

                // Riattiva tooltips
                setupTooltipListeners();
            }

            // Funzione render ranking per orario
            function renderRankingByTime(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId) {
                const resultsContainer = document.getElementById('ranking-results');
                const toggleContainer = document.getElementById('ranking-view-toggle');

                // Mostra toggle
                toggleContainer.classList.remove('hidden');

                // Flatten e ordina per orario
                const allMatches = Object.values(byTip).flat();
                const matchesByTime = {};

                allMatches.forEach(m => {
                    const timeKey = m.time && m.time.trim() !== '' ? m.time : '‚è∞ Orario non disponibile';
                    if (!matchesByTime[timeKey]) matchesByTime[timeKey] = [];
                    matchesByTime[timeKey].push(m);
                });

                // Ordina keys per orario
                const sortedTimes = Object.keys(matchesByTime).sort((a, b) => {
                    if (a === '‚è∞ Orario non disponibile') return 1;
                    if (b === '‚è∞ Orario non disponibile') return -1;
                    return a.localeCompare(b);
                });

                const timeBlocks = sortedTimes.map(time => {
                    const matches = matchesByTime[time];
                    // Ordina per score dentro ogni orario
                    matches.sort((a, b) => b.score - a.score);

                    return `
                        <div class="bg-white p-6 rounded-xl shadow mb-6">
                            <h3 class="text-2xl font-bold mb-3">‚è∞ ${time}</h3>
                            <div class="text-sm text-gray-600 mb-4">${matches.length} partite</div>
                            <div class="space-y-3">
                                ${matches.map((m, idx) => renderMatchCard(m, idx, selectedFilterId, true)).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                resultsContainer.innerHTML = `
                    <div class="mb-6 bg-gradient-to-r from-purple-500 to-blue-500 text-white p-6 rounded-xl shadow">
                        <h2 class="text-3xl font-bold mb-2">üèÜ Ranking ${rankingDate}</h2>
                        <div class="text-lg mb-1">üìä Filtro: <span class="font-bold">${filterName}</span></div>
                        <div class="text-sm opacity-90 mb-3">
                            ‚úÖ ${rankedMatches.length} partite totali su ${todayMatches.length} filtrate
                        </div>
                        <button id="save-ranking-btn" class="bg-white text-purple-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                            <i class="fa-solid fa-save mr-2"></i>Salva Ranking per Tracking ML
                        </button>
                        <button id="export-csv-btn" class="bg-white text-blue-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md">
                            <i class="fa-solid fa-download mr-2"></i>Esporta CSV Strategie
                        </button>
                    </div>
                    ${timeBlocks}
                `;

                // Re-attach event listeners
                document.getElementById('save-ranking-btn').addEventListener('click', saveRankingForTracking);
                document.getElementById('export-csv-btn').addEventListener('click', exportRankingCSV);

                // Riattiva tooltips
                setupTooltipListeners();
            }

            // Funzione render singola card match (riutilizzabile)
            function renderMatchCard(m, idx, selectedFilterId, showTip = false) {
                const [team1, team2] = m.partita.split(' - ');
                const team1Stats = analyzeTeamStats(team1, true, m.tip, allMatches);
                const team2Stats = analyzeTeamStats(team2, false, m.tip, allMatches);

                // HT indicator
                let htIndicator = '';
                if (m.info_ht && m.info_ht.trim() !== '') {
                    const probMatch = m.info_ht.match(/(\d+)%/);
                    if (probMatch) {
                        const htProb = parseInt(probMatch[1]);
                        if (htProb >= 70) {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-green-100 text-green-700 px-2 py-1 rounded font-bold">‚ö° HT: ${m.info_ht}</span></div>`;
                        } else if (htProb >= 55) {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-yellow-100 text-yellow-700 px-2 py-1 rounded">üí° HT: ${m.info_ht}</span></div>`;
                        } else {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-gray-100 text-gray-600 px-2 py-1 rounded">üìä HT: ${m.info_ht}</span></div>`;
                        }
                    }
                }

                // Betfair badge
                const betfairBadge = generateBetfairBadge(m, selectedFilterId === 'BEST_05HT', team1Stats, team2Stats);
                let betfairDisplay = '';
                if (betfairBadge) {
                    const icon = selectedFilterId === 'BEST_05HT' ? '‚ö°' : 'üü£';
                    betfairDisplay = `<div class="mt-2"><span class="px-3 py-1 rounded-full text-xs font-bold border ${betfairBadge.color}">${icon} ${betfairBadge.text}</span></div>`;
                }

                // Formato display TIP FT
                const tipDisplay = showTip ? `${m.tip} FT` : `${m.tip} FT`;

                return `
                    <div class="border rounded-lg p-4 ${(m.score || 0) < 30 ? 'bg-red-50 border-red-200' : 'bg-white hover:bg-gray-50'}">
                        <div class="flex justify-between items-start mb-3">
                            <div class="flex-1">
                                <div class="flex justify-between items-start">
                                    <div class="font-bold text-lg">
                                        ${idx + 1}. 
                                        <span class="team-${team1Stats.color}">${team1}</span>
                                        - 
                                        <span class="team-${team2Stats.color}">${team2}</span>
                                    </div>
                                </div>
                                <div class="text-sm text-gray-600 flex items-center gap-2">
                                    ${m.time && m.time.trim() !== '' ? `<span class="text-gray-900 font-bold">‚è∞ ${m.time}</span> | ` : ''}
                                    ${m.lega}
                                </div>
                                <div class="text-sm mt-1">
                                    <span class="bg-blue-100 px-2 py-1 rounded text-xs font-semibold">${tipDisplay}</span>
                                    <span class="ml-2 font-bold">@${m.quota.toFixed(2)}</span>
                                    <span class="ml-2 text-gray-500">${m.probabilita}%</span>
                                </div>
                                ${htIndicator}
                            </div>
                            <div class="text-right">
                                <div class="score-badge">${m.score || 0}</div>
                                <div class="text-xs text-gray-500 mt-1 relative inline-block">
                                    <span class="tooltip-trigger cursor-help"
                                          data-tooltip-type="stats"
                                          data-mercato="${m.mercato || ''}"
                                          data-tip="${m.tip || ''}"
                                          data-home-count="${team1Stats.count || 0}"
                                          data-home-total="${team1Stats.total || 0}"
                                          data-away-count="${team2Stats.count || 0}"
                                          data-away-total="${team2Stats.total || 0}"
                                          data-home-perc="${team1Stats.percentage || 0}"
                                          data-away-perc="${team2Stats.percentage || 0}"
                                          data-home-penalty="${team1Stats.penalty || 0}"
                                          data-away-penalty="${team2Stats.penalty || 0}"
                                          data-home-score="${team1Stats.scoreValue || 0}"
                                          data-away-score="${team2Stats.scoreValue || 0}"
                                          data-home-details="${team1Stats.details || ''}"
                                          data-away-details="${team2Stats.details || ''}">
                                        ${team1Stats.stats} | ${team2Stats.stats}
                                    </span>
                                    <span class="ml-1 text-blue-500 cursor-help tooltip-trigger"
                                          data-tooltip-type="stats"
                                          data-mercato="${m.mercato || ''}"
                                          data-tip="${m.tip || ''}"
                                          data-home-count="${team1Stats.count || 0}"
                                          data-home-total="${team1Stats.total || 0}"
                                          data-away-count="${team2Stats.count || 0}"
                                          data-away-total="${team2Stats.total || 0}"
                                          data-home-perc="${team1Stats.percentage || 0}"
                                          data-away-perc="${team2Stats.percentage || 0}"
                                          data-home-penalty="${team1Stats.penalty || 0}"
                                          data-away-penalty="${team2Stats.penalty || 0}"
                                          data-home-score="${team1Stats.scoreValue || 0}"
                                          data-away-score="${team2Stats.scoreValue || 0}"
                                          data-home-details="${team1Stats.details || ''}"
                                          data-away-details="${team2Stats.details || ''}"
                                          title="Hover per dettagli">
                                        ‚ÑπÔ∏è
                                    </span>
                                </div>
                            </div>
                        </div>
                        ${betfairDisplay}
                        ${(m.score || 0) < 30 ? '<div class="mt-2"><span class="bg-red-500 text-white text-xs px-2 py-1 rounded font-bold">‚ö†Ô∏è Score Basso - Poco Affidabile</span></div>' : ''}
                    </div>
                `;
            }

            // Event listeners toggle visualizzazione ranking
            document.addEventListener('click', (e) => {
                if (e.target.id === 'view-by-tip-btn' || e.target.closest('#view-by-tip-btn')) {
                    if (currentRankingView === 'by-tip') return;
                    currentRankingView = 'by-tip';

                    // Update buttons
                    document.getElementById('view-by-tip-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white';
                    document.getElementById('view-by-time-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300';

                    // Re-render
                    if (currentRankingData) {
                        renderRankingByTip(
                            currentRankingData.byTip,
                            currentRankingData.rankingDate,
                            currentRankingData.filterName,
                            currentRankingData.rankedMatches,
                            currentRankingData.todayMatches,
                            currentRankingData.selectedFilterId,
                            currentRankingData.maxMatches
                        );
                    }
                } else if (e.target.id === 'view-by-time-btn' || e.target.closest('#view-by-time-btn')) {
                    if (currentRankingView === 'by-time') return;
                    currentRankingView = 'by-time';

                    // Update buttons
                    document.getElementById('view-by-tip-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300';
                    document.getElementById('view-by-time-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white';

                    // Re-render
                    if (currentRankingData) {
                        renderRankingByTime(
                            currentRankingData.byTip,
                            currentRankingData.rankingDate,
                            currentRankingData.filterName,
                            currentRankingData.rankedMatches,
                            currentRankingData.todayMatches,
                            currentRankingData.selectedFilterId
                        );
                    }
                }
            });

            // Funzione export CSV ranking
            function exportRankingCSV() {
                if (!currentRankingData) return;

                const csvData = [];
                csvData.push(['Data', 'Lega', 'Partita', 'Tip', 'Quota', 'Prob%', 'HT', 'Ora', 'Score', 'Betfair'].join(','));

                Object.keys(currentRankingData.byTip).forEach(tip => {
                    currentRankingData.byTip[tip].forEach(m => {
                        const [team1, team2] = m.partita.split(' - ');
                        const team1Stats = analyzeTeamStats(team1, true, m.tip, allMatches);
                        const team2Stats = analyzeTeamStats(team2, false, m.tip, allMatches);
                        const betfairBadge = generateBetfairBadge(m, currentRankingData.selectedFilterId === 'BEST_05HT', team1Stats, team2Stats);
                        const betfairText = betfairBadge ? betfairBadge.text : 'N/A';
                        const htInfo = m.info_ht || '-';
                        const time = m.time || '-';

                        csvData.push([
                            m.data,
                            `"${m.lega}"`,
                            `"${m.partita}"`,
                            m.tip,
                            m.quota.toFixed(2),
                            m.probabilita,
                            htInfo,
                            time,
                            m.score,
                            betfairText
                        ].join(','));
                    });
                });

                const csvContent = csvData.join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `ranking_${currentRankingData.rankingDate}_${currentRankingData.filterName.replace(/\s+/g, '_')}.csv`;
                link.click();
            }

            // Ordinamento Dashboard
            document.getElementById('dashboard-sort-select')?.addEventListener('change', (e) => {
                const sortBy = e.target.value;
                applyFiltersAndRender(sortBy);
            });

            // ==================== STORICO PREVISIONI ====================

            // Carica previsioni per data specifica
            async function loadStorico(date) {
                const storicoList = document.getElementById('storico-strategie-list');
                const storicoContainer = document.getElementById('storico-strategie-container');
                const storicoDateTitle = document.getElementById('storico-date-title');
                const storicoCount = document.getElementById('storico-count');
                const storicoDettaglio = document.getElementById('storico-dettaglio');
                const storicoStatsGlobali = document.getElementById('storico-stats-globali');

                storicoList.classList.remove('hidden');
                storicoDettaglio.classList.add('hidden');
                storicoStatsGlobali.classList.add('hidden');
                storicoContainer.innerHTML = '<div class="text-center py-4"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento...</div>';

                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    const q = query(rankingHistoryCol, where("data_partite", "==", date));
                    const snapshot = await getDocs(q);

                    if (snapshot.empty) {
                        storicoDateTitle.textContent = `Previsioni del ${date}`;
                        storicoCount.textContent = 'Nessuna previsione salvata';
                        storicoContainer.innerHTML = `
                            <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('data')">DATA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                            <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('lega')">LEGA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                            <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('partita')">PARTITA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                            <!-- Mercato Removed -->
                            <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('tip')">TIP <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                            <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('quota')">QUOTA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                            <th class="p-3 text-center cursor-pointer hover:bg-gray-100 w-48" onclick="updateSort('info_ht')">HT <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th> <!-- Expanded HT -->
                            <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('esito')">ESITO <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                            </div>
                        `;
                        return;
                    }

                    const rankings = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                    storicoDateTitle.innerHTML = `Previsioni del ${date} <button id="delete-date-btn" class="ml-3 bg-red-500 hover:bg-red-600 text-white text-sm px-3 py-1 rounded" title="Cancella tutte le strategie di questa giornata"><i class="fa-solid fa-trash mr-1"></i>Cancella Giornata</button>`;
                    storicoCount.textContent = `${rankings.length} strategie salvate`;

                    // Event listener cancella giornata
                    document.getElementById('delete-date-btn').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (!confirm(`‚ö†Ô∏è ATTENZIONE!\n\nVuoi cancellare TUTTE le ${rankings.length} strategie del ${date}?\n\nQuesta azione √® IRREVERSIBILE e pu√≤ influenzare il machine learning futuro.`)) return;

                        try {
                            const batch = [];
                            for (const ranking of rankings) {
                                const docRef = doc(db, "ranking_history", ranking.id);
                                batch.push(deleteDoc(docRef));
                            }
                            await Promise.all(batch);

                            showModal("‚úÖ Cancellato!", `Tutte le ${rankings.length} strategie del ${date} sono state eliminate.`, () => {
                                // Ricarica storico
                                storicoList.classList.add('hidden');
                            });
                        } catch (e) {
                            showModal("Errore", `Errore cancellazione: ${e.message}`, () => { });
                        }
                    });

                    // Calcola stats per ogni strategia
                    const strategieCards = rankings.map(ranking => {
                        const allPartite = Object.values(ranking.partite_by_tip).flat();
                        const vinte = allPartite.filter(p => p.esito === 'Vinto').length;
                        const perse = allPartite.filter(p => p.esito === 'Perso').length;
                        const pending = allPartite.filter(p => !p.esito || p.esito === 'PENDING').length;
                        const totConEsito = vinte + perse;
                        const winRate = totConEsito > 0 ? Math.round((vinte / totConEsito) * 100) : null;

                        // Determina icona e colore
                        let icon = 'üìä';
                        let bgClass = 'bg-gray-50 hover:bg-gray-100';
                        let borderClass = 'border-gray-200';

                        if (ranking.magic_type === 'singole') {
                            icon = 'üéØ';
                            bgClass = 'bg-green-50 hover:bg-green-100';
                            borderClass = 'border-green-300';
                        } else if (ranking.magic_type === 'trading') {
                            icon = 'üìà';
                            bgClass = 'bg-blue-50 hover:bg-blue-100';
                            borderClass = 'border-blue-300';
                        }

                        // Stats badge
                        let statsBadge = '';
                        if (totConEsito > 0) {
                            const winColor = winRate >= 70 ? 'bg-green-500' : winRate >= 50 ? 'bg-yellow-500' : 'bg-red-500';
                            statsBadge = `
                                <div class="flex items-center gap-2 mt-2">
                                    <span class="text-green-600 font-bold">${vinte}W</span>
                                    <span class="text-red-600 font-bold">${perse}L</span>
                                    ${pending > 0 ? `<span class="text-gray-500">${pending}P</span>` : ''}
                                    <span class="${winColor} text-white text-xs px-2 py-1 rounded-full font-bold">${winRate}%</span>
                                </div>
                            `;
                        } else if (pending > 0) {
                            statsBadge = `<div class="text-sm text-gray-500 mt-2"><i class="fa-solid fa-clock mr-1"></i>${pending} partite in attesa risultati</div>`;
                        }

                        return `
                            <div class="p-4 rounded-lg border-2 ${borderClass} ${bgClass} transition-all storico-strategia-card" 
                                 data-ranking-id="${ranking.id}">
                                <div class="flex justify-between items-start">
                                    <div class="flex-1 cursor-pointer storico-card-clickable">
                                        <div class="flex items-center gap-2">
                                            <span class="text-2xl">${icon}</span>
                                            <div>
                                                <div class="font-bold text-lg">${ranking.filtro_nome}</div>
                                                <div class="text-sm text-gray-600">${allPartite.length} partite</div>
                                            </div>
                                        </div>
                                        ${statsBadge}
                                    </div>
                                    <div class="flex flex-col items-end gap-2">
                                        <button class="delete-strategy-btn text-red-500 hover:text-red-700 hover:bg-red-50 p-2 rounded" 
                                                data-strategy-id="${ranking.id}"
                                                data-strategy-name="${ranking.filtro_nome}"
                                                title="Cancella questa strategia">
                                            <i class="fa-solid fa-trash"></i>
                                        </button>
                                        <div class="text-xs text-gray-500">${new Date(ranking.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}</div>
                                        <div class="cursor-pointer text-gray-400 hover:text-gray-600"><i class="fa-solid fa-chevron-right"></i></div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    storicoContainer.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">${strategieCards}</div>`;

                    // Event listeners per click area principale card
                    document.querySelectorAll('.storico-card-clickable').forEach(clickArea => {
                        clickArea.addEventListener('click', () => {
                            const card = clickArea.closest('.storico-strategia-card');
                            const rankingId = card.dataset.rankingId;
                            const ranking = rankings.find(r => r.id === rankingId);
                            if (ranking) showStoricoDettaglio(ranking);
                        });
                    });

                    // Event listeners per pulsanti cancella strategia
                    document.querySelectorAll('.delete-strategy-btn').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            const strategyId = btn.dataset.strategyId;
                            const strategyName = btn.dataset.strategyName;

                            if (!confirm(`‚ö†Ô∏è Cancellare la strategia "${strategyName}"?\n\nQuesta azione √® irreversibile e pu√≤ influenzare il ML futuro.`)) return;

                            try {
                                const docRef = doc(db, "ranking_history", strategyId);
                                await deleteDoc(docRef);

                                showModal("‚úÖ Cancellato!", `Strategia "${strategyName}" eliminata.`, () => {
                                    // Ricarica la data
                                    loadStorico(date);
                                });
                            } catch (e) {
                                showModal("Errore", `Errore cancellazione: ${e.message}`, () => { });
                            }
                        });
                    });

                    // Mostra stats globali se ci sono risultati
                    showStoricoStatsGlobali(rankings);

                } catch (e) {
                    console.error('Storico Error:', e);
                    storicoContainer.innerHTML = `<div class="text-center py-4 text-red-600">Errore: ${e.message}</div>`;
                }
            }

            // Mostra dettaglio strategia
            function showStoricoDettaglio(ranking) {
                const dettaglioEl = document.getElementById('storico-dettaglio');
                dettaglioEl.classList.remove('hidden');

                // Scroll to dettaglio
                dettaglioEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

                // Determina icona
                let icon = 'üìä';
                let gradientClass = 'from-gray-500 to-gray-600';
                if (ranking.magic_type === 'singole') {
                    icon = 'üéØ';
                    gradientClass = 'from-green-500 to-emerald-600';
                } else if (ranking.magic_type === 'trading') {
                    icon = 'üìà';
                    gradientClass = 'from-blue-500 to-indigo-600';
                }

                // Costruisci lista partite per tip
                const tipSections = Object.keys(ranking.partite_by_tip).map(tip => {
                    const partite = ranking.partite_by_tip[tip];

                    const partiteRows = partite.map(p => {
                        let esitoClass = 'bg-gray-100 text-gray-600';
                        let esitoIcon = '‚è≥';
                        let esitoBorder = 'border-gray-200';

                        if (p.esito === 'Vinto') {
                            esitoClass = 'bg-green-100 text-green-700';
                            esitoIcon = '‚úÖ';
                            esitoBorder = 'border-green-300';
                        } else if (p.esito === 'Perso') {
                            esitoClass = 'bg-red-100 text-red-700';
                            esitoIcon = '‚ùå';
                            esitoBorder = 'border-red-300';
                        }

                        return `
                            <div class="p-3 rounded-lg border ${esitoBorder} ${esitoClass} mb-2">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-bold">${p.partita}</div>
                                        <div class="text-xs opacity-75">${p.lega}</div>
                                        ${p.risultato ? `<div class="text-sm font-bold mt-1">‚öΩ Risultato: ${p.risultato}</div>` : ''}
                                    </div>
                                    <div class="text-right">
                                        <div class="text-lg">${esitoIcon}</div>
                                        <div class="text-xs">Tip: ${p.tip} @${p.quota?.toFixed(2) || '-'}</div>
                                        <div class="text-xs">Prob: ${p.probabilita || '-'}%</div>
                                        <div class="text-xs font-bold">Score: ${p.score || '-'}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    // Stats per tip
                    const vinte = partite.filter(p => p.esito === 'Vinto').length;
                    const perse = partite.filter(p => p.esito === 'Perso').length;
                    const pending = partite.filter(p => !p.esito || p.esito === 'PENDING').length;

                    return `
                        <div class="mb-6">
                            <div class="flex justify-between items-center mb-3">
                                <h4 class="text-lg font-bold">${tip}</h4>
                                <div class="text-sm">
                                    <span class="text-green-600 font-bold">${vinte}W</span> / 
                                    <span class="text-red-600 font-bold">${perse}L</span>
                                    ${pending > 0 ? ` / <span class="text-gray-500">${pending}P</span>` : ''}
                                </div>
                            </div>
                            ${partiteRows}
                        </div>
                    `;
                }).join('');

                // Stats totali
                const allPartite = Object.values(ranking.partite_by_tip).flat();
                const totVinte = allPartite.filter(p => p.esito === 'Vinto').length;
                const totPerse = allPartite.filter(p => p.esito === 'Perso').length;
                const totPending = allPartite.filter(p => !p.esito || p.esito === 'PENDING').length;
                const totConEsito = totVinte + totPerse;
                const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                dettaglioEl.innerHTML = `
                    <div class="bg-gradient-to-r ${gradientClass} text-white p-4 rounded-t-xl">
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="text-2xl mr-2">${icon}</span>
                                <span class="text-xl font-bold">${ranking.filtro_nome}</span>
                            </div>
                            <button id="close-dettaglio-btn" class="bg-white/20 hover:bg-white/30 px-3 py-1 rounded-lg text-sm">
                                <i class="fa-solid fa-times mr-1"></i>Chiudi
                            </button>
                        </div>
                        <div class="mt-2 text-sm opacity-90">
                            üìÖ ${ranking.data_partite} ‚Ä¢ ${allPartite.length} partite ‚Ä¢ 
                            Salvato alle ${new Date(ranking.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}
                        </div>
                        ${winRate !== null ? `
                            <div class="mt-3 flex items-center gap-4">
                                <span class="bg-white/20 px-3 py-1 rounded-lg">
                                    <span class="font-bold">${totVinte}</span> Vinte
                                </span>
                                <span class="bg-white/20 px-3 py-1 rounded-lg">
                                    <span class="font-bold">${totPerse}</span> Perse
                                </span>
                                <span class="bg-white text-gray-800 px-3 py-1 rounded-lg font-bold">
                                    ${winRate}% Win Rate
                                </span>
                            </div>
                        ` : totPending > 0 ? `
                            <div class="mt-3 text-sm">
                                <i class="fa-solid fa-clock mr-1"></i>${totPending} partite in attesa risultati
                            </div>
                        ` : ''}
                    </div>
                    <div class="bg-white rounded-b-xl shadow-md border border-gray-200 p-4">
                        ${tipSections}
                    </div>
                `;

                // Close button
                document.getElementById('close-dettaglio-btn').addEventListener('click', () => {
                    dettaglioEl.classList.add('hidden');
                });
            }

            // Stats globali per tutte le strategie della data
            function showStoricoStatsGlobali(rankings) {
                const statsEl = document.getElementById('storico-stats-globali');
                const statsContent = document.getElementById('storico-stats-content');

                // Calcola totali
                let totPartite = 0;
                let totVinte = 0;
                let totPerse = 0;
                let totPending = 0;

                rankings.forEach(r => {
                    const partite = Object.values(r.partite_by_tip).flat();
                    totPartite += partite.length;
                    totVinte += partite.filter(p => p.esito === 'Vinto').length;
                    totPerse += partite.filter(p => p.esito === 'Perso').length;
                    totPending += partite.filter(p => !p.esito || p.esito === 'PENDING').length;
                });

                const totConEsito = totVinte + totPerse;
                const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                if (totConEsito === 0) {
                    statsEl.classList.add('hidden');
                    return;
                }

                statsEl.classList.remove('hidden');

                const winRateColor = winRate >= 70 ? 'text-green-600' : winRate >= 50 ? 'text-yellow-600' : 'text-red-600';

                statsContent.innerHTML = `
                    <div class="bg-blue-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold text-blue-600">${totPartite}</div>
                        <div class="text-sm text-gray-600">Partite Totali</div>
                    </div>
                    <div class="bg-green-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold text-green-600">${totVinte}</div>
                        <div class="text-sm text-gray-600">Vinte</div>
                    </div>
                    <div class="bg-red-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold text-red-600">${totPerse}</div>
                        <div class="text-sm text-gray-600">Perse</div>
                    </div>
                    <div class="bg-purple-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold ${winRateColor}">${winRate}%</div>
                        <div class="text-sm text-gray-600">Win Rate</div>
                    </div>
                `;
            }

            // Carica ultime N giornate
            async function loadUltimeGiornate(n = 10) {
                const storicoList = document.getElementById('storico-strategie-list');
                const storicoContainer = document.getElementById('storico-strategie-container');
                const storicoDateTitle = document.getElementById('storico-date-title');
                const storicoCount = document.getElementById('storico-count');
                const storicoDettaglio = document.getElementById('storico-dettaglio');
                const storicoStatsGlobali = document.getElementById('storico-stats-globali');

                storicoList.classList.remove('hidden');
                storicoDettaglio.classList.add('hidden');
                storicoStatsGlobali.classList.add('hidden');
                storicoContainer.innerHTML = '<div class="text-center py-4"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento ultime giornate...</div>';

                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    const snapshot = await getDocs(rankingHistoryCol);

                    if (snapshot.empty) {
                        storicoDateTitle.textContent = 'Storico Completo';
                        storicoCount.textContent = 'Nessuna previsione salvata';
                        storicoContainer.innerHTML = `
                            <div class="text-center py-8 text-gray-500">
                                <i class="fa-solid fa-inbox text-4xl mb-3"></i>
                                <p>Nessuna previsione salvata nel sistema.</p>
                            </div>
                        `;
                        return;
                    }

                    // Raggruppa per data
                    const byDate = {};
                    snapshot.docs.forEach(doc => {
                        const data = doc.data();
                        const date = data.data_partite;
                        if (!byDate[date]) byDate[date] = [];
                        byDate[date].push({ id: doc.id, ...data });
                    });

                    // Ordina date e prendi ultime N
                    const sortedDates = Object.keys(byDate).sort().reverse().slice(0, n);

                    storicoDateTitle.textContent = `Ultime ${sortedDates.length} Giornate`;
                    storicoCount.textContent = `${snapshot.docs.length} strategie totali`;

                    // Costruisci cards per data
                    const dateCards = sortedDates.map(date => {
                        const rankings = byDate[date];

                        // Stats aggregate per data
                        let totVinte = 0, totPerse = 0, totPending = 0;
                        rankings.forEach(r => {
                            const partite = Object.values(r.partite_by_tip).flat();
                            totVinte += partite.filter(p => p.esito === 'Vinto').length;
                            totPerse += partite.filter(p => p.esito === 'Perso').length;
                            totPending += partite.filter(p => !p.esito || p.esito === 'PENDING').length;
                        });

                        const totConEsito = totVinte + totPerse;
                        const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                        let statsBadge = '';
                        if (winRate !== null) {
                            const winColor = winRate >= 70 ? 'bg-green-500' : winRate >= 50 ? 'bg-yellow-500' : 'bg-red-500';
                            statsBadge = `<span class="${winColor} text-white text-xs px-2 py-1 rounded-full font-bold ml-2">${winRate}%</span>`;
                        } else if (totPending > 0) {
                            statsBadge = `<span class="bg-gray-400 text-white text-xs px-2 py-1 rounded-full ml-2">Pending</span>`;
                        }

                        return `
                            <div class="p-4 rounded-lg border-2 border-gray-200 bg-gray-50 hover:bg-gray-100 cursor-pointer transition-all storico-date-card" 
                                 data-date="${date}">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-bold text-lg">üìÖ ${date} ${statsBadge}</div>
                                        <div class="text-sm text-gray-600">${rankings.length} strategie</div>
                                    </div>
                                    <div class="text-gray-400">
                                        <i class="fa-solid fa-chevron-right"></i>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    storicoContainer.innerHTML = `<div class="space-y-3">${dateCards}</div>`;

                    // Event listeners
                    document.querySelectorAll('.storico-date-card').forEach(card => {
                        card.addEventListener('click', () => {
                            const date = card.dataset.date;
                            document.getElementById('storico-date').value = date;
                            loadStorico(date);
                        });
                    });

                } catch (e) {
                    console.error('Storico Error:', e);
                    storicoContainer.innerHTML = `<div class="text-center py-4 text-red-600">Errore: ${e.message}</div>`;
                }
            }



            // ==================== RANKING TRACKING & ML ====================
            async function saveRankingForTracking() {
                if (!lastGeneratedRanking) {
                    showModal("Errore", "Nessun ranking da salvare!", () => { });
                    return;
                }

                try {
                    const rankingHistoryCol = collection(db, "ranking_history");

                    // CONTROLLO SE ESISTE GI√Ä un ranking con stessa data + stesso filtro
                    const q = query(rankingHistoryCol,
                        where("data_partite", "==", lastGeneratedRanking.data_partite),
                        where("filtro_nome", "==", lastGeneratedRanking.filtro_nome)
                    );
                    const snapshot = await getDocs(q);

                    if (!snapshot.empty) {
                        // SOVRASCRIVI il documento esistente
                        const docId = snapshot.docs[0].id;
                        const docRef = doc(db, "ranking_history", docId);
                        await setDoc(docRef, lastGeneratedRanking);

                        // v3.5.0: Refresh immediato storico dopo salvataggio
                        const currentDate = document.getElementById('storico-data-picker')?.value;
                        if (currentDate) {
                            await loadStorico(currentDate);
                        }

                        showModal("‚úÖ Aggiornato!", `Ranking aggiornato (sovrascritto)!\nData: ${lastGeneratedRanking.data_partite}\nFiltro: ${lastGeneratedRanking.filtro_nome}\nPartite: ${lastGeneratedRanking.stats.totale_partite}`, () => { });
                    } else {
                        // CREA NUOVO documento
                        await addDoc(rankingHistoryCol, lastGeneratedRanking);

                        // v3.5.0: Refresh immediato storico dopo salvataggio
                        const currentDate = document.getElementById('storico-data-picker')?.value;
                        if (currentDate) {
                            await loadStorico(currentDate);
                        }

                        showModal("‚úÖ Salvato!", `Ranking salvato per tracking ML!\nData: ${lastGeneratedRanking.data_partite}\nFiltro: ${lastGeneratedRanking.filtro_nome}\nPartite: ${lastGeneratedRanking.stats.totale_partite}`, () => { });
                    }

                    // Disabilita bottone dopo salvataggio
                    const btn = document.getElementById('save-ranking-btn');
                    if (btn) {
                        btn.disabled = true;
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                        btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Ranking Salvato';
                    }
                } catch (e) {
                    showModal("Errore", `Errore salvataggio: ${e.message}`, () => { });
                }
            }

            async function updateRankingResults(uploadedDate, uploadedMatches) {
                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    const q = query(rankingHistoryCol, where("data_partite", "==", uploadedDate));
                    const snapshot = await getDocs(q);

                    if (snapshot.empty) {
                        return null; // Nessun ranking salvato per quella data
                    }

                    let totalUpdated = 0;
                    const performanceByFilter = {};

                    for (const docSnap of snapshot.docs) {
                        const ranking = docSnap.data();
                        let updated = false;

                        // Per ogni tip nel ranking
                        Object.keys(ranking.partite_by_tip).forEach(tip => {
                            ranking.partite_by_tip[tip].forEach(partitaRanking => {
                                // Trova match corrispondente nei risultati caricati
                                const match = uploadedMatches.find(m =>
                                    m.partita === partitaRanking.partita &&
                                    m.tip === partitaRanking.tip &&
                                    m.risultato
                                );

                                if (match && match.esito) {
                                    partitaRanking.esito = match.esito;
                                    partitaRanking.risultato = match.risultato;
                                    updated = true;
                                    totalUpdated++;
                                }
                            });
                        });

                        if (updated) {
                            // Calcola performance
                            let totalMatches = 0;
                            let wonMatches = 0;

                            Object.keys(ranking.partite_by_tip).forEach(tip => {
                                ranking.partite_by_tip[tip].forEach(p => {
                                    if (p.esito) {
                                        totalMatches++;
                                        if (p.esito === 'Vinto') wonMatches++;
                                    }
                                });
                            });

                            const winrate = totalMatches > 0 ? Math.round((wonMatches / totalMatches) * 100) : 0;
                            ranking.performance = {
                                totale: totalMatches,
                                vinte: wonMatches,
                                perse: totalMatches - wonMatches,
                                winrate: winrate
                            };

                            // Aggiorna su Firestore
                            await setDoc(doc(db, "ranking_history", docSnap.id), ranking);

                            performanceByFilter[ranking.filtro_nome] = ranking.performance;
                        }
                    }

                    return {
                        updated: totalUpdated,
                        performance: performanceByFilter
                    };
                } catch (e) {
                    console.error("Error updating ranking results:", e);
                    return null;
                }
            }

            // ==================== RANKING FUNCTIONS ====================
            // V3.4.5 - SCORE SPECIALE PER 0.5 HT
            function calculateScore05HT(partita, dbCompleto) {
                let score = 0;

                // Estrai HT prob
                let htProb = 0;
                if (partita.info_ht && partita.info_ht.trim() !== '') {
                    const htMatch = partita.info_ht.match(/(\d+)%/);
                    if (htMatch) htProb = parseInt(htMatch[1]);
                }

                // PESO 1: HT Probability (50% del score)
                if (htProb >= 85) score += 50;
                else if (htProb >= 80) score += 45;
                else if (htProb >= 75) score += 40;
                else if (htProb >= 70) score += 35;
                else if (htProb >= 65) score += 25;

                // PESO 2: Prolificit√† squadre Over 1.5 (30% del score)
                const teams = partita.partita.split(' - ');
                if (teams.length === 2 && dbCompleto && dbCompleto.length > 0) {
                    const teamHome = teams[0].trim();
                    const teamAway = teams[1].trim();

                    const homeStats = analyzeTeamStats(teamHome, true, '+1.5', dbCompleto);
                    const awayStats = analyzeTeamStats(teamAway, false, '+1.5', dbCompleto);

                    if (homeStats.total >= 5 && awayStats.total >= 5) {
                        const homePerc = (homeStats.count / homeStats.total) * 100;
                        const awayPerc = (awayStats.count / awayStats.total) * 100;
                        const avgPerc = (homePerc + awayPerc) / 2;

                        if (avgPerc >= 75) score += 30;
                        else if (avgPerc >= 65) score += 25;
                        else if (avgPerc >= 55) score += 20;
                        else if (avgPerc >= 45) score += 15;
                        else score += 10;
                    }
                }

                // PESO 3: Orario favorevole (20% del score - bonus)
                if (partita.time) {
                    const [hours] = partita.time.split(':').map(Number);
                    if (hours >= 17 && hours <= 22) score += 20; // Orario prime time
                    else if (hours >= 14 && hours <= 23) score += 10; // Orario buono
                }

                return {
                    teamBonus: score,
                    totalScore: Math.min(100, score),
                    quotaValid: true,
                    htProb: htProb
                };
            }

            function calculateScore(partita, legheSet, tipsSet, leaguePerformance = {}, dbCompleto = null) {
                // v3.5.0 - SCORE DA SCOREVALUE: usa direttamente score calcolato da analyzeTeamStats

                let score = 0;
                const tipNorm = (partita.tip || '').trim().toUpperCase();
                const mercato = (partita.mercato || '').toLowerCase().trim();

                // Se non ho DB, score 0
                if (!dbCompleto || dbCompleto.length === 0 || !partita.partita) {
                    return {
                        teamBonus: 0,
                        totalScore: 0,
                        quotaValid: true
                    };
                }

                const teams = partita.partita.split(' - ');
                if (teams.length !== 2) {
                    return {
                        teamBonus: 0,
                        totalScore: 0,
                        quotaValid: true
                    };
                }

                const teamHome = teams[0].trim();
                const teamAway = teams[1].trim();

                // Analizza statistiche squadre
                const homeStats = analyzeTeamStats(teamHome, true, tipNorm, dbCompleto);
                const awayStats = analyzeTeamStats(teamAway, false, tipNorm, dbCompleto);

                // ========== OVER/UNDER (+1.5, +2.5, -2.5, etc) ==========
                if (tipNorm.startsWith('+') || tipNorm.startsWith('-')) {
                    // Usa scoreValue DIRETTO da analyzeTeamStats
                    // Media dei due score
                    const avgScore = (homeStats.scoreValue + awayStats.scoreValue) / 2;
                    score = Math.round(avgScore);

                    // BOOST HT se disponibile (solo per OVER)
                    if (tipNorm.startsWith('+') && partita.info_ht && partita.info_ht.trim() !== '') {
                        const probMatch = partita.info_ht.match(/(\d+)%/);
                        if (probMatch) {
                            const htProb = parseInt(probMatch[1]);
                            if (htProb >= 75) score += 15;
                            else if (htProb >= 65) score += 10;
                            else if (htProb >= 55) score += 5;
                        }
                    }

                    // PENALIT√Ä HT alto (solo per UNDER)
                    if (tipNorm.startsWith('-') && partita.info_ht && partita.info_ht.trim() !== '') {
                        const probMatch = partita.info_ht.match(/(\d+)%/);
                        if (probMatch) {
                            const htProb = parseInt(probMatch[1]);
                            if (htProb >= 75) score -= 15;
                            else if (htProb >= 65) score -= 10;
                        }
                    }

                    return {
                        teamBonus: score,
                        totalScore: Math.max(0, Math.min(100, score)),
                        quotaValid: true
                    };
                }

                // ========== 1X2 / Doppia Chance ==========
                // Usa scoreValue DIRETTO da analyzeTeamStats
                const avgScore = (homeStats.scoreValue + awayStats.scoreValue) / 2;
                score = Math.round(avgScore);

                return {
                    teamBonus: score,
                    totalScore: Math.max(0, Math.min(100, score)),
                    quotaValid: true
                };
            }

            // ==================== CALCULATE SCORE 0.5 HT ====================

            function analyzeLeaguePerformance(dbCompleto) {
                if (!dbCompleto || dbCompleto.length === 0) return {};

                const leagueStats = {};

                dbCompleto.forEach(match => {
                    const lega = (match.lega || '').toLowerCase().trim();
                    if (!lega) return;

                    if (!leagueStats[lega]) {
                        leagueStats[lega] = {
                            totalMatches: 0,
                            over25Count: 0,
                            under25Count: 0,
                            tips: {}
                        };
                    }

                    leagueStats[lega].totalMatches++;

                    const risultato = match.risultato || '';
                    const golMatch = risultato.match(/(\d+)\s*-\s*(\d+)/);

                    let golTotali = 0;
                    if (golMatch) {
                        const golCasa = parseInt(golMatch[1]);
                        const golTrasferta = parseInt(golMatch[2]);
                        golTotali = golCasa + golTrasferta;

                        if (golTotali > 2.5) leagueStats[lega].over25Count++;
                        else leagueStats[lega].under25Count++;
                    }

                    const tip = (match.tip || '').trim();
                    if (tip) {
                        if (!leagueStats[lega].tips[tip]) {
                            leagueStats[lega].tips[tip] = { total: 0, success: 0 };
                        }

                        leagueStats[lega].tips[tip].total++;

                        let success = false;
                        if (golMatch) {
                            const golCasa = parseInt(golMatch[1]);
                            const golTrasferta = parseInt(golMatch[2]);
                            const golTotali = golCasa + golTrasferta;

                            // 1X2
                            if (tip === '1') success = golCasa > golTrasferta;
                            else if (tip === 'X') success = golCasa === golTrasferta;
                            else if (tip === '2') success = golCasa < golTrasferta;

                            // Doppia Chance
                            else if (tip === '1X') success = golCasa >= golTrasferta;
                            else if (tip === 'X2') success = golCasa <= golTrasferta;
                            else if (tip === '12') success = golCasa !== golTrasferta;

                            // Gol/No Gol
                            else if (tip === 'S√¨') success = golCasa > 0 && golTrasferta > 0;
                            else if (tip === 'No') success = golCasa === 0 || golTrasferta === 0;

                            // Over/Under
                            else if (tip.startsWith('+')) {
                                const soglia = parseFloat(tip.substring(1));
                                success = golTotali > soglia;
                            } else if (tip.startsWith('-')) {
                                const soglia = parseFloat(tip.substring(1));
                                success = golTotali < soglia;
                            }
                        }

                        if (success) leagueStats[lega].tips[tip].success++;
                    }
                });

                Object.keys(leagueStats).forEach(lega => {
                    const stats = leagueStats[lega];
                    stats.over25Percentage = (stats.over25Count / stats.totalMatches * 100).toFixed(0);
                    stats.under25Percentage = (stats.under25Count / stats.totalMatches * 100).toFixed(0);

                    let totalTips = 0;
                    let totalSuccess = 0;

                    Object.keys(stats.tips).forEach(tip => {
                        const tipStats = stats.tips[tip];
                        tipStats.successRate = (tipStats.success / tipStats.total * 100).toFixed(0);

                        totalTips += tipStats.total;
                        totalSuccess += tipStats.success;
                    });

                    stats.overallWinrate = totalTips > 0 ? (totalSuccess / totalTips * 100).toFixed(0) : 0;
                });

                return leagueStats;
            }

            function analyzeTeamStats(teamName, isHome, tip, dbCompleto) {
                if (!dbCompleto || dbCompleto.length === 0) {
                    return { color: 'black', stats: '', count: 0, total: 0, percentage: 0, penalty: 0, scoreValue: 0, details: '' };
                }

                const teamNorm = teamName.toLowerCase().trim();

                // v3.5.0 NUOVA LOGICA: Calcolo preciso score + penalit√†
                const isOverUnder = tip.startsWith('+') || tip.startsWith('-');

                let relevantMatches = [];

                // Filtra match ultimi 6 mesi con risultato
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

                if (isOverUnder) {
                    // OVER/UNDER: Tutti i match della squadra (ultimi 15)
                    const allTeamMatches = dbCompleto.filter(row => {
                        if (!row.risultato || row.risultato.trim() === '') return false;

                        const matchDate = new Date(row.data || '2000-01-01');
                        if (matchDate < sixMonthsAgo) return false;

                        const team1 = (row.partita || '').split(' - ')[0]?.toLowerCase().trim() || '';
                        const team2 = (row.partita || '').split(' - ').slice(1).join(' - ')?.toLowerCase().trim() || '';
                        return (team1 === teamNorm || team2 === teamNorm);
                    });

                    allTeamMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                    relevantMatches = allTeamMatches.slice(0, 15);

                } else {
                    // 1X2/DC: Match casa o trasferta (ultimi 5)
                    let locationMatches = dbCompleto.filter(row => {
                        if (!row.risultato || row.risultato.trim() === '') return false;

                        const matchDate = new Date(row.data || '2000-01-01');
                        if (matchDate < sixMonthsAgo) return false;

                        const team1 = (row.partita || '').split(' - ')[0]?.toLowerCase().trim() || '';
                        const team2 = (row.partita || '').split(' - ').slice(1).join(' - ')?.toLowerCase().trim() || '';

                        if (isHome) return team1 === teamNorm;
                        else return team2 === teamNorm;
                    });

                    locationMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                    relevantMatches = locationMatches.slice(0, 5); // Solo ultimi 5 per 1X2/DC
                }

                // Minimo match richiesti
                const minMatches = isOverUnder ? 5 : 3;
                if (relevantMatches.length < minMatches) {
                    return {
                        color: 'gray',
                        stats: `(${relevantMatches.length})`,
                        count: 0,
                        total: relevantMatches.length,
                        percentage: 0,
                        penalty: 0,
                        scoreValue: 0,
                        details: `Dati insufficienti (min ${minMatches})`
                    };
                }

                let successCount = 0;
                let penalty = 0;
                let detailsArray = [];

                relevantMatches.forEach(match => {
                    const risultato = match.risultato || '';
                    const golMatch = risultato.match(/(\d+)\s*-\s*(\d+)/);

                    if (!golMatch) return;

                    const golCasa = parseInt(golMatch[1]);
                    const golTrasferta = parseInt(golMatch[2]);
                    const golTotali = golCasa + golTrasferta;

                    const team1 = (match.partita || '').split(' - ')[0]?.toLowerCase().trim() || '';
                    const isTeamHome = team1 === teamNorm;

                    let success = false;

                    if (tip.startsWith('+')) {
                        // OVER: conta gol totali > soglia
                        const soglia = parseFloat(tip.substring(1));
                        success = golTotali > soglia;

                        // Penalit√† -5 per ogni 0-0
                        if (golCasa === 0 && golTrasferta === 0) {
                            penalty += 5;
                            detailsArray.push(`0-0 (-5 pen)`);
                        }

                    } else if (tip.startsWith('-')) {
                        // UNDER: conta gol totali < soglia
                        const soglia = parseFloat(tip.substring(1));
                        success = golTotali < soglia;

                        // Penalit√† -5 per ogni 4+ gol (se Under 3.5)
                        if (soglia <= 3.5 && golTotali >= 4) {
                            penalty += 5;
                            detailsArray.push(`${golCasa}-${golTrasferta} 4+ gol (-5 pen)`);
                        }

                    } else if (tip === '1') {
                        // Casa vince (Tip 1)
                        if (isHome && isTeamHome) {
                            // Casa FAVORITA: conta vittorie
                            success = golCasa > golTrasferta;
                        } else if (!isHome && !isTeamHome) {
                            // Trasferta SFAVORITA: conta sconfitte
                            success = golTrasferta < golCasa;
                        }

                    } else if (tip === 'X') {
                        // Pareggio (Tip X)
                        // Entrambe contano pareggi
                        success = golCasa === golTrasferta;

                    } else if (tip === '2') {
                        // Trasferta vince (Tip 2)
                        if (!isHome && !isTeamHome) {
                            // Trasferta FAVORITA: conta vittorie
                            success = golTrasferta > golCasa;
                        } else if (isHome && isTeamHome) {
                            // Casa SFAVORITA: conta sconfitte
                            success = golCasa < golTrasferta;
                        }

                    } else if (tip === '1X') {
                        // Casa o Pareggio (Tip 1X)
                        if (isHome && isTeamHome) {
                            // Casa FAVORITA: conta non-sconfitte (V+P)
                            success = golCasa >= golTrasferta;
                        } else if (!isHome && !isTeamHome) {
                            // Trasferta SFAVORITA: conta sconfitte + pareggi (NON vittorie)
                            // Logica: vogliamo che NON vinca
                            success = golTrasferta <= golCasa;
                        }

                    } else if (tip === '12') {
                        // Casa o Trasferta (no pareggio) (Tip 12)
                        // Entrambe contano SOLO vittorie
                        const isVittoria = (isHome && isTeamHome && golCasa > golTrasferta) ||
                            (!isHome && !isTeamHome && golTrasferta > golCasa);
                        success = isVittoria;

                        // Penalit√† -5 per ogni pareggio
                        if (golCasa === golTrasferta) {
                            penalty += 5;
                            detailsArray.push(`${golCasa}-${golTrasferta} pareggio (-5 pen)`);
                        }

                    } else if (tip === 'X2') {
                        // Pareggio o Trasferta (Tip X2)
                        if (!isHome && !isTeamHome) {
                            // Trasferta FAVORITA: conta non-sconfitte (V+P)
                            success = golTrasferta >= golCasa;
                        } else if (isHome && isTeamHome) {
                            // Casa SFAVORITA: conta sconfitte + pareggi (NON vittorie)
                            // Logica: vogliamo che NON vinca
                            success = golCasa <= golTrasferta;
                        }
                    }

                    if (success) successCount++;
                });

                // Calcola percentuale ESATTA
                const percentage = relevantMatches.length > 0 ? (successCount / relevantMatches.length) * 100 : 0;

                // Score value = percentuale - penalit√†
                const scoreValue = Math.max(0, Math.round(percentage - penalty));

                // Colore basato su score finale
                let color = 'black';
                if (relevantMatches.length >= minMatches) {
                    if (scoreValue >= 70) color = 'green';
                    else if (scoreValue >= 50) color = 'yellow';
                    else color = 'red';
                }

                // Details string
                const details = detailsArray.length > 0 ? detailsArray.join(', ') : '';

                return {
                    color: color,
                    stats: `(${successCount}/${relevantMatches.length})`,
                    count: successCount,
                    total: relevantMatches.length,
                    percentage: Math.round(percentage),
                    penalty: penalty,
                    scoreValue: scoreValue,
                    details: details
                };
            }

            // ==================== MODAL ====================
            function showModal(title, message, onConfirm) {
                document.getElementById('modal-title').textContent = title;
                document.getElementById('modal-message').textContent = message;
                const modal = document.getElementById('modal');
                modal.classList.remove('hidden');
                modal.classList.add('flex');

                document.getElementById('modal-confirm').onclick = () => {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                    onConfirm();
                };

                document.getElementById('modal-cancel').onclick = () => {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                };
            }

        });

        // ==================== TOOLTIP SYSTEM ====================

        // Crea elemento tooltip
        const tooltipEl = document.createElement('div');
        tooltipEl.id = 'custom-tooltip';
        tooltipEl.className = 'fixed bg-gray-900 text-white text-xs rounded-lg p-3 shadow-xl pointer-events-none z-[9999] max-w-xs';
        tooltipEl.style.display = 'none';
        document.body.appendChild(tooltipEl);

        // Mostra tooltip - VERSIONE USER-FRIENDLY v3.3
        function showTooltipCustom(element, type) {
            const rect = element.getBoundingClientRect();
            let content = '';

            if (type === 'score') {
                const score = element.dataset.score || '0';
                const legaScore = parseInt(element.dataset.legaScore) || 0;
                const tipScore = parseInt(element.dataset.tipScore) || 0;
                const probScore = parseInt(element.dataset.probScore) || 0;
                const teamBonus = parseInt(element.dataset.teamBonus) || 0;
                const htBonus = parseInt(element.dataset.htBonus) || 0;

                // Genera spiegazione user-friendly
                const reasons = [];

                if (legaScore >= 15) reasons.push('üèÜ <strong>Lega top</strong> per questo mercato');
                else if (legaScore >= 10) reasons.push('üèÜ Lega con buono storico');
                else if (legaScore >= 5) reasons.push('üèÜ Lega nella media');

                if (tipScore >= 15) reasons.push('‚úÖ <strong>Tip molto affidabile</strong> (storico >70%)');
                else if (tipScore >= 10) reasons.push('‚úÖ Tip affidabile');

                if (probScore >= 20) reasons.push('üìä <strong>Prob. eccellente</strong> (>80%)');
                else if (probScore >= 15) reasons.push('üìä Prob. alta (>75%)');
                else if (probScore >= 10) reasons.push('üìä Prob. buona (>70%)');

                if (teamBonus >= 20) reasons.push('‚öΩ <strong>Squadre molto prolifiche</strong>');
                else if (teamBonus >= 10) reasons.push('‚öΩ Squadre con buona tendenza gol');
                else if (teamBonus < 0) reasons.push('‚ö†Ô∏è Squadre poco prolifiche');

                if (htBonus >= 10) reasons.push('üî• <strong>HT molto alto</strong> - gol probabile 1¬∞T');
                else if (htBonus >= 5) reasons.push('üí° HT buono');
                else if (htBonus < 0) reasons.push('‚ö†Ô∏è HT sfavorevole per questa tip');

                content = `
                    <div class="font-bold mb-2 text-center text-base">üìä PERCH√â SCORE ${score}</div>
                    <div class="space-y-2">
                        ${reasons.length > 0 ? reasons.map(r => `<div>${r}</div>`).join('') : '<div>Score nella media</div>'}
                    </div>
                    <div class="text-xs mt-3 pt-2 border-t border-gray-700 opacity-75 text-center">
                        <div>üî• 65+ = TOP | ‚ö° 50-64 = BUONO</div>
                        <div>üí° 30-49 = MEDIO | ‚ö†Ô∏è <30 = SKIP</div>
                    </div>
                `;
            } else if (type === 'stats') {
                const mercato = element.dataset.mercato || '';
                const tip = element.dataset.tip || '';
                const homeCount = parseInt(element.dataset.homeCount) || 0;
                const homeTotal = parseInt(element.dataset.homeTotal) || 0;
                const awayCount = parseInt(element.dataset.awayCount) || 0;
                const awayTotal = parseInt(element.dataset.awayTotal) || 0;

                // v3.5.0: Dati estesi da analyzeTeamStats
                const homePerc = parseInt(element.dataset.homePerc) || (homeTotal > 0 ? Math.round((homeCount / homeTotal) * 100) : 0);
                const awayPerc = parseInt(element.dataset.awayPerc) || (awayTotal > 0 ? Math.round((awayCount / awayTotal) * 100) : 0);
                const homePenalty = parseInt(element.dataset.homePenalty) || 0;
                const awayPenalty = parseInt(element.dataset.awayPenalty) || 0;
                const homeScore = parseInt(element.dataset.homeScore) || 0;
                const awayScore = parseInt(element.dataset.awayScore) || 0;
                const homeDetails = element.dataset.homeDetails || '';
                const awayDetails = element.dataset.awayDetails || '';

                const homeColor = homePerc >= 70 ? 'üü¢' : homePerc >= 50 ? 'üü°' : 'üî¥';
                const awayColor = awayPerc >= 70 ? 'üü¢' : awayPerc >= 50 ? 'üü°' : 'üî¥';

                // Per mercato GOL mostra tendenza gol
                if (mercato.toLowerCase().includes('gol') || mercato.toLowerCase().includes('goal') || tip.startsWith('+') || tip.startsWith('-')) {
                    const tipLabel = tip.startsWith('+') ? `Over ${tip.substring(1)}` : tip.startsWith('-') ? `Under ${tip.substring(1)}` : tip;

                    // Valutazione complessiva
                    const avgScore = (homeScore + awayScore) / 2;
                    let verdict = '';
                    if (avgScore >= 70) verdict = '<div class="text-green-400 font-bold mt-2">‚úÖ OTTIMA AFFIDABILIT√Ä</div>';
                    else if (avgScore >= 50) verdict = '<div class="text-yellow-400 mt-2">üí° AFFIDABILIT√Ä MEDIA</div>';
                    else verdict = '<div class="text-red-400 mt-2">‚ö†Ô∏è BASSA AFFIDABILIT√Ä</div>';

                    content = `
                        <div class="font-bold mb-2 text-center">‚öΩ ${tipLabel} - DETTAGLIO PRECISO</div>
                        <div class="space-y-2 text-xs">
                            <div class="border-b border-gray-700 pb-1">
                                ${homeColor} <strong>Casa:</strong> ${homeCount}/${homeTotal} match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${homePerc}%
                                    ${homePenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${homePenalty} punti` : ''}
                                    ${homeDetails ? `<br>‚Ä¢ ${homeDetails}` : ''}
                                    <br>‚Ä¢ <strong>Score finale: ${homeScore}</strong>
                                </div>
                            </div>
                            <div class="pb-1">
                                ${awayColor} <strong>Trasferta:</strong> ${awayCount}/${awayTotal} match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${awayPerc}%
                                    ${awayPenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${awayPenalty} punti` : ''}
                                    ${awayDetails ? `<br>‚Ä¢ ${awayDetails}` : ''}
                                    <br>‚Ä¢ <strong>Score finale: ${awayScore}</strong>
                                </div>
                            </div>
                        </div>
                        ${verdict}
                        <div class="text-xs mt-2 pt-2 border-t border-gray-700 opacity-75">
                            <div><strong>Score medio partita: ${Math.round(avgScore)}</strong></div>
                            <div class="mt-1">70+ = TOP | 50-69 = BUONO | <50 = SKIP</div>
                        </div>
                    `;
                } else {
                    // Per 1X2/Doppia Chance
                    const avgScore = (homeScore + awayScore) / 2;

                    content = `
                        <div class="font-bold mb-2 text-center">üìà ${tip} - FORMA DETTAGLIATA</div>
                        <div class="space-y-2 text-xs">
                            <div class="border-b border-gray-700 pb-1">
                                ${homeColor} <strong>Casa:</strong> ${homeCount}/${homeTotal} ultimi match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${homePerc}%
                                    ${homePenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${homePenalty} punti` : ''}
                                    <br>‚Ä¢ <strong>Score: ${homeScore}</strong>
                                </div>
                            </div>
                            <div class="pb-1">
                                ${awayColor} <strong>Trasferta:</strong> ${awayCount}/${awayTotal} ultimi match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${awayPerc}%
                                    ${awayPenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${awayPenalty} punti` : ''}
                                    <br>‚Ä¢ <strong>Score: ${awayScore}</strong>
                                </div>
                            </div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t border-gray-700 opacity-75">
                            <div><strong>Score medio: ${Math.round(avgScore)}</strong></div>
                            <div class="mt-1">80+ = OTTIMA | 60-79 = BUONA | <60 = INCERTA</div>
                        </div>
                    `;
                }
            }

            tooltipEl.innerHTML = content;
            tooltipEl.style.display = 'block';

            // Posiziona tooltip - FIX: Rimuovi scrollY perch√© √® position: fixed
            setTimeout(() => {
                const tooltipRect = tooltipEl.getBoundingClientRect();
                let top = rect.top - tooltipRect.height - 10;
                let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);

                // Evita overflow top/bottom/left/right
                if (top < 0) top = rect.bottom + 10;
                if (left < 10) left = 10;
                if (left + tooltipRect.width > window.innerWidth) {
                    left = window.innerWidth - tooltipRect.width - 10;
                }

                tooltipEl.style.top = `${top}px`; // FIX: Solo top relativo a viewport
                tooltipEl.style.left = `${left}px`;
            }, 0);
        }

        // Nascondi tooltip
        function hideTooltipCustom() {
            tooltipEl.style.display = 'none';
        }

        // Event delegation per tooltip - FIX: Usa mouseover per bubbling corretto
        document.addEventListener('mouseover', (e) => {
            const trigger = e.target.closest('.tooltip-trigger');
            if (trigger && trigger.dataset.tooltipType) {
                showTooltipCustom(trigger, trigger.dataset.tooltipType);
            } else {
                hideTooltipCustom();
            }
        });

        document.addEventListener('mouseout', (e) => {
            // Lascia che mouseover gestisca la scomparsa se esce dal trigger
            const related = e.relatedTarget;
            const trigger = e.target.closest('.tooltip-trigger');
            if (trigger && (!related || !trigger.contains(related))) {
                hideTooltipCustom();
            }
        });
    </script>
</body>

</html>