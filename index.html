<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TipsterAI - Pronostici</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.85) 100%);
            backdrop-filter: blur(10px);
        }

        .strategy-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .strategy-btn:active {
            transform: scale(0.95);
        }

        .strategy-btn.magic-ai {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 8px 24px rgba(245, 158, 11, 0.4);
            border: 2px solid #fbbf24;
        }

        .strategy-info {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .strategy-info:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .match-card {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            transition: all 0.3s ease;
        }

        .match-card:active {
            transform: translateY(2px);
        }

        .score-badge {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
        }

        .flag-btn {
            transition: all 0.2s ease;
        }

        .flag-btn.flagged {
            color: #f59e0b !important;
            transform: scale(1.2);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.4s ease-out;
        }
    </style>
</head>

<body class="text-white">
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="text-white text-2xl font-bold mb-4 animate-pulse">TipsterAI</div>
            <div class="text-blue-300 text-sm">Caricamento...</div>
        </div>
    </div>

    <!-- Login/Register Screen (hidden after login) -->
    <div id="login-container"
        class="hidden fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-40 px-4">
        <div class="bg-white rounded-2xl p-8 max-w-md w-full text-gray-800">
            <h2 id="auth-title" class="text-2xl font-bold mb-6 text-center">Accedi a TipsterAI</h2>

            <!-- Toggle Login/Register -->
            <div class="flex mb-6 bg-gray-100 rounded-lg p-1">
                <button id="toggle-login"
                    class="flex-1 py-2 rounded-lg font-semibold bg-purple-600 text-white transition">
                    Accedi
                </button>
                <button id="toggle-register" class="flex-1 py-2 rounded-lg font-semibold text-gray-600 transition">
                    Registrati
                </button>
            </div>

            <form id="auth-form" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-1">Email</label>
                    <input type="email" id="email" required
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Password</label>
                    <input type="password" id="password" required minlength="6"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none">
                    <div class="text-xs text-gray-500 mt-1">Minimo 6 caratteri</div>
                </div>
                <div id="auth-error" class="text-red-500 text-sm hidden"></div>
                <button type="submit" id="auth-submit-btn"
                    class="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-3 rounded-lg font-bold hover:opacity-90">
                    Accedi
                </button>
            </form>
        </div>
    </div>

    <!-- Main App -->
    <div id="app-container" class="hidden">
        <!-- Top Bar -->
        <div class="bg-gradient-to-r from-purple-700 to-blue-700 shadow-lg sticky top-0 z-40">
            <div class="container mx-auto px-4 py-4 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <img src="logo.png" alt="TipsterAI" class="h-10 w-10 rounded-lg">
                    <h1 class="text-2xl font-black">TipsterAI</h1>
                </div>
                <button id="logout-btn" class="text-sm hover:text-yellow-300 transition">
                    <i class="fa-solid fa-right-from-bracket mr-1"></i> Esci
                </button>
            </div>
        </div>

        <!-- Stats Dashboard -->
        <div id="stats-dashboard" class="container mx-auto px-4 py-6">
            <!-- Riga 1: Box grande totale -->
            <div class="stat-card rounded-xl p-4 text-center mb-3">
                <div class="text-gray-700 text-xs font-semibold mb-1">Pronostici da agosto 2025</div>
                <div id="stat-total" class="text-3xl font-black text-blue-800">-</div>
            </div>

            <!-- Riga 2: 3 box piccoli -->
            <div class="grid grid-cols-3 gap-3 mb-4">
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">Pronostici<br>VINTI</div>
                    <div id="stat-wins" class="text-xl font-black text-green-600">-</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">Pronostici<br>PERSI</div>
                    <div id="stat-losses" class="text-xl font-black text-red-600">-</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">WINRATE</div>
                    <div id="stat-winrate" class="text-xl font-black text-green-600">-</div>
                </div>
            </div>

            <div class="stat-card rounded-lg px-4 py-2 text-center">
                <div class="text-gray-600 text-xs">
                    <i class="fa-solid fa-sparkles mr-1"></i>
                    Aggiornata per nuovi Pronostici: <span id="last-update" class="font-semibold">-</span>
                </div>
            </div>
        </div>

        <!-- Strategies Page -->
        <div id="page-strategies" class="page active container mx-auto px-4 pb-24">
            <!-- Date Selector (7-Day History) -->
            <div class="bg-white/10 rounded-xl p-4 mb-4">
                <div class="flex items-center justify-between">
                    <button id="date-prev"
                        class="text-3xl hover:scale-110 transition transform disabled:opacity-30 disabled:cursor-not-allowed">
                        ‚óÄ
                    </button>
                    <div class="text-center flex-1">
                        <div class="text-xs text-gray-300 mb-1">Strategie del</div>
                        <div id="selected-date-display" class="text-xl font-bold">...</div>
                        <div id="date-indicator" class="text-xs text-gray-400 mt-1">Caricamento...</div>
                    </div>
                    <button id="date-next"
                        class="text-3xl hover:scale-110 transition transform disabled:opacity-30 disabled:cursor-not-allowed">
                        ‚ñ∂
                    </button>
                </div>
            </div>

            <h2 class="text-2xl font-bold mb-4 text-center">üìä Seleziona una Strategia</h2>
            <div id="strategies-grid" class="grid grid-cols-2 md:grid-cols-3 gap-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Ranking Page -->
        <div id="page-ranking" class="page container mx-auto px-4 pb-24">
            <div class="flex items-center justify-between mb-4">
                <button id="back-to-strategies" class="text-sm hover:text-yellow-300">
                    <i class="fa-solid fa-arrow-left mr-1"></i> Tutte le Strategie
                </button>
                <h2 id="strategy-title" class="text-xl font-bold">-</h2>
            </div>

            <!-- Sorting Toggle -->
            <div class="flex gap-2 mb-4">
                <button id="sort-by-score"
                    class="flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm">
                    üìä Per Ranking
                </button>
                <button id="sort-by-time"
                    class="flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm">
                    üïê Per Orario
                </button>
            </div>

            <div id="matches-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- My Matches Page -->
        <div id="page-my-matches" class="page container mx-auto px-4 pb-24">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-bold">‚≠ê Le Mie Partite</h2>
                <button id="delete-all-matches-btn"
                    class="bg-red-600 text-white px-4 py-2 rounded-lg font-semibold text-sm hover:bg-red-700 transition">
                    <i class="fa-solid fa-trash mr-1"></i> Cancella Tutte
                </button>
            </div>

            <!-- Sorting Toggle for My Matches -->
            <div class="flex gap-2 mb-4">
                <button id="my-matches-sort-score"
                    class="flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm">
                    üìä Per Ranking
                </button>
                <button id="my-matches-sort-time"
                    class="flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm">
                    üïê Per Orario
                </button>
            </div>

            <div id="my-matches-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Bottom Nav -->
        <div class="fixed bottom-0 left-0 right-0 bg-gray-900 border-t border-gray-700 flex justify-around py-3 z-50">
            <button data-page="strategies" class="nav-btn flex flex-col items-center text-purple-400 transition">
                <i class="fa-solid fa-list text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Strategie</span>
            </button>
            <button data-page="my-matches"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-yellow-400 transition">
                <i class="fa-solid fa-star text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Mie Partite</span>
            </button>
        </div>
    </div>

    <script>
        // ==================== CREDENZIALI FIREBASE E GEMINI ====================
        window.firebaseConfig = {
            apiKey: "AIzaSyCwAy4QfYlbxj4yBLnho3ZnO2_NaxzbVRQ",
            authDomain: "betmines-pronostici.firebaseapp.com",
            projectId: "betmines-pronostici",
            storageBucket: "betmines-pronostici.firebasestorage.app",
            messagingSenderId: "716119578109",
            appId: "1:716119578109:web:01e8b9dad7b17c91d63594"
        };

        // Split key to avoid GitHub "Leaked Key" auto-revocation
        const PART_A = "AIzaSyADskGhRN1E5UqXon";
        const PART_B = "Y11qL05e-gA4fFkYs";
        window.GEMINI_API_KEY = PART_A + PART_B;
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";

        // Firebase Config
        const firebaseConfig = window.firebaseConfig;
        // GEMINI_API_KEY is already on window from secrets.js

        // Firebase Config imported from secrets.js

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Set auth persistence to keep user logged in
        setPersistence(auth, browserLocalPersistence).catch(err => {
            console.error('[Auth] Persistence error:', err);
        });

        // Expose Firebase helpers to window for AI functions
        window.db = db;
        window.setDoc = setDoc;
        window.doc = doc;
        window.currentUser = null; // Will be updated by auth listener

        // State
        let currentUser = null;
        let strategiesData = null;
        let selectedMatches = [];
        let currentStrategyId = null;  // Track current strategy for re-sorting
        let currentSortMode = 'score';  // 'score' or 'time'
        let isRegisterMode = false;  // Track if user is in registration mode
        let globalStats = { total: 0, wins: 0, losses: 0, winrate: 0 }; // Global stats for AI

        // Expose to window for Chatbot
        window.globalStats = globalStats;
        window.strategiesData = null; // Will be updated
        window.currentUser = null; // Will be updated
        window.aiKnowledge = null; // AI Knowledge Base

        // Date formatting
        function formatDateIT(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            return `${day}/${month}/${year}`;
        }

        // Toggle between Login and Register
        document.getElementById('toggle-login').addEventListener('click', () => {
            isRegisterMode = false;
            document.getElementById('auth-title').textContent = 'Accedi a TipsterAI';
            document.getElementById('auth-submit-btn').textContent = 'Accedi';
            document.getElementById('toggle-login').className = 'flex-1 py-2 rounded-lg font-semibold bg-purple-600 text-white transition';
            document.getElementById('toggle-register').className = 'flex-1 py-2 rounded-lg font-semibold text-gray-600 transition';
        });

        document.getElementById('toggle-register').addEventListener('click', () => {
            isRegisterMode = true;
            document.getElementById('auth-title').textContent = 'Registrati a TipsterAI';
            document.getElementById('auth-submit-btn').textContent = 'Registrati';
            document.getElementById('toggle-login').className = 'flex-1 py-2 rounded-lg font-semibold text-gray-600 transition';
            document.getElementById('toggle-register').className = 'flex-1 py-2 rounded-lg font-semibold bg-purple-600 text-white transition';
        });

        // Clean up old matches (> 24h)
        async function cleanupOldMatches(userId) {
            try {
                const userMatchesDoc = await getDoc(doc(db, "users", userId, "data", "selected_matches"));
                if (!userMatchesDoc.exists()) return;

                const data = userMatchesDoc.data();
                const now = Date.now();
                const oneDayMs = 24 * 60 * 60 * 1000;

                // Filter out matches older than 24h
                const freshMatches = (data.matches || []).filter(m => {
                    const matchDate = new Date(m.data).getTime();
                    return (now - matchDate) < oneDayMs;
                });

                const removed = data.matches.length - freshMatches.length;
                if (removed > 0) {
                    await setDoc(doc(db, "users", userId, "data", "selected_matches"), {
                        matches: freshMatches,
                        updated: now
                    });
                    console.log(`[Auto-Cleanup] Removed ${removed} old matches (>24h)`);
                }

                selectedMatches = freshMatches;
            } catch (e) {
                console.error('[Auto-Cleanup] Error:', e);
            }
        }

        // Auth Check
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                window.currentUser = user; // Update global reference

                // Auto-cleanup old matches
                await cleanupOldMatches(user.uid);

                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('login-container').classList.add('hidden'); // Fix: Hide login screen
                document.getElementById('app-container').classList.remove('hidden');
                await loadData();
            } else {
                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('login-container').classList.remove('hidden');
            }
        });

        // Login/Register
        document.getElementById('auth-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('auth-error');

            try {
                if (isRegisterMode) {
                    // REGISTER
                    await createUserWithEmailAndPassword(auth, email, password);
                    console.log('[Auth] User registered successfully');
                } else {
                    // LOGIN
                    await signInWithEmailAndPassword(auth, email, password);
                    console.log('[Auth] User logged in successfully');
                }
            } catch (e) {
                console.error('[Auth] Error:', e);

                // User-friendly error messages
                let errorMsg = 'Errore di autenticazione';
                if (e.code === 'auth/email-already-in-use') {
                    errorMsg = 'Email gi√† registrata. Usa il login.';
                } else if (e.code === 'auth/weak-password') {
                    errorMsg = 'Password troppo debole (min 6 caratteri)';
                } else if (e.code === 'auth/user-not-found' || e.code === 'auth/wrong-password') {
                    errorMsg = 'Email o password errati';
                } else if (e.code === 'auth/invalid-email') {
                    errorMsg = 'Email non valida';
                }

                errorDiv.textContent = errorMsg;
                errorDiv.classList.remove('hidden');
            }
        });

        // Logout
        document.getElementById('logout-btn').addEventListener('click', () => signOut(auth));

        // Global variable for selected date
        let selectedDateGlobal = new Date().toISOString().split('T')[0]; // Default: today

        // Load Data
        async function loadData(dateToLoad = null) {
            try {
                // Use provided date or default to global selected date
                const targetDate = dateToLoad || selectedDateGlobal;

                console.log(`[Client] Loading strategies for ${targetDate}...`);

                // Try NEW date-based structure first
                let strategiesDoc = await getDoc(doc(db, "daily_strategies", targetDate));

                if (strategiesDoc.exists()) {
                    // NEW structure found
                    console.log('[Client] ‚úÖ Found strategies in new date-based structure');
                    const docData = strategiesDoc.data();
                    const strategiesContainer = docData.strategies || {};

                    console.log('[Client] Date:', docData.date, 'Strategies:', Object.keys(strategiesContainer));

                    // Use strategies directly from date-specific document
                    // (Already contains full strategy data with matches)
                    processStrategiesData(strategiesContainer);
                    updateDateDisplay(targetDate, true);
                } else {
                    // Fallback to OLD structure
                    console.log('[Client] Date-based structure not found, falling back to old system/strategy_results');
                    strategiesDoc = await getDoc(doc(db, "system", "strategy_results"));

                    if (!strategiesDoc.exists()) {
                        console.error('[Client] No strategies found!');
                        updateDateDisplay(targetDate, false);
                        clearStrategiesUI();
                        return;
                    }

                    const allStrategies = strategiesDoc.data();
                    processStrategiesData(allStrategies);
                    updateDateDisplay(targetDate, true);
                }

                // Load user selected matches (only first time)
                if (dateToLoad === null) {
                    const userMatchesDoc = await getDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"));
                    if (userMatchesDoc.exists()) {
                        selectedMatches = userMatchesDoc.data().matches || [];
                        window.selectedMatches = selectedMatches;
                        console.log('[Client] Loaded selected matches:', selectedMatches.length);
                        updateMyMatchesCount();
                    } else {
                        console.log('[Client] No selected matches found');
                    }

                    // Load AI Knowledge Base (only first time)
                    try {
                        const knowledgeDoc = await getDoc(doc(db, "strategies_metadata", "definitions"));
                        if (knowledgeDoc.exists()) {
                            window.aiKnowledge = knowledgeDoc.data();
                            console.log('[Client] AI Knowledge loaded:', Object.keys(window.aiKnowledge));
                        }
                    } catch (e) {
                        console.warn('[Client] Could not load AI knowledge:', e);
                    }
                }
            } catch (e) {
                console.error('[Client] Critical error loading data:', e);
                updateDateDisplay(selectedDateGlobal, false);
            }
        }

        // Helper: Process strategies data (filter and expose)
        function processStrategiesData(allStrategies) {
            console.log('[Client] Raw strategies from DB:', Object.keys(allStrategies));

            const presetIds = ['all', 'winrate_80', 'italia', 'top_eu', 'cups', 'best_05_ht'];
            strategiesData = {};

            for (const [stratId, stratData] of Object.entries(allStrategies)) {
                if (!stratData.name || !stratData.matches) {
                    console.warn(`[Client] Skipping ${stratId} - missing data`);
                    continue;
                }

                // Include presets always
                if (presetIds.includes(stratId)) {
                    strategiesData[stratId] = stratData;
                    continue;
                }

                // Include all custom strategies
                strategiesData[stratId] = stratData;
            }

            console.log('[Client] Filtered published strategies:', Object.keys(strategiesData));
            window.strategiesData = strategiesData;
            console.log('[Client] strategiesData attached to window for AI');
            window.updateMyMatchesCount = updateMyMatchesCount;
            console.log('[Client] selectedMatches attached to window for AI');

            renderStats();
            renderStrategies();
        }

        // Helper: Clear strategies UI when no data
        function clearStrategiesUI() {
            const grid = document.getElementById('strategies-grid');
            if (grid) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-300 py-8">Nessuna strategia disponibile per questa data</div>';
            }
        }

        // Helper: Update date display
        function updateDateDisplay(date, hasData) {
            const displayEl = document.getElementById('selected-date-display');
            const indicatorEl = document.getElementById('date-indicator');

            if (displayEl) {
                displayEl.textContent = formatDateLong(date);
            }

            if (indicatorEl) {
                if (hasData) {
                    const matchCount = Object.values(strategiesData).reduce((sum, strat) =>
                        sum + (strat.matches?.length || 0), 0);
                    indicatorEl.textContent = `${matchCount} partite totali`;
                    indicatorEl.className = 'text-xs text-green-400 mt-1';
                } else {
                    indicatorEl.textContent = 'Nessuna strategia disponibile';
                    indicatorEl.className = 'text-xs text-red-400 mt-1';
                }
            }

            // Update button states
            updateDateNavButtons();
        }

        // Helper: Update date nav button states
        function updateDateNavButtons() {
            const prevBtn = document.getElementById('date-prev');
            const nextBtn = document.getElementById('date-next');
            const today = new Date().toISOString().split('T')[0];

            // Disable next if we're at today
            if (nextBtn) {
                nextBtn.disabled = (selectedDateGlobal >= today);
            }

            // Always enable prev (can go back 7+ days, just won't find data)
            if (prevBtn) {
                prevBtn.disabled = false;
            }
        }

        // Render Stats
        async function renderStats() {
            try {
                // Query all matches with results
                const matchesQuery = query(collection(db, "matches"), where("risultato", "!=", ""));
                const snapshot = await getDocs(matchesQuery);

                let total = 0;
                let wins = 0;
                let losses = 0;
                let lastDate = '';

                snapshot.forEach(doc => {
                    const m = doc.data();
                    total++;
                    if (m.esito === 'Vinto') wins++;
                    if (m.esito === 'Perso') losses++;
                    if (m.data > lastDate) lastDate = m.data;
                });

                const winrate = total > 0 ? ((wins / total) * 100).toFixed(1) : 0;

                // Update Global Stats for AI
                globalStats = { total, wins, losses, winrate };
                window.globalStats = globalStats; // Update global reference

                // Calculate date from ACTIVE predictions (strategiesData)
                let activeDate = '';
                if (window.strategiesData) {
                    // Find the most recent date in the loaded strategies
                    Object.values(window.strategiesData).forEach(strat => {
                        if (strat.matches && strat.matches.length > 0) {
                            strat.matches.forEach(m => {
                                if (m.data > activeDate) activeDate = m.data;
                            });
                        }
                    });
                }

                // Fallback to next day of last result if no active matches found
                const displayDate = activeDate ? activeDate : getNextDay(lastDate);

                document.getElementById('stat-total').textContent = total;
                document.getElementById('stat-wins').textContent = wins;
                document.getElementById('stat-losses').textContent = losses;
                document.getElementById('stat-winrate').textContent = winrate + '%';
                document.getElementById('last-update').textContent = formatDateLong(displayDate);
            } catch (e) {
                console.error('Error calculating stats:', e);
            }
        }

        // Get next day
        function getNextDay(dateString) {
            const date = new Date(dateString);
            date.setDate(date.getDate() + 1);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Format date in Italian long format
        function formatDateLong(dateString) {
            if (!dateString) return '';
            const months = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
                'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
            const [year, month, day] = dateString.split('-');
            return `${parseInt(day)} ${months[parseInt(month) - 1]} ${year}`;
        }

        // Render Strategies
        function renderStrategies() {
            const container = document.getElementById('strategies-grid');
            container.innerHTML = '';

            // Strategy descriptions
            const descriptions = {
                all: 'Tutte le partite pronosticate',
                winrate_80: 'Solo leghe con winrate superiore all\'80%',
                italia: 'Tutte le partite dei campionati Italiani',
                top_eu: 'Principali campionati europei (Premier, Liga, Bundesliga, Ligue 1, Serie A)',
                cups: 'Competizioni europee (Champions, Europa, Conference League)',
                best_05_ht: 'Partite Over 0.5 HT selezionate al 70%+',
                magic_ai: 'La magia dell\'AI con le sue scelte misteriose ü™Ñ'
            };

            Object.keys(strategiesData).forEach(stratId => {
                const strat = strategiesData[stratId];

                // Safety checks
                if (!strat || !strat.name) {
                    console.warn(`[Client] Skipping ${stratId} - invalid data`);
                    return;
                }

                const isMagicAI = stratId.toLowerCase().includes('magic') || (strat.name && strat.name.toLowerCase().includes('magic'));
                const card = document.createElement('button');
                card.className = `strategy-btn ${isMagicAI ? 'magic-ai' : ''} text-white rounded-xl p-6 shadow-lg transform hover:scale-105 transition`;

                const description = descriptions[stratId] || descriptions['magic_ai'] || 'Strategia personalizzata';

                card.innerHTML = `
                    <div class="strategy-info">?</div>
                    <div class="text-3xl mb-2">${getStrategyIcon(stratId, isMagicAI)}</div>
                    <div class="font-bold text-sm mb-1">${strat.name}</div>
                    <div class="text-xs opacity-80">${strat.totalMatches} partite</div>
                `;

                // Info button click
                const infoBtn = card.querySelector('.strategy-info');
                infoBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    alert(`${strat.name}\n\n${description}`);
                });

                card.addEventListener('click', () => showRanking(stratId, strat));
                container.appendChild(card);
            });
        }

        // Show Ranking
        function showRanking(stratId, strat, sortMode = 'score') {
            try {
                console.log('[showRanking] Called with:', stratId, 'sortMode:', sortMode);
                console.log('[showRanking] Strategy data:', strat);

                if (!strat) {
                    console.error('[showRanking] Strategy data is null/undefined!');
                    alert('Errore: Dati strategia non disponibili');
                    return;
                }

                if (!strat.matches) {
                    console.error('[showRanking] Strategy has no matches array!');
                    alert('Errore: Nessun dato partite disponibile');
                    return;
                }

                currentStrategyId = stratId;
                currentSortMode = sortMode;

                document.getElementById('strategy-title').textContent = strat.name;
                const container = document.getElementById('matches-container');
                container.innerHTML = '';

                if (strat.matches.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-300 py-12">Nessuna partita per questa strategia</div>';
                } else {
                    console.log('[showRanking] Rendering', strat.matches.length, 'matches');

                    // Clone and sort matches
                    let sortedMatches = [...strat.matches];

                    if (sortMode === 'time') {
                        // Sort by time (matches without time go last)
                        sortedMatches.sort((a, b) => {
                            if (!a.ora && !b.ora) return 0;
                            if (!a.ora) return 1;
                            if (!b.ora) return -1;
                            return a.ora.localeCompare(b.ora);
                        });

                        // Group by time and render with time headers
                        let currentTime = null;
                        let matchIndex = 0;

                        sortedMatches.forEach((m) => {
                            // Add time header if changed
                            if (m.ora && m.ora !== currentTime) {
                                currentTime = m.ora;
                                const timeHeader = document.createElement('div');
                                timeHeader.className = 'flex items-center gap-2 my-4 pt-4 border-t border-white/20';
                                timeHeader.innerHTML = `
                                    <div class="text-2xl">üïê</div>
                                    <div class="text-xl font-bold">${currentTime}</div>
                                    <div class="text-sm text-gray-400 ml-auto">${countMatchesAtTime(sortedMatches, currentTime)} partite</div>
                                `;
                                container.appendChild(timeHeader);
                            }

                            const card = createMatchCard(m, matchIndex, stratId, false); // false = hide time in card
                            container.appendChild(card);
                            matchIndex++;
                        });
                    } else {
                        // Render by score (no time headers)
                        sortedMatches.forEach((m, idx) => {
                            const card = createMatchCard(m, idx, stratId, true); // true = show time in card if available
                            container.appendChild(card);
                        });
                    }
                }

                // Update button states
                updateSortButtons(sortMode);

                console.log('[showRanking] Switching to ranking page');
                showPage('ranking');
                console.log('[showRanking] Complete!');
            } catch (error) {
                console.error('[showRanking] CRITICAL ERROR:', error);
                console.error('[showRanking] Error stack:', error.stack);
                alert(`Errore nell'apertura della strategia: ${error.message}\n\nControlla la console per dettagli.`);
            }
        }

        // Helper: count matches at specific time
        function countMatchesAtTime(matches, time) {
            return matches.filter(m => m.ora === time).length;
        }

        // Update sort button visual states
        function updateSortButtons(activeMode) {
            const scoreBtn = document.getElementById('sort-by-score');
            const timeBtn = document.getElementById('sort-by-time');

            if (activeMode === 'score') {
                scoreBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
            } else {
                scoreBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
            }
        }

        // Create Match Card
        function createMatchCard(match, index, stratId, showTimeInCard = true) {
            const matchId = `${match.data}_${match.partita}`;
            const isFlagged = (window.selectedMatches || []).some(sm => sm.id === matchId);

            const card = document.createElement('div');

            // Keep card blue always, only color the result box
            card.className = 'match-card rounded-xl p-5 shadow-lg fade-in';

            const indicationHTML = match.indication ? `
                <div class="${match.indication.bg} ${match.indication.color} px-4 py-2 rounded-xl text-center font-bold text-sm mb-3">
                    ${match.indication.text}
                </div>
            ` : '';

            const betfairHTML = match.betfairBadge ? `
                <div class="text-xs ${match.betfairBadge.color} mt-2 font-semibold">Trading Sportivo: ${match.betfairBadge.text}</div>
            ` : '';

            // HT Info section (when available and significant)
            const htHTML = match.info_ht && match.info_ht.trim() !== '' ? `
                <div class="mt-3 bg-purple-500/20 border border-purple-400/30 rounded-lg p-3">
                    <div class="text-xs font-bold text-purple-200 mb-1">üìä Primo Tempo (0.5 PT)</div>
                    <div class="text-sm text-purple-100">
                        Probabilit√†: <span class="font-black">${match.info_ht}</span>
                    </div>
                </div>
            ` : '';

            // Generate explanatory text for team stats
            const getStatsExplanation = (stats, isHome, tip) => {
                if (!stats || stats.total === 0) return '';

                const location = isHome ? 'casa' : 'trasferta';
                const tipDisplay = tip || match.tip;

                // Determine what the stats represent based on tip type
                let explanation = '';
                if (tipDisplay.startsWith('+')) {
                    // Over tip
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite, ha avuto esito <strong>${tipDisplay}</strong> in <strong>${stats.count}</strong> casi`;
                } else if (tipDisplay.startsWith('-')) {
                    // Under tip
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite, ha avuto esito <strong>${tipDisplay}</strong> in <strong>${stats.count}</strong> casi`;
                } else {
                    // 1X2 / DC
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite ${location}, esito favorevole in <strong>${stats.count}</strong> casi`;
                }

                return explanation;
            };

            const statsHTML = match.teamStats && match.teamStats.home && match.teamStats.away ? `
                <div class="mt-4 pt-4 border-t border-white/20">
                    <div class="text-xs font-bold mb-3 opacity-80">üìä Statistiche Squadre:</div>
                    <div class="space-y-3 text-xs">
                        <div class="bg-white/10 p-3 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <div class="font-semibold text-sm">üè† Casa</div>
                                <div class="text-${match.teamStats.home.color === 'green' ? 'green' : 'yellow'}-400 font-black text-lg">
                                    ${match.teamStats.home.percentage}%
                                </div>
                            </div>
                            <div class="text-gray-300 text-xs leading-relaxed">
                                ${getStatsExplanation(match.teamStats.home, true, match.tip)}
                            </div>
                        </div>
                        <div class="bg-white/10 p-3 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <div class="font-semibold text-sm">‚úàÔ∏è Trasferta</div>
                                <div class="text-${match.teamStats.away.color === 'green' ? 'green' : 'yellow'}-400 font-black text-lg">
                                    ${match.teamStats.away.percentage}%
                                </div>
                            </div>
                            <div class="text-gray-300 text-xs leading-relaxed">
                                ${getStatsExplanation(match.teamStats.away, false, match.tip)}
                            </div>
                        </div>
                    </div>
                </div>
            ` : '';

            card.innerHTML = `
                <div class="flex items-center justify-between mb-3">
                    <span class="text-3xl font-black text-purple-300">#${index + 1}</span>
                    <button class="flag-btn ${isFlagged ? 'flagged' : ''} text-2xl" data-match-id="${matchId}">
                        <i class="fa-${isFlagged ? 'solid' : 'regular'} fa-star"></i>
                    </button>
                    <span class="score-badge text-white px-4 py-2 rounded-full text-xl font-black">${match.score}</span>
                </div>
                
                ${showTimeInCard && match.ora ? `<div class="text-sm text-yellow-300 mb-2">üïê ${match.ora}</div>` : ''}
                
                <div class="text-2xl font-bold mb-2">${match.partita}</div>
                <div class="text-sm opacity-80 mb-3">${match.lega}</div>
                
                ${match.risultato && match.esito ? `
                    <div class="mb-4 p-4 rounded-xl ${match.esito === 'Vinto' ? 'bg-gradient-to-r from-green-500 to-green-600' : 'bg-gradient-to-r from-red-500 to-red-600'}">
                        <div class="flex items-center justify-between gap-4 text-white">
                            <div class="flex-1 text-center">
                                <div class="text-xs font-bold opacity-90 mb-1">RISULTATO FINALE</div>
                                <div class="text-4xl font-black">${match.risultato}</div>
                            </div>
                            <div class="flex-1 text-center">
                                <div class="text-3xl font-black">
                                    ${match.esito === 'Vinto' ? '‚úÖ VINTO' : '‚ùå PERSO'}
                                </div>
                            </div>
                        </div>
                    </div>
                ` : ''}
                
                <div class="bg-white/10 rounded-lg p-3 mb-3">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-xs text-gray-300 mb-1">Tip Principale</div>
                            <div class="text-xl font-black text-blue-300">${match.tip} <span class="text-white">@${match.quota}</span></div>
                        </div>
                        <div class="text-right">
                            <div class="text-xs text-gray-300 mb-1">Probabilit√†</div>
                            <div class="text-lg font-bold text-white">${match.probabilita}%</div>
                        </div>
                    </div>
                </div>
                
                ${!match.risultato ? indicationHTML : ''}
                ${!match.risultato ? htHTML : ''}
                ${!match.risultato ? betfairHTML : ''}
                ${!match.risultato ? statsHTML : ''}
            `;

            // Flag button logic
            const flagBtn = card.querySelector('.flag-btn');
            flagBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFlag(matchId, match, stratId, flagBtn);
            });

            return card;
        }

        // Toggle Flag
        async function toggleFlag(matchId, match, stratId, btn) {
            const index = window.selectedMatches.findIndex(sm => sm.id === matchId);

            if (index >= 0) {
                // Remove
                window.selectedMatches.splice(index, 1);
                btn.classList.remove('flagged');
                btn.innerHTML = '<i class="fa-regular fa-star"></i>';
            } else {
                // Add
                window.selectedMatches.push({
                    id: matchId,
                    strategy: strategiesData[stratId].name, // Save to state
                    ...match
                });
                btn.classList.add('flagged');
                btn.innerHTML = '<i class="fa-solid fa-star"></i>';
            }

            // Save to Firebase
            try {
                await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                    matches: window.selectedMatches,
                    updated: Date.now()
                });
            } catch (e) {
                console.error('Error saving selection:', e);
            }

            // Update My Matches count
            updateMyMatchesCount();
        }

        // Show My Matches
        function showMyMatches(sortMode = 'score') {
            const container = document.getElementById('my-matches-container');
            container.innerHTML = '';

            if (window.selectedMatches.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-300 py-12">Nessuna partita selezionata</div>';
                console.log('[Client] No matches to show');
            } else {
                console.log('[Client] Rendering', window.selectedMatches.length, 'matches');

                // Clone and sort
                let sortedMatches = [...window.selectedMatches];

                if (sortMode === 'time') {
                    // Sort by time
                    sortedMatches.sort((a, b) => {
                        if (!a.ora && !b.ora) return 0;
                        if (!a.ora) return 1;
                        if (!b.ora) return -1;
                        return a.ora.localeCompare(b.ora);
                    });

                    // Render with time headers
                    let currentTime = null;
                    let matchIndex = 0;

                    sortedMatches.forEach((m) => {
                        // Add time header if changed
                        if (m.ora && m.ora !== currentTime) {
                            currentTime = m.ora;
                            const timeHeader = document.createElement('div');
                            timeHeader.className = 'flex items-center gap-2 my-4 pt-4 border-t border-white/20';
                            timeHeader.innerHTML = `
                                <div class="text-2xl">üïê</div>
                                <div class="text-xl font-bold">${currentTime}</div>
                                <div class="text-sm text-gray-400 ml-auto">${sortedMatches.filter(x => x.ora === currentTime).length} partite</div>
                            `;
                            container.appendChild(timeHeader);
                        }

                        try {
                            const card = createMatchCard(m, matchIndex, null, false);

                            // Replace Flag Button with Delete Button
                            const flagBtn = card.querySelector('.flag-btn');
                            if (flagBtn) flagBtn.remove();

                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'absolute top-4 right-4 text-gray-400 hover:text-red-500 transition p-2';
                            deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                removeMatch(`${m.data}_${m.partita}`);
                            };
                            card.style.position = 'relative';
                            card.appendChild(deleteBtn);

                            container.appendChild(card);
                        } catch (e) {
                            console.error('[Client] Error creating match card:', e, m);
                        }
                        matchIndex++;
                    });
                } else {
                    // Sort by score (default)
                    sortedMatches.sort((a, b) => (b.score || 0) - (a.score || 0));

                    sortedMatches.forEach((m, idx) => {
                        try {
                            const card = createMatchCard(m, idx, null, true);

                            // Replace Flag Button with Delete Button
                            const flagBtn = card.querySelector('.flag-btn');
                            if (flagBtn) flagBtn.remove();

                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'absolute top-4 right-4 text-gray-400 hover:text-red-500 transition p-2';
                            deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                removeMatch(`${m.data}_${m.partita}`);
                            };
                            card.style.position = 'relative';
                            card.appendChild(deleteBtn);

                            container.appendChild(card);
                        } catch (e) {
                            console.error('[Client] Error creating match card:', e, m);
                        }
                    });
                }
            }
            // Update button states
            updateMyMatchesSortButtons(sortMode);
            // DON'T call showPage here - it's already called by the navigation button!
        }

        // Remove Single Match
        async function removeMatch(matchId) {
            if (!confirm('Vuoi rimuovere questa partita dai preferiti?')) return;

            const index = window.selectedMatches.findIndex(sm => sm.id === matchId);
            if (index > -1) {
                window.selectedMatches.splice(index, 1);

                // Save to Firebase
                try {
                    await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                        matches: window.selectedMatches,
                        updated: Date.now()
                    });

                    // Update UI
                    updateMyMatchesCount();
                    showMyMatches(); // Refresh list

                } catch (e) {
                    console.error("Error removing match:", e);
                    alert("Errore durante la rimozione");
                }
            }
        }

        // Update My Matches sort button states
        function updateMyMatchesSortButtons(activeMode) {
            const scoreBtn = document.getElementById('my-matches-sort-score');
            const timeBtn = document.getElementById('my-matches-sort-time');

            if (activeMode === 'score') {
                scoreBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
            } else {
                scoreBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
            }
        }

        // Update My Matches Count
        function updateMyMatchesCount() {
            const navBtn = document.querySelector('[data-page="my-matches"]');
            const countBadge = navBtn.querySelector('.count-badge');

            if (window.selectedMatches.length > 0) {
                if (!countBadge) {
                    const badge = document.createElement('span');
                    badge.className = 'count-badge absolute top-0 right-2 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center font-bold z-50';
                    badge.textContent = window.selectedMatches.length;
                    navBtn.style.position = 'relative';
                    navBtn.appendChild(badge);
                    console.log('[UI] Badge created:', window.selectedMatches.length);
                } else {
                    countBadge.textContent = window.selectedMatches.length;
                }
            } else if (countBadge) {
                countBadge.remove();
            }
        }

        // Navigation
        function showPage(pageName) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));

            if (pageName === 'strategies') {
                document.getElementById('page-strategies').classList.add('active');
            } else if (pageName === 'ranking') {
                document.getElementById('page-ranking').classList.add('active');
            } else if (pageName === 'my-matches') {
                showMyMatches();
                document.getElementById('page-my-matches').classList.add('active');
            }

            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if (btn.dataset.page === pageName) {
                    btn.classList.remove('text-gray-400');
                    btn.classList.add('text-purple-400');
                } else {
                    btn.classList.remove('text-purple-400');
                    btn.classList.add('text-gray-400');
                }
            });
        }

        // Event Listeners
        document.getElementById('back-to-strategies').addEventListener('click', () => showPage('strategies'));

        // Sort buttons
        document.getElementById('sort-by-score').addEventListener('click', () => {
            if (currentStrategyId && strategiesData[currentStrategyId]) {
                showRanking(currentStrategyId, strategiesData[currentStrategyId], 'score');
            }
        });

        document.getElementById('sort-by-time').addEventListener('click', () => {
            if (currentStrategyId && strategiesData[currentStrategyId]) {
                showRanking(currentStrategyId, strategiesData[currentStrategyId], 'time');
            }
        });

        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => showPage(btn.dataset.page));
        });

        // Date navigation buttons
        document.getElementById('date-prev').addEventListener('click', async () => {
            const currentDate = new Date(selectedDateGlobal);
            currentDate.setDate(currentDate.getDate() - 1);
            selectedDateGlobal = currentDate.toISOString().split('T')[0];
            await loadData(selectedDateGlobal);
        });

        document.getElementById('date-next').addEventListener('click', async () => {
            const currentDate = new Date(selectedDateGlobal);
            currentDate.setDate(currentDate.getDate() + 1);
            const today = new Date().toISOString().split('T')[0];

            if (currentDate.toISOString().split('T')[0] <= today) {
                selectedDateGlobal = currentDate.toISOString().split('T')[0];
                await loadData(selectedDateGlobal);
            }
        });

        // Delete all matches button
        document.getElementById('delete-all-matches-btn').addEventListener('click', async () => {
            if (window.selectedMatches.length === 0) {
                alert('Nessuna partita da cancellare');
                return;
            }

            if (!confirm(`Vuoi cancellare tutte le ${window.selectedMatches.length} partite salvate?\n\nQuesta azione √® irreversibile.`)) {
                return;
            }

            try {
                // Clear all matches
                window.selectedMatches = [];

                // Save to Firebase
                await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                    matches: [],
                    updated: Date.now()
                });

                // Update UI
                updateMyMatchesCount();
                showMyMatches();

                alert('‚úÖ Tutte le partite sono state cancellate');
            } catch (e) {
                console.error('[Delete All] Error:', e);
                alert('Errore durante la cancellazione');
            }
        });

        // My Matches sort buttons
        document.getElementById('my-matches-sort-score').addEventListener('click', () => {
            showMyMatches('score');
        });

        document.getElementById('my-matches-sort-time').addEventListener('click', () => {
            showMyMatches('time');
        });

        // Strategy Icons
        function getStrategyIcon(stratId, isMagicAI = false) {
            if (isMagicAI) return 'ü™Ñ';

            const icons = {
                all: 'üìä',
                winrate_80: 'üî•',
                italia: 'üáÆüáπ',
                top_eu: 'üåç',
                cups: 'üèÜ',
                best_05_ht: '‚ö°'
            };
            return icons[stratId] || 'üéØ';
        }
    </script>
</body>

<!-- AI CHATBOT WIDGET -->
<div id="ai-chat-widget" class="fixed bottom-6 right-6 z-50 flex flex-col items-end font-sans">
    <!-- Chat Window -->
    <div id="ai-chat-window"
        class="hidden bg-white w-80 h-96 rounded-2xl shadow-2xl border border-gray-200 flex flex-col mb-4 overflow-hidden transition-all transform origin-bottom-right">
        <!-- Header -->
        <div class="bg-gradient-to-r from-purple-600 to-blue-600 p-4 flex justify-between items-center text-white">
            <div class="flex items-center gap-2">
                <i class="fa-solid fa-robot"></i>
                <span class="font-bold text-sm">Antigravity AI</span>
            </div>
            <button id="close-chat-btn" class="hover:text-gray-200 transition">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>

        <!-- Messages Area -->
        <div id="chat-messages" class="flex-1 p-4 overflow-y-auto bg-gray-50 space-y-3 text-sm">
            <!-- Welcome Message (Dynamically added by JS) -->
        </div>

        <!-- Input Area -->
        <div class="p-3 bg-white border-t border-gray-100">
            <form id="chat-form" class="flex gap-2">
                <input type="text" id="chat-input" placeholder="Scrivi una domanda..."
                    class="flex-1 p-2 border border-gray-300 rounded-lg text-sm text-gray-900 bg-white focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500">
                <button type="submit"
                    class="bg-purple-600 text-white p-2 rounded-lg hover:bg-purple-700 transition shadow-sm disabled:opacity-50">
                    <i class="fa-solid fa-paper-plane"></i>
                </button>
            </form>
        </div>
    </div>

    <!-- Toggle Button -->
    <button id="toggle-chat-btn"
        class="bg-gradient-to-r from-purple-600 to-blue-600 text-white w-14 h-14 rounded-full shadow-lg hover:shadow-xl transition transform hover:scale-105 flex items-center justify-center text-2xl">
        <i class="fa-solid fa-comment-dots"></i>
    </button>
</div>

<!-- AI Chatbot Logic -->
<script>
    // CONFIGURATION
    // API Key imported from secrets.js
    const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";

    // UI Elements
    const widget = document.getElementById('ai-chat-widget');
    const chatWindow = document.getElementById('ai-chat-window');
    const toggleBtn = document.getElementById('toggle-chat-btn');
    const closeBtn = document.getElementById('close-chat-btn');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('chat-input');
    const messagesContainer = document.getElementById('chat-messages');
    const chatHeaderTitle = chatWindow.querySelector('.font-bold');

    // Update Name
    chatHeaderTitle.textContent = "euGENIO üßû‚Äç‚ôÇÔ∏è - TipsterAI";

    // State
    let isOpen = false;
    let chatHistory = [];
    let hasWelcomed = false;

    // Helper: Get User Name
    function getUserName() {
        if (window.currentUser && window.currentUser.email) {
            // Extract name from email (e.g., "mario" from "mario@gmail.com")
            const name = window.currentUser.email.split('@')[0];
            return name.charAt(0).toUpperCase() + name.slice(1);
        }
        return "Amico";
    }

    // Helper: Build Dynamic System Prompt
    function buildSystemPrompt() {
        const userName = getUserName();
        const knowledge = window.aiKnowledge || {};
        const strategies = window.strategiesData || {};

        // Merge keys from both sources to ensure we cover everything
        const allStrategyIds = new Set([...Object.keys(strategies), ...Object.keys(knowledge)]);

        let strategiesText = "";
        if (allStrategyIds.size > 0) {
            strategiesText = Array.from(allStrategyIds)
                .map(id => {
                    const s = strategies[id] || { name: knowledge[id]?.name || id, totalMatches: 0, matches: [] };
                    const meta = knowledge[id] || {};

                    // Description: Use Knowledge Base or fallback to Strategy object or default
                    const desc = meta.description || s.description || 'Strategia basata su statistiche.';

                    // 1. Static Knowledge (Definitions)
                    let staticInfo = "";
                    if (meta.leagues && meta.leagues.length > 0) {
                        const list = meta.leagues.slice(0, 12).join(', ');
                        staticInfo = `\n  *Definizione Leghe:* ${list}${meta.leagues.length > 12 ? ', ecc.' : '.'}`;
                    }

                    // 2. Dynamic Status (Active Matches Breakdown)
                    let dynamicInfo = "";
                    if (s.matches && s.matches.length > 0) {
                        // Count matches per league
                        const leagueCounts = {};
                        s.matches.forEach(m => {
                            const cleanLega = m.lega.replace(/^(EU-|AS-|AF-|NA-|SA-)/, ''); // Remove geo prefix for readability
                            leagueCounts[cleanLega] = (leagueCounts[cleanLega] || 0) + 1;
                        });

                        // Format: "Eredivisie (3), Premier League (2)"
                        let activeList = "";

                        // Special handling for "ALL" or huge strategies
                        if (id === 'all' || Object.keys(leagueCounts).length > 15) {
                            const totalActive = Object.values(leagueCounts).reduce((a, b) => a + b, 0);
                            activeList = `TUTTE le leghe attive (${Object.keys(leagueCounts).length} campionati, ${totalActive} partite). Include Serie A, Premier, Liga, ecc.`;
                        } else {
                            activeList = Object.entries(leagueCounts)
                                .sort((a, b) => b[1] - a[1]) // Sort by count desc
                                .slice(0, 8) // Top 8 active leagues
                                .map(([name, count]) => `${name} (${count})`)
                                .join(', ');
                        }

                        dynamicInfo = `\n  *üî• PARTITE ATTIVE OGGI:* ${activeList}`;
                    } else {
                        dynamicInfo = "\n  *Nessuna partita attiva oggi.*";
                    }

                    return `- **${s.name}**: ${desc} (${s.totalMatches || 0} partite totali).${staticInfo}${dynamicInfo}`;
                })
                .join('\n');
        } else {
            strategiesText = "- Nessuna strategia caricata al momento.";
        }

        // Get Global Stats safely
        const stats = window.globalStats || { total: 0, wins: 0, losses: 0, winrate: 0 };

        return `
Sei **euGENIO üßû‚Äç‚ôÇÔ∏è**, l'assistente speciale di Tipster-AI.
Parla al plurale o in terza persona come se fossi il team di esperti (es. "Noi di TipsterAI", "Gli esperti di TipsterAI", "La magia di TipsterAI").
Il tuo interlocutore si chiama **${userName}**.

**REGOLA D'ORO SUI SALUTI:**
- Saluta l'utente (es. "Ciao ${userName}!") **SOLO** nel primissimo messaggio della conversazione.
- In tutte le risposte successive, **NON SALUTARE**. Vai dritto al punto. Sii scorrevole e diretto.

**I NOSTRI NUMERI STRAORDINARI:**
Abbiamo analizzato **${stats.total}** partite totali.
Vittorie: **${stats.wins}** üèÜ
Sconfitte: **${stats.losses}**
Winrate Attuale: **${stats.winrate}%** üî•
Usa questi numeri per vantarti dei risultati quando opportuno!

**LA TUA MISSIONE:**
Il nostro compito √® aiutare l'utente a selezionare, tra tutte le partite che si giocano oggi, quelle con la pi√π alta percentuale di successo.
Analizziamo migliaia di partite per offrire le migliori opportunit√†.
L'utente deve scegliere quale strategia utilizzare tra quelle proposte, e noi forniamo le partite pronte con tutte le informazioni per giocare nel bookmaker preferito.
Ricorda sempre di promuovere il **gioco responsabile**: il betting deve essere un divertimento, non una fonte di reddito garantita.

**COME RISPONDERE A "COME FUNZIONA?":**
Se l'utente chiede come funziona, rispondi con enfasi:
"Il nostro compito √® analizzare migliaia di partite ogni giorno per trovare quelle con la pi√π alta probabilit√† di successo. Tu devi solo scegliere una delle nostre strategie vincenti (come Magia AI o Winrate 80%) e noi ti mostriamo le migliori opportunit√† pronte da giocare. Semplice, veloce e basato sui dati!"

**STRATEGIE ATTIVE OGGI:**
${strategiesText}

**ELEMENTI APP:**
1. **Mie Partite**: L'utente pu√≤ salvare le partite preferite (stella ‚≠ê).
2. **Badge Rossi**: Indicano le "Partite Calde" o le opportunit√† attive per quella strategia. Pi√π alto √® il numero, pi√π occasioni ci sono!
3. **Filtri**: Si possono ordinare le partite per Ranking üìä (migliori prima) o Orario üïê.

**TONO DI VOCE:**
- Professionale ma amichevole ed entusiasta.
- Usa emoji calcistiche e "magic" (‚öΩ, ü™Ñ, üî•, üìä).
- Risposte concise (max 3-4 righe) ma complete.

**REGOLE DI VERIT√Ä (IMPORTANTE):**
1. **NON INVENTARE**: Se una strategia si chiama "Top EU", include SOLO leghe Europee. Non dire MAI che include Africa o Asia.
2. **FIDATI DEI DATI**: Usa SOLO le leghe elencate in "Definizione Leghe" o "Partite Attive". Se una lega non c'√®, NON C'√à.
3. **AMMETTI L'IGNORANZA**: Se l'utente chiede di una lega che non vedi nella lista, rispondi: "Mi dispiace, quella lega non √® inclusa nelle strategie attive oggi." Non inventare scuse "dinamiche".

**SUPER POTERI (AZIONI):**
Se l'utente ti chiede di aggiungere partite ai preferiti (es. "Metti la Juve nei preferiti" o "Aggiungi Eredivisie"), TU PUOI FARLO!
Usa questo comando speciale alla fine della frase:
\`[[CMD:ADD_MATCHES|Query]]\`

Esempio:
Utente: "Aggiungi le partite di Eredivisie" -> Tu: "Fatto! üåü [[CMD:ADD_MATCHES|Eredivisie]]"
Utente: "Salva la partita della Juve" -> Tu: "Aggiunta! ‚öΩ [[CMD:ADD_MATCHES|Juventus]]"

IMPORTANTE: La Query pu√≤ essere il nome di una lega o di una squadra.

**GESTIONE PROPOSTE STRATEGIE:**
Se l'utente propone una NUOVA strategia (es. "Voglio una strategia sugli 0-0"), rispondi cos√¨:
1. Fai i complimenti per l'idea ("Interessante dal punto di vista statistico!").
2. Spiega che al momento usiamo solo le nostre strategie ottimizzate (Magia AI, Winrate 80%).
3. Invita a scrivere a: **proposte@tipster-ai.it**.
4. Offriti di preparare la bozza della mail: "Se vuoi, posso preparare io la bozza della mail per te. Dimmi solo 'S√¨' o 'Prepara mail'".

Se l'utente dice S√å (o "prepara mail"):
Usa il comando: \`[[CMD:EMAIL|Oggetto|Corpo]]\`
Esempio: \`[[CMD:EMAIL|Proposta Strategia 0-0|Ciao Team, vorrei proporre una strategia basata sui pareggi 0-0...]]\`
`;
    }

    // ACTION: Add Matches by Query (League or Team)
    async function addMatches(query) {
        if (!window.strategiesData) return;

        const target = query.toLowerCase().trim();
        let addedCount = 0;
        let matchesToAdd = [];

        // Search in all strategies
        Object.values(window.strategiesData).forEach(strat => {
            if (strat.matches) {
                strat.matches.forEach(m => {
                    // Search in League OR Match Title (Home/Away)
                    if (m.lega.toLowerCase().includes(target) || m.partita.toLowerCase().includes(target)) {
                        // Check if not already selected (use window.selectedMatches)
                        const currentMatches = window.selectedMatches || [];
                        const matchId = `${m.data}_${m.partita}`;

                        if (!currentMatches.some(sm => sm.id === matchId)) {
                            // Avoid duplicates in this batch
                            if (!matchesToAdd.some(nm => nm.id === matchId)) {
                                matchesToAdd.push({
                                    id: matchId,
                                    strategy: strat.name,
                                    ...m
                                });
                            }
                        }
                    }
                });
            }
        });

        if (matchesToAdd.length > 0) {
            // Update global array
            if (!window.selectedMatches) window.selectedMatches = [];
            window.selectedMatches.push(...matchesToAdd);

            addedCount = matchesToAdd.length;

            // Save to Firebase
            try {
                await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                    matches: window.selectedMatches,
                    updated: Date.now()
                });

                // Update UI badge (if exposed)
                if (window.updateMyMatchesCount) {
                    console.log("Calling global updateMyMatchesCount...");
                    window.updateMyMatchesCount();
                } else {
                    console.warn("window.updateMyMatchesCount is NOT defined!");
                }

                // Show feedback in chat (system message)
                appendMessage(`‚úÖ <strong>Azione completata:</strong> Ho aggiunto ${addedCount} partite per "${query}" ai tuoi preferiti!`, 'ai');

            } catch (e) {
                console.error("Error saving matches via AI:", e);
                appendMessage(`‚ö†Ô∏è Errore durante il salvataggio: ${e.message}`, 'ai');
            }
        } else {
            appendMessage(`‚ö†Ô∏è Non ho trovato nuove partite per "${query}" da aggiungere.`, 'ai');
        }
    }

    // ACTION: Open Email Draft
    function openEmailDraft(subject, body) {
        const email = "tecnicoabb@gmail.com";
        const mailtoLink = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

        // Try to open mailto link (works better on iPhone with location.href)
        try {
            // On iPhone, window.open with mailto doesn't always work
            // Using location.href is more reliable
            window.location.href = mailtoLink;
            appendMessage(`‚úÖ <strong>Azione completata:</strong> Ho aperto il tuo client di posta con la bozza pronta!`, 'ai');
        } catch (e) {
            console.error('[Email] Error opening mailto:', e);
            appendMessage(`‚ö†Ô∏è Non sono riuscito ad aprire il client email. Invia manualmente a: ${email}`, 'ai');
        }
    }

    // Helper: Find Team Context (RAG-lite)
    function findTeamContext(userMessage) {
        if (!window.strategiesData) return "";

        const msg = userMessage.toLowerCase();
        // Ignore short words to avoid noise
        const words = msg.split(' ').filter(w => w.length > 3);

        let hints = [];

        Object.values(window.strategiesData).forEach(strat => {
            if (strat.matches) {
                strat.matches.forEach(m => {
                    const matchTitle = m.partita.toLowerCase();
                    // Check if any significant word from user message is in the match title
                    // e.g. "juve" in "juventus - cagliari"
                    words.forEach(w => {
                        if (matchTitle.includes(w)) {
                            hints.push({
                                team: w, // e.g. "juve"
                                match: m.partita,
                                strategy: strat.name
                            });
                        }
                    });
                });
            }
        });

        if (hints.length > 0) {
            // Group by strategy
            // "Found 'juve' in: ALL, Italia"
            const uniqueStrategies = [...new Set(hints.map(h => h.strategy))];
            return `\n[SYSTEM HINT: Ho trovato corrispondenze per la tua ricerca nelle strategie: ${uniqueStrategies.join(', ')}. Usa queste info per rispondere.]`;
        }
        return "";
    }

    // Toggle Chat
    function toggleChat() {
        isOpen = !isOpen;
        if (isOpen) {
            chatWindow.classList.remove('hidden');
            toggleBtn.classList.add('hidden');
            setTimeout(() => input.focus(), 100);

            // Welcome Message (euGENIO)
            if (!hasWelcomed) {
                const userName = getUserName();
                const welcomeMsg = `Ciao ${userName}! üëã Sono euGENIO üßû‚Äç‚ôÇÔ∏è l'assistente speciale di Tipster-AI. Sono a tua disposizione per capire l'APP e per tutte le tue curiosit√†.`;
                appendMessage(welcomeMsg, 'ai');
                hasWelcomed = true;
            }
        } else {
            chatWindow.classList.add('hidden');
            toggleBtn.classList.remove('hidden');
        }
    }

    toggleBtn.addEventListener('click', toggleChat);
    closeBtn.addEventListener('click', toggleChat);

    // Append Message to UI
    function appendMessage(text, sender) {
        const div = document.createElement('div');
        div.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

        const bubble = document.createElement('div');
        bubble.className = sender === 'user'
            ? 'bg-purple-600 text-white rounded-2xl rounded-tr-none p-3 shadow-sm max-w-[85%]'
            : 'bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm max-w-[85%] text-gray-800';

        bubble.innerHTML = text;
        div.appendChild(bubble);
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Show Loading (old version, will be replaced by new loading in submit handler)
    function showLoading() {
        const div = document.createElement('div');
        div.id = 'ai-loading';
        div.className = 'flex justify-start';
        div.innerHTML = `
                <div class="bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm">
                    <div class="flex gap-1">
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.4s"></div>
                    </div>
                </div>`;
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function removeLoading(loadingId) { // Modified to accept loadingId
        const loading = document.getElementById(loadingId);
        if (loading) loading.remove();
    }

    // Handle Submit
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const text = input.value.trim();
        if (!text) return;

        // UI Updates
        input.value = '';
        appendMessage(text, 'user');
        showLoading();

        try {
            // Initialize History if empty
            if (chatHistory.length === 0) {
                const currentSystemPrompt = buildSystemPrompt();
                chatHistory.push({
                    role: "user",
                    parts: [{ text: currentSystemPrompt }]
                });
                // Add a dummy model response to acknowledge system prompt (optional, but helps set context)
                chatHistory.push({
                    role: "model",
                    parts: [{ text: "Ok, ho capito la mia missione. Sono pronto!" }]
                });
            }

            // Add User Question to History
            chatHistory.push({
                role: "user",
                parts: [{ text: text }]
            });

            // Call Gemini API (REST) with FULL HISTORY
            const response = await fetch(`${API_URL}?key=${window.GEMINI_API_KEY}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    contents: chatHistory
                })
            });

            const data = await response.json();

            if (!response.ok) {
                // Handle specific error for leaked key
                if (data.error && data.error.message && data.error.message.includes("API key not valid")) {
                    throw new Error("API Key non valida o revocata da Google.");
                }
                throw new Error(data.error?.message || "Errore API");
            }

            const markdownText = data.candidates[0].content.parts[0].text;

            // Add Model Response to History
            chatHistory.push({
                role: "model",
                parts: [{ text: markdownText }]
            });

            // Simple Markdown to HTML
            let htmlText = markdownText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            // COMMAND PARSING
            // COMMAND PARSING
            // 1. ADD_MATCHES (Loop to handle multiple commands)
            const cmdMatchesRegex = /\[\[CMD:ADD_MATCHES\|(.*?)\]\]/;
            let matchMatches;
            while ((matchMatches = htmlText.match(cmdMatchesRegex)) !== null) {
                const query = matchMatches[1];
                console.log("AI Command detected: ADD_MATCHES", query);
                htmlText = htmlText.replace(matchMatches[0], '');
                await addMatches(query);
            }

            // 2. EMAIL (Loop to handle multiple commands)
            const cmdEmailRegex = /\[\[CMD:EMAIL\|(.*?)\|(.*?)\]\]/;
            let matchEmail;
            while ((matchEmail = htmlText.match(cmdEmailRegex)) !== null) {
                const subject = matchEmail[1];
                const body = matchEmail[2];
                console.log("AI Command detected: EMAIL", subject);
                htmlText = htmlText.replace(matchEmail[0], '');
                openEmailDraft(subject, body);
            }

            removeLoading();
            appendMessage(htmlText, 'ai');

        } catch (error) {
            console.error("AI Error Details:", error);
            removeLoading();
            appendMessage(`‚ö†Ô∏è <strong>Errore Tecnico:</strong> ${error.message}<br><br>Se vedi "API Key leaked", devi rigenerare la chiave su Google AI Studio.`, 'ai');
        }
    });
</script>
</body>

</html>